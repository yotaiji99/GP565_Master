#ifndef GP_WB_PROP_H
#define GP_WB_PROP_H

/***************************
 * layout: plme
 ***************************/

/* dont use this address */
#define GP_WB_READ_PLME_ILLEGAL_ADDRESS() \
        GP_WB_READ_U8(0x000)


/* tranceiver state, 0=trx_off/1=rx_on/2=tx_on/3=cal, status from design */
#define GP_WB_READ_PLME_TRX_STATE_STATUS() \
        GP_WB_READ_U8(0x001)


/* CCA energy detect threshold */
#define GP_WB_READ_PLME_CCA_ED_THRESH() \
        GP_WB_READ_U8(0x002)

#define GP_WB_WRITE_PLME_CCA_ED_THRESH(val) do { \
          GP_WB_WRITE_U8(0x002, (val)); \
        } while (0)


/* Sets the divide factor for the prescaler. The prescaled frequency is 16MHz/(2**prescale_div) */
#define GP_WB_READ_PLME_SIG_GEN_PRESCALE_DIV() \
        GP_WB_READ_U8(0x003)

#define GP_WB_WRITE_PLME_SIG_GEN_PRESCALE_DIV(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x003, (val)); \
        } while (0)


/* Sets the start pointer for the pattern descriptors (16 bit word address - using memory map address) */
#define GP_WB_READ_PLME_SIG_GEN_PATTERN_DESCRIPTOR_PTR() \
        GP_WB_READ_U24(0x004)

#define GP_WB_WRITE_PLME_SIG_GEN_PATTERN_DESCRIPTOR_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03FFFF); \
          GP_WB_WRITE_U24(0x004, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION_CONTROL() \
        GP_WB_READ_U8(0x007)

#define GP_WB_WRITE_PLME_SIG_GEN_TRANSITION_CONTROL(val) \
      GP_WB_WRITE_U8(0x007, (val))

/* Determines what transition will be done e.g. off 2 tx or tx to rx, ... (should actually be set by the design ... is here for test purposes) */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION() \
        (GP_WB_READ_U8(0x007) & 0x0F)

#define GP_WB_GET_PLME_SIG_GEN_TRANSITION_FROM_SIG_GEN_TRANSITION_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PLME_SIG_GEN_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x007, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PLME_SIG_GEN_TRANSITION_TO_SIG_GEN_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set to true when you want to trigger patterns fromn the regmap (when set to FALSE, the design controls the triggering of the sequences) */
#define GP_WB_READ_PLME_SIG_GEN_TRIGGER_FROM_REGMAP() \
        GP_WB_READ_U1(0x007, 4)

#define GP_WB_GET_PLME_SIG_GEN_TRIGGER_FROM_REGMAP_FROM_SIG_GEN_TRANSITION_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PLME_SIG_GEN_TRIGGER_FROM_REGMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x007, 4, (val)); \
        } while (0)

#define GP_WB_SET_PLME_SIG_GEN_TRIGGER_FROM_REGMAP_TO_SIG_GEN_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_PLME_SIG_GEN_SEQUENCE_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x008, (val))

/* Fire of a ram sequence */
#define GP_WB_PLME_START_RAM_SEQUENCER() \
        GP_WB_WRITE_U8(0x008, 0x01)

#define GP_WB_SET_PLME_START_RAM_SEQUENCER_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Aborts the ongoing sequence entirely */
#define GP_WB_PLME_ABORT_SEQUENCE() \
        GP_WB_WRITE_U8(0x008, 0x02)

#define GP_WB_SET_PLME_ABORT_SEQUENCE_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* interrupt clear */
#define GP_WB_PLME_CLR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(0x008, 0x04)

#define GP_WB_SET_PLME_CLR_SEQUENCE_DONE_INTERRUPT_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* This triggers a repeating pattern to stop repeating */
#define GP_WB_PLME_STOP_REPEAT() \
        GP_WB_WRITE_U8(0x008, 0x08)

#define GP_WB_SET_PLME_STOP_REPEAT_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_SIG_GEN_SEQUENCE_STATUS() \
        GP_WB_READ_U8(0x009)

/* ram sequence is ongoing */
#define GP_WB_READ_PLME_SIG_GEN_BUSY() \
        GP_WB_READ_U1(0x009, 0)

#define GP_WB_GET_PLME_SIG_GEN_BUSY_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        ((tmp) & 0x01)

/* indicates that the ram sequence was aborted because of a memory access err-or */
#define GP_WB_READ_PLME_SIG_GEN_MEM_ERR() \
        GP_WB_READ_U1(0x009, 1)

#define GP_WB_GET_PLME_SIG_GEN_MEM_ERR_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked interrupt status of the interrupt triggered by finishing a ram sequence */
#define GP_WB_READ_PLME_UNMASKED_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x009, 2)

#define GP_WB_GET_PLME_UNMASKED_SEQUENCE_DONE_INTERRUPT_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates what state transition is currently being executed - only really meaningful when busy is true */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION_OBSERVE() \
        ((GP_WB_READ_U8(0x009) >> 3) & 0x0F)

#define GP_WB_GET_PLME_SIG_GEN_TRANSITION_OBSERVE_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 3) & 0x0F)


/* shows the what index in the ram sequence is currently being executed */
#define GP_WB_READ_PLME_SIG_GEN_SEQUENCE_IDX() \
        GP_WB_READ_U8(0x00a)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_DUTY_CYCLE_TRANSITION_CONTROL() \
        GP_WB_READ_U8(0x00b)

#define GP_WB_WRITE_PLME_DUTY_CYCLE_TRANSITION_CONTROL(val) \
      GP_WB_WRITE_U8(0x00b, (val))

/* Selects the transition that will be played out when the phy starts/restarts the duty cycling mode (so a low power listening mode) */
#define GP_WB_READ_PLME_DUTY_CYCLING_START_TRANSITION() \
        (GP_WB_READ_U8(0x00b) & 0x0F)

#define GP_WB_GET_PLME_DUTY_CYCLING_START_TRANSITION_FROM_DUTY_CYCLE_TRANSITION_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PLME_DUTY_CYCLING_START_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x00b, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DUTY_CYCLING_START_TRANSITION_TO_DUTY_CYCLE_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Selects the transition that will be played out when the phy stops/aborts the duty cycling mode (so e.g when going from preamble to data phase) */
#define GP_WB_READ_PLME_DUTY_CYCLING_STOP_TRANSITION() \
        ((GP_WB_READ_U8(0x00b) >> 4) & 0x0F)

#define GP_WB_GET_PLME_DUTY_CYCLING_STOP_TRANSITION_FROM_DUTY_CYCLE_TRANSITION_CONTROL(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PLME_DUTY_CYCLING_STOP_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x00b, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PLME_DUTY_CYCLING_STOP_TRANSITION_TO_DUTY_CYCLE_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_CHANNEL_CONTROL_DEBUG() \
        GP_WB_READ_U8(0x00c)

#define GP_WB_WRITE_PLME_CHANNEL_CONTROL_DEBUG(val) \
      GP_WB_WRITE_U8(0x00c, (val))

/* In normal operation, channel updates will be triggered by the mac. This option disables mac channel updates */
#define GP_WB_READ_PLME_DISABLE_MAC_CHANNEL_UPDATE() \
        GP_WB_READ_U1(0x00c, 0)

#define GP_WB_GET_PLME_DISABLE_MAC_CHANNEL_UPDATE_FROM_CHANNEL_CONTROL_DEBUG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_MAC_CHANNEL_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00c, 0, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_MAC_CHANNEL_UPDATE_TO_CHANNEL_CONTROL_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* In normal operation, the mac can force the phy to be in single channel mode (e.g for TX). This option disables mac channel forcing */
#define GP_WB_READ_PLME_DISABLE_MAC_CHANNEL_FORCE() \
        GP_WB_READ_U1(0x00c, 1)

#define GP_WB_GET_PLME_DISABLE_MAC_CHANNEL_FORCE_FROM_CHANNEL_CONTROL_DEBUG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_MAC_CHANNEL_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00c, 1, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_MAC_CHANNEL_FORCE_TO_CHANNEL_CONTROL_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables overruling the channel used */
#define GP_WB_READ_PLME_CHANNEL_OVERRULE_ENA() \
        GP_WB_READ_U1(0x00c, 2)

#define GP_WB_GET_PLME_CHANNEL_OVERRULE_ENA_FROM_CHANNEL_CONTROL_DEBUG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PLME_CHANNEL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00c, 2, (val)); \
        } while (0)

#define GP_WB_SET_PLME_CHANNEL_OVERRULE_ENA_TO_CHANNEL_CONTROL_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* The channel that is used in overrule mode (so when overrule_ena is 1) - This channel is really the channel used by the FLL and the rest of the design. So the overrule happens at the very last point */
#define GP_WB_READ_PLME_CHANNEL_OVERRULE() \
        ((GP_WB_READ_U8(0x00c) >> 3) & 0x0F)

#define GP_WB_GET_PLME_CHANNEL_OVERRULE_FROM_CHANNEL_CONTROL_DEBUG(tmp) \
        (((tmp) >> 3) & 0x0F)

#define GP_WB_WRITE_PLME_CHANNEL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x00c, 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_PLME_CHANNEL_OVERRULE_TO_CHANNEL_CONTROL_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x87; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When enabled, this setting will force a virtual channel transition on each receiver channel slot when using multichannel mode, even if the channel in consecutive slots is the same channel */
#define GP_WB_READ_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT() \
        GP_WB_READ_U1(0x00c, 7)

#define GP_WB_GET_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT_FROM_CHANNEL_CONTROL_DEBUG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00c, 7, (val)); \
        } while (0)

#define GP_WB_SET_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT_TO_CHANNEL_CONTROL_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* direct channel configuration interface for a channel - the value set will take effect when apply_channel_* is triggered. The channel will then be applied to the appropriate index */
#define GP_WB_READ_PLME_CHANNEL_SET() \
        GP_WB_READ_U8(0x00d)

#define GP_WB_WRITE_PLME_CHANNEL_SET(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x00d, (val)); \
        } while (0)


#define GP_WB_WRITE_PLME_APPLY_CHANNEL(val) \
      GP_WB_WRITE_U8(0x00e, (val))

/* when triggered channel 0 will be set to the value defined in channel_0 */
#define GP_WB_PLME_APPLY_CHANNEL_0() \
        GP_WB_WRITE_U8(0x00e, 0x01)

#define GP_WB_SET_PLME_APPLY_CHANNEL_0_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when triggered channel 0 will be set to the value defined in channel_0 */
#define GP_WB_PLME_APPLY_CHANNEL_1() \
        GP_WB_WRITE_U8(0x00e, 0x02)

#define GP_WB_SET_PLME_APPLY_CHANNEL_1_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when triggered channel 2 will be set to the value defined in channel_2 */
#define GP_WB_PLME_APPLY_CHANNEL_2() \
        GP_WB_WRITE_U8(0x00e, 0x04)

#define GP_WB_SET_PLME_APPLY_CHANNEL_2_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when triggered channel 3 will be set to the value defined in channel_3 */
#define GP_WB_PLME_APPLY_CHANNEL_3() \
        GP_WB_WRITE_U8(0x00e, 0x08)

#define GP_WB_SET_PLME_APPLY_CHANNEL_3_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when triggered channel 4 will be set to the value defined in channel_4 */
#define GP_WB_PLME_APPLY_CHANNEL_4() \
        GP_WB_WRITE_U8(0x00e, 0x10)

#define GP_WB_SET_PLME_APPLY_CHANNEL_4_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* when triggered channel 5 will be set to the value defined in channel_5 */
#define GP_WB_PLME_APPLY_CHANNEL_5() \
        GP_WB_WRITE_U8(0x00e, 0x20)

#define GP_WB_SET_PLME_APPLY_CHANNEL_5_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_CHANNEL_PREAMBLE_DETECT_DISABLE() \
        GP_WB_READ_U8(0x00f)

#define GP_WB_WRITE_PLME_CHANNEL_PREAMBLE_DETECT_DISABLE(val) \
      GP_WB_WRITE_U8(0x00f, (val))

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 0 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0() \
        GP_WB_READ_U1(0x00f, 0)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 0, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 1 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1() \
        GP_WB_READ_U1(0x00f, 1)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 1, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 2 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2() \
        GP_WB_READ_U1(0x00f, 2)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 2, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 3 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3() \
        GP_WB_READ_U1(0x00f, 3)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 3, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 4 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4() \
        GP_WB_READ_U1(0x00f, 4)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 4, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 5 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5() \
        GP_WB_READ_U1(0x00f, 5)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x00f, 5, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_STATUS_0() \
        GP_WB_READ_U8(0x010)

/* channel 0 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_0() \
        (GP_WB_READ_U8(0x010) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_0_FROM_ACTIVE_CHANNEL_STATUS_0(tmp) \
        ((tmp) & 0x0F)

/* channel 1 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_1() \
        ((GP_WB_READ_U8(0x010) >> 4) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_1_FROM_ACTIVE_CHANNEL_STATUS_0(tmp) \
        (((tmp) >> 4) & 0x0F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_STATUS_1() \
        GP_WB_READ_U8(0x011)

/* channel 2 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_2() \
        (GP_WB_READ_U8(0x011) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_2_FROM_ACTIVE_CHANNEL_STATUS_1(tmp) \
        ((tmp) & 0x0F)

/* channel 3 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_3() \
        ((GP_WB_READ_U8(0x011) >> 4) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_3_FROM_ACTIVE_CHANNEL_STATUS_1(tmp) \
        (((tmp) >> 4) & 0x0F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_STATUS_2() \
        GP_WB_READ_U8(0x012)

/* channel 4 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_4() \
        (GP_WB_READ_U8(0x012) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_4_FROM_ACTIVE_CHANNEL_STATUS_2(tmp) \
        ((tmp) & 0x0F)

/* channel 5 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_5() \
        ((GP_WB_READ_U8(0x012) >> 4) & 0x0F)

#define GP_WB_GET_PLME_ACTIVE_CHANNEL_5_FROM_ACTIVE_CHANNEL_STATUS_2(tmp) \
        (((tmp) >> 4) & 0x0F)


/* Indicates what channel indexes use the currently active channel as a mask */
#define GP_WB_READ_PLME_MATCHING_CH_IDX_MASK() \
        GP_WB_READ_U8(0x013)


#define GP_WB_WRITE_PLME_CLR_RSSI_FOR_CHANNEL(val) \
      GP_WB_WRITE_U8(0x014, (val))

/* when triggered the max hold rssi for channel idx 0 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_0() \
        GP_WB_WRITE_U8(0x014, 0x01)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_0_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when triggered the max hold rssi for channel idx 0 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_1() \
        GP_WB_WRITE_U8(0x014, 0x02)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_1_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when triggered the max hold rssi for channel idx 2 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_2() \
        GP_WB_WRITE_U8(0x014, 0x04)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_2_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when triggered the max hold rssi for channel idx 3 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_3() \
        GP_WB_WRITE_U8(0x014, 0x08)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_3_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when triggered the max hold rssi for channel idx 4 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_4() \
        GP_WB_WRITE_U8(0x014, 0x10)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_4_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* when triggered the max hold rssi for channel idx 5 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_5() \
        GP_WB_WRITE_U8(0x014, 0x20)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_5_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Max hold rssi value for channel idx 0. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_0() \
        GP_WB_READ_U8(0x015)


/* Max hold rssi value for channel idx 1. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_1() \
        GP_WB_READ_U8(0x016)


/* Max hold rssi value for channel idx 2. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_2() \
        GP_WB_READ_U8(0x017)


/* Max hold rssi value for channel idx 3. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_3() \
        GP_WB_READ_U8(0x018)


/* Max hold rssi value for channel idx 4. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_4() \
        GP_WB_READ_U8(0x019)


/* Max hold rssi value for channel idx 5. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_5() \
        GP_WB_READ_U8(0x01a)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_RSSI_VALID() \
        GP_WB_READ_U8(0x01b)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 0 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_0() \
        GP_WB_READ_U1(0x01b, 0)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_0_FROM_RSSI_VALID(tmp) \
        ((tmp) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 1 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_1() \
        GP_WB_READ_U1(0x01b, 1)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_1_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 2 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_2() \
        GP_WB_READ_U1(0x01b, 2)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_2_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 3 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_3() \
        GP_WB_READ_U1(0x01b, 3)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_3_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 4 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_4() \
        GP_WB_READ_U1(0x01b, 4)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_4_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 5 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_5() \
        GP_WB_READ_U1(0x01b, 5)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_5_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 5) & 0x01)

/***************************
 * layout: rx
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RX_ANTSEL() \
        GP_WB_READ_U8(0x080)

#define GP_WB_WRITE_RX_RX_ANTSEL(val) \
      GP_WB_WRITE_U8(0x080, (val))

/* Rx antenna select internal: 0=ant_sel/1='0'/2='1' */
#define GP_WB_READ_RX_RX_ANTSEL_INT() \
        (GP_WB_READ_U8(0x080) & 0x03)

#define GP_WB_GET_RX_RX_ANTSEL_INT_FROM_RX_ANTSEL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RX_RX_ANTSEL_INT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x080, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_RX_ANTSEL_INT_TO_RX_ANTSEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Rx antenna select external: 0='0'/1='1'/2=ant_sel/3=~ant_sel */
#define GP_WB_READ_RX_RX_ANTSEL_EXT() \
        ((GP_WB_READ_U8(0x080) >> 2) & 0x03)

#define GP_WB_GET_RX_RX_ANTSEL_EXT_FROM_RX_ANTSEL(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_RX_RX_ANTSEL_EXT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x080, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RX_RX_ANTSEL_EXT_TO_RX_ANTSEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* limiter I output for (real) random seed generation */
#define GP_WB_READ_RX_LIMITER_OUT_I() \
        GP_WB_READ_U8(0x081)


/* limiter Q output for (real) random seed generation */
#define GP_WB_READ_RX_LIMITER_OUT_Q() \
        GP_WB_READ_U8(0x082)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BBPRX_CONFIG_0() \
        GP_WB_READ_U8(0x083)

#define GP_WB_WRITE_RX_BBPRX_CONFIG_0(val) \
      GP_WB_WRITE_U8(0x083, (val))

/* antenna to use when antenna diversity is not enabled */
#define GP_WB_READ_RX_ANT_USE() \
        GP_WB_READ_U1(0x083, 1)

#define GP_WB_GET_RX_ANT_USE_FROM_BBPRX_CONFIG_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_ANT_USE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x083, 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_ANT_USE_TO_BBPRX_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0C; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enable Packet In Packet detection */
#define GP_WB_READ_RX_EN_PIP() \
        GP_WB_READ_U1(0x083, 2)

#define GP_WB_GET_RX_EN_PIP_FROM_BBPRX_CONFIG_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_EN_PIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x083, 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_PIP_TO_BBPRX_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0A; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Range switch for lqi measurment (1 is full range/low resolution, 0 is limited range/high resolution) */
#define GP_WB_READ_RX_LQI_RANGE_SWITCH() \
        GP_WB_READ_U1(0x083, 3)

#define GP_WB_GET_RX_LQI_RANGE_SWITCH_FROM_BBPRX_CONFIG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_LQI_RANGE_SWITCH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x083, 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_LQI_RANGE_SWITCH_TO_BBPRX_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BBPRX_CONFIG_1() \
        GP_WB_READ_U8(0x084)

#define GP_WB_WRITE_RX_BBPRX_CONFIG_1(val) \
      GP_WB_WRITE_U8(0x084, (val))

/* Sign for fll mode frequency compensation */
#define GP_WB_READ_RX_FLL_FREQ_COMP_SIGN() \
        GP_WB_READ_U1(0x084, 3)

#define GP_WB_GET_RX_FLL_FREQ_COMP_SIGN_FROM_BBPRX_CONFIG_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_FLL_FREQ_COMP_SIGN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x084, 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_FLL_FREQ_COMP_SIGN_TO_BBPRX_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF0; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* This flag determines whether the BBPRX controls the on/off switching of the radio through phytransitions, or whether the phy signal generator itself generates a dutycycle pattern (triggered by training start and training stop) */
#define GP_WB_READ_RX_USE_BBPRX_DUTY_CYCLING() \
        GP_WB_READ_U1(0x084, 4)

#define GP_WB_GET_RX_USE_BBPRX_DUTY_CYCLING_FROM_BBPRX_CONFIG_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_USE_BBPRX_DUTY_CYCLING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x084, 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_USE_BBPRX_DUTY_CYCLING_TO_BBPRX_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xE8; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1 the multichannel mode is enabled */
#define GP_WB_READ_RX_RX_MODE() \
        ((GP_WB_READ_U8(0x084) >> 5) & 0x07)

#define GP_WB_GET_RX_RX_MODE_FROM_BBPRX_CONFIG_1(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_WRITE_RX_RX_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x084, 0xE0, (val) << 5); \
        } while (0)

#define GP_WB_SET_RX_RX_MODE_TO_BBPRX_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x18; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* preamble detect threshold */
#define GP_WB_READ_RX_PREAMBLE_THRESH() \
        GP_WB_READ_U8(0x085)

#define GP_WB_WRITE_RX_PREAMBLE_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_WRITE_U8(0x085, (val)); \
        } while (0)


/* Low power preamble detect threshold */
#define GP_WB_READ_RX_PREAMBLE_THRESH_LP() \
        GP_WB_READ_U8(0x086)

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_LP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_WRITE_U8(0x086, (val)); \
        } while (0)


/* symbol sample start, low part */
#define GP_WB_READ_RX_SYMBOL_SAMPLE_START_0() \
        GP_WB_READ_U8(0x087)

#define GP_WB_WRITE_RX_SYMBOL_SAMPLE_START_0(val) do { \
          GP_WB_WRITE_U8(0x087, (val)); \
        } while (0)


/* timeout quard timer */
#define GP_WB_READ_RX_TIMEOUT_QUARD_TIMER() \
        GP_WB_READ_U8(0x088)

#define GP_WB_WRITE_RX_TIMEOUT_QUARD_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x088, (val)); \
        } while (0)


/* Amount of time (in 8MHz periods) that will pass between the BBPRX being enabled and the start of the actual listening */
#define GP_WB_READ_RX_START_LISTENING_FROM_RX_ON_DELAY() \
        GP_WB_READ_U8(0x089)

#define GP_WB_WRITE_RX_START_LISTENING_FROM_RX_ON_DELAY(val) do { \
          GP_WB_WRITE_U8(0x089, (val)); \
        } while (0)


/* Amount of time (in 8MHz periods) that will pass between the sequence trigger and the start of the internal houskeeping */
#define GP_WB_READ_RX_SEQUENCE_TRIGGER_TO_INTERNAL_DELAY() \
        GP_WB_READ_U8(0x08a)

#define GP_WB_WRITE_RX_SEQUENCE_TRIGGER_TO_INTERNAL_DELAY(val) do { \
          GP_WB_WRITE_U8(0x08a, (val)); \
        } while (0)


/* Packet In Packet threshold */
#define GP_WB_READ_RX_PIP_THRESH() \
        GP_WB_READ_U8(0x08b)

#define GP_WB_WRITE_RX_PIP_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x08b, (val)); \
        } while (0)


/* antenna switch variable delay (8MHz periods) */
#define GP_WB_READ_RX_ANT_SW_VAR_DELAY() \
        GP_WB_READ_U8(0x08c)

#define GP_WB_WRITE_RX_ANT_SW_VAR_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x08c, (val)); \
        } while (0)


/* Half of the channel change duration in 8MHz period (theoretically equalt to 2.5us) */
#define GP_WB_READ_RX_CH_CHANGE_TUNING() \
        GP_WB_READ_U8(0x08d)

#define GP_WB_WRITE_RX_CH_CHANGE_TUNING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x08d, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BBPRX_EVENT() \
        GP_WB_READ_U8(0x08e)

/* preamble detect event */
#define GP_WB_READ_RX_PREAMPLE_DET_EV() \
        GP_WB_READ_U1(0x08e, 0)

#define GP_WB_GET_RX_PREAMPLE_DET_EV_FROM_BBPRX_EVENT(tmp) \
        ((tmp) & 0x01)

/* SFD detect event */
#define GP_WB_READ_RX_SFD_DET_EV() \
        GP_WB_READ_U1(0x08e, 1)

#define GP_WB_GET_RX_SFD_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 1) & 0x01)

/* Packet In Packet detect event */
#define GP_WB_READ_RX_PIP_DET_EV() \
        GP_WB_READ_U1(0x08e, 2)

#define GP_WB_GET_RX_PIP_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 2) & 0x01)

/* Preamble validation failed event */
#define GP_WB_READ_RX_PREAMBLE_VALIDATION_FAILED_EV() \
        GP_WB_READ_U1(0x08e, 3)

#define GP_WB_GET_RX_PREAMBLE_VALIDATION_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 3) & 0x01)

/* Data phase validation failed event */
#define GP_WB_READ_RX_DATA_VALIDATION_FAILED_EV() \
        GP_WB_READ_U1(0x08e, 4)

#define GP_WB_GET_RX_DATA_VALIDATION_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 4) & 0x01)


/* Symbol timing found during the training */
#define GP_WB_READ_RX_SYMBOL_TIMING() \
        GP_WB_READ_U8(0x08f)


/* phase difference between receive and local symbol clock */
#define GP_WB_READ_RX_PHASE_RX() \
        GP_WB_READ_U8(0x090)


/* Correction to apply to the received phase */
#define GP_WB_READ_RX_PHASE_RX_CORR() \
        GP_WB_READ_U8(0x091)

#define GP_WB_WRITE_RX_PHASE_RX_CORR(val) do { \
          GP_WB_WRITE_U8(0x091, (val)); \
        } while (0)


/* frequency offset value */
#define GP_WB_READ_RX_FREQ_OFFSET() \
        GP_WB_READ_U8(0x092)


/* RSSI (Received Signal Strength Indication) from BBP-RX, not valid when multiple rx channels active */
#define GP_WB_READ_RX_RSSI_BBPRX() \
        GP_WB_READ_U8(0x093)


/* antenna used for last received packet */
#define GP_WB_READ_RX_ANT_USED() \
        GP_WB_READ_U1(0x094, 0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_PDS_RX_EVENT() \
        GP_WB_READ_U8(0x095)

/* packet too large event */
#define GP_WB_READ_RX_PACKET_TOO_LARGE_EV() \
        GP_WB_READ_U1(0x095, 0)

#define GP_WB_GET_RX_PACKET_TOO_LARGE_EV_FROM_PDS_RX_EVENT(tmp) \
        ((tmp) & 0x01)

/* packet too small event */
#define GP_WB_READ_RX_PACKET_TOO_SMALL_EV() \
        GP_WB_READ_U1(0x095, 1)

#define GP_WB_GET_RX_PACKET_TOO_SMALL_EV_FROM_PDS_RX_EVENT(tmp) \
        (((tmp) >> 1) & 0x01)


/* LQI (Link Quality Indication) of last received packet */
#define GP_WB_READ_RX_LQI() \
        GP_WB_READ_U8(0x096)


/* RSSI (Received Signal Strength Indication) of last received packet */
#define GP_WB_READ_RX_RSSI() \
        GP_WB_READ_U8(0x097)


/* 0 = off (data ind used), 1 = SFD, 2 = preamble, 3 = early preamble */
#define GP_WB_READ_RX_EARLY_IND_CONFIG() \
        GP_WB_READ_U8(0x098)

#define GP_WB_WRITE_RX_EARLY_IND_CONFIG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x098, (val)); \
        } while (0)


/* Configures RSSI Low pass filter (only for PHY-MAC RSSI value),  0 = off, 1 = on, 2 = on (s)lower, 3 = on even (s)lower */
#define GP_WB_READ_RX_RSSI_FILTER_CONF() \
        GP_WB_READ_U8(0x099)

#define GP_WB_WRITE_RX_RSSI_FILTER_CONF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x099, (val)); \
        } while (0)


/* Threshold for SFD detection */
#define GP_WB_READ_RX_SFD_THRESH() \
        GP_WB_READ_U8(0x09a)

#define GP_WB_WRITE_RX_SFD_THRESH(val) do { \
          GP_WB_WRITE_U8(0x09a, (val)); \
        } while (0)


/* frequency tracking value */
#define GP_WB_READ_RX_FREQ_TRACK() \
        GP_WB_READ_U8(0x09b)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNAMIX_CONTROL_0() \
        GP_WB_READ_U8(0x09c)

#define GP_WB_WRITE_RX_LNAMIX_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x09c, (val))

/* Programming of the LNAMIX LDO voltage */
#define GP_WB_READ_RX_LNAMIX_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x09c) & 0x07), 3))

#define GP_WB_GET_RX_LNAMIX_LDO_REFBITS_FROM_LNAMIX_CONTROL_0(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_RX_LNAMIX_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x09c, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNAMIX_LDO_REFBITS_TO_LNAMIX_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x38; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Power up of the LNAMIX LDO */
#define GP_WB_READ_RX_LNAMIX_LDO_PUP() \
        GP_WB_READ_U1(0x09c, 3)

#define GP_WB_GET_RX_LNAMIX_LDO_PUP_FROM_LNAMIX_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_LNAMIX_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09c, 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNAMIX_LDO_PUP_TO_LNAMIX_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Power up of the LNAMIX LDO RDY signal */
#define GP_WB_READ_RX_LNAMIX_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x09c, 4)

#define GP_WB_GET_RX_LNAMIX_LDO_RDY_PUP_FROM_LNAMIX_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_LNAMIX_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09c, 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNAMIX_LDO_RDY_PUP_TO_LNAMIX_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Enable extra bleeding current for improvement stability */
#define GP_WB_READ_RX_LNAMIX_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x09c, 5)

#define GP_WB_GET_RX_LNAMIX_LDO_ENA_BLEED_FROM_LNAMIX_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_LNAMIX_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09c, 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNAMIX_LDO_ENA_BLEED_TO_LNAMIX_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNAMIX_CONTROL_1() \
        GP_WB_READ_U8(0x09d)

#define GP_WB_WRITE_RX_LNAMIX_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x09d, (val))

/* LNA resistor tuning bits for constant gm bias current */
#define GP_WB_READ_RX_LNA_BIAS_CTRL() \
        (GP_WB_S8((GP_WB_READ_U8(0x09d) & 0x0F), 4))

#define GP_WB_GET_RX_LNA_BIAS_CTRL_FROM_LNAMIX_CONTROL_1(tmp) \
        (GP_WB_S8(((tmp) & 0x0F), 4))

#define GP_WB_WRITE_RX_LNA_BIAS_CTRL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(0x09d, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_BIAS_CTRL_TO_LNAMIX_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          (tmp) &= 0xF0; \
          (tmp) |= (((Int8)(val)) & 0x0F); \
        } while (0)

/* Controls which biasing mode is used */
#define GP_WB_READ_RX_LNA_BIASMODE() \
        ((GP_WB_READ_U8(0x09d) >> 4) & 0x03)

#define GP_WB_GET_RX_LNA_BIASMODE_FROM_LNAMIX_CONTROL_1(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_RX_LNA_BIASMODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x09d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_LNA_BIASMODE_TO_LNAMIX_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Lna resistor bypass setting */
#define GP_WB_READ_RX_LNA_BYPASS_RES() \
        ((GP_WB_READ_U8(0x09d) >> 6) & 0x03)

#define GP_WB_GET_RX_LNA_BYPASS_RES_FROM_LNAMIX_CONTROL_1(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_RX_LNA_BYPASS_RES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x09d, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_RX_LNA_BYPASS_RES_TO_LNAMIX_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNAMIX_CONTROL_2() \
        GP_WB_READ_U8(0x09e)

#define GP_WB_WRITE_RX_LNAMIX_CONTROL_2(val) \
      GP_WB_WRITE_U8(0x09e, (val))

/* Buffer control for higher/lower current */
#define GP_WB_READ_RX_BUFFER_CTRL() \
        (GP_WB_S8((GP_WB_READ_U8(0x09e) & 0x07), 3))

#define GP_WB_GET_RX_BUFFER_CTRL_FROM_LNAMIX_CONTROL_2(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_RX_BUFFER_CTRL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x09e, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RX_BUFFER_CTRL_TO_LNAMIX_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x78; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Controls mixer biasing point on RF side */
#define GP_WB_READ_RX_MIXER_CTRL() \
        (GP_WB_S8(((GP_WB_READ_U8(0x09e) >> 3) & 0x07), 3))

#define GP_WB_GET_RX_MIXER_CTRL_FROM_LNAMIX_CONTROL_2(tmp) \
        (GP_WB_S8((((tmp) >> 3) & 0x07), 3))

#define GP_WB_WRITE_RX_MIXER_CTRL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x09e, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_MIXER_CTRL_TO_LNAMIX_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x47; \
          (tmp) |= ((((Int8)(val)) << 3) & 0x38); \
        } while (0)

/* Enable the low frequency pole at the IF for blocker */
#define GP_WB_READ_RX_LNA_BLOCKER_ENA() \
        GP_WB_READ_U1(0x09e, 6)

#define GP_WB_GET_RX_LNA_BLOCKER_ENA_FROM_LNAMIX_CONTROL_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_LNA_BLOCKER_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09e, 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_BLOCKER_ENA_TO_LNAMIX_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LIMITER_CONTROL_0() \
        GP_WB_READ_U8(0x09f)

#define GP_WB_WRITE_RX_LIMITER_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x09f, (val))

/* Programming of the LIMRSSI LDO voltage */
#define GP_WB_READ_RX_LIM_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x09f) & 0x07), 3))

#define GP_WB_GET_RX_LIM_LDO_REFBITS_FROM_LIMITER_CONTROL_0(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_RX_LIM_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x09f, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_LDO_REFBITS_TO_LIMITER_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0xF8; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Bias ref bits for internal limiter bias voltage */
#define GP_WB_READ_RX_LIM_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(0x09f) >> 3) & 0x07), 3))

#define GP_WB_GET_RX_LIM_REFBITS_FROM_LIMITER_CONTROL_0(tmp) \
        (GP_WB_S8((((tmp) >> 3) & 0x07), 3))

#define GP_WB_WRITE_RX_LIM_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x09f, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_LIM_REFBITS_TO_LIMITER_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0xC7; \
          (tmp) |= ((((Int8)(val)) << 3) & 0x38); \
        } while (0)

/* Scale down LDO current factor 4: LP mode */
#define GP_WB_READ_RX_LIM_LDO_LPMODE_ENA() \
        GP_WB_READ_U1(0x09f, 6)

#define GP_WB_GET_RX_LIM_LDO_LPMODE_ENA_FROM_LIMITER_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_LIM_LDO_LPMODE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09f, 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_LDO_LPMODE_ENA_TO_LIMITER_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enable extra bleeding current for improvement stability */
#define GP_WB_READ_RX_LIM_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x09f, 7)

#define GP_WB_GET_RX_LIM_LDO_ENA_BLEED_FROM_LIMITER_CONTROL_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_LIM_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x09f, 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_LDO_ENA_BLEED_TO_LIMITER_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LIMITER_CONTROL_1() \
        GP_WB_READ_U8(0x0a0)

#define GP_WB_WRITE_RX_LIMITER_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x0a0, (val))

/* Bypass filtering resistor in LIMRSSI LDO */
#define GP_WB_READ_RX_LIM_ENA_LDO_RESBYP() \
        GP_WB_READ_U1(0x0a0, 0)

#define GP_WB_GET_RX_LIM_ENA_LDO_RESBYP_FROM_LIMITER_CONTROL_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_LIM_ENA_LDO_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a0, 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_ENA_LDO_RESBYP_TO_LIMITER_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* powers up the limiter ldo */
#define GP_WB_READ_RX_LIM_LDO_PUP() \
        GP_WB_READ_U1(0x0a0, 1)

#define GP_WB_GET_RX_LIM_LDO_PUP_FROM_LIMITER_CONTROL_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_LIM_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a0, 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_LDO_PUP_TO_LIMITER_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* powers up the limiter ldo rdy signal */
#define GP_WB_READ_RX_LIM_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x0a0, 2)

#define GP_WB_GET_RX_LIM_LDO_RDY_PUP_FROM_LIMITER_CONTROL_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_LIM_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a0, 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_LIM_LDO_RDY_PUP_TO_LIMITER_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BPF_CONTROL_0() \
        GP_WB_READ_U8(0x0a1)

#define GP_WB_WRITE_RX_BPF_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x0a1, (val))

/* Bypass the resistor in the PMOS SC-bias cell gate terminal */
#define GP_WB_READ_RX_BPF_ENA_RESBYP_P() \
        GP_WB_READ_U1(0x0a1, 0)

#define GP_WB_GET_RX_BPF_ENA_RESBYP_P_FROM_BPF_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_BPF_ENA_RESBYP_P(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a1, 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_ENA_RESBYP_P_TO_BPF_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Bypass the resistor in the NMOS SC-bias cell gate terminal */
#define GP_WB_READ_RX_BPF_ENA_RESBYP_N() \
        GP_WB_READ_U1(0x0a1, 1)

#define GP_WB_GET_RX_BPF_ENA_RESBYP_N_FROM_BPF_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_BPF_ENA_RESBYP_N(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a1, 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_ENA_RESBYP_N_TO_BPF_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Selects the upper or lower sideband for BPF */
#define GP_WB_READ_RX_BPF_SIDEB_SEL() \
        ((GP_WB_READ_U8(0x0a1) >> 2) & 0x03)

#define GP_WB_GET_RX_BPF_SIDEB_SEL_FROM_BPF_CONTROL_0(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_RX_BPF_SIDEB_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0a1, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RX_BPF_SIDEB_SEL_TO_BPF_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BPF_CONTROL_1() \
        GP_WB_READ_U8(0x0a2)

#define GP_WB_WRITE_RX_BPF_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x0a2, (val))

/* Programming of the PMOS SC-bias cell output current */
#define GP_WB_READ_RX_BPF_BIAS_TUNE_P() \
        (GP_WB_READ_U8(0x0a2) & 0x0F)

#define GP_WB_GET_RX_BPF_BIAS_TUNE_P_FROM_BPF_CONTROL_1(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_BPF_BIAS_TUNE_P(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x0a2, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_BIAS_TUNE_P_TO_BPF_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Programming of the NMOS SC-bias cell output current */
#define GP_WB_READ_RX_BPF_BIAS_TUNE_N() \
        ((GP_WB_READ_U8(0x0a2) >> 4) & 0x0F)

#define GP_WB_GET_RX_BPF_BIAS_TUNE_N_FROM_BPF_CONTROL_1(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RX_BPF_BIAS_TUNE_N(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x0a2, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BPF_BIAS_TUNE_N_TO_BPF_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BPF_CONTROL_2() \
        GP_WB_READ_U8(0x0a3)

#define GP_WB_WRITE_RX_BPF_CONTROL_2(val) \
      GP_WB_WRITE_U8(0x0a3, (val))

/* Bypass filtering resistor in BPF LDO */
#define GP_WB_READ_RX_BPF_ENA_LDO_RESBYP() \
        GP_WB_READ_U1(0x0a3, 0)

#define GP_WB_GET_RX_BPF_ENA_LDO_RESBYP_FROM_BPF_CONTROL_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_BPF_ENA_LDO_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a3, 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_ENA_LDO_RESBYP_TO_BPF_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable extra bleeding current for improvement stability */
#define GP_WB_READ_RX_BPF_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x0a3, 1)

#define GP_WB_GET_RX_BPF_LDO_ENA_BLEED_FROM_BPF_CONTROL_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_BPF_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a3, 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_LDO_ENA_BLEED_TO_BPF_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* powers up the bpf ldo */
#define GP_WB_READ_RX_BPF_LDO_PUP() \
        GP_WB_READ_U1(0x0a3, 2)

#define GP_WB_GET_RX_BPF_LDO_PUP_FROM_BPF_CONTROL_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_BPF_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a3, 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_LDO_PUP_TO_BPF_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* powers up the bpf ldo rdy signal */
#define GP_WB_READ_RX_BPF_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x0a3, 3)

#define GP_WB_GET_RX_BPF_LDO_RDY_PUP_FROM_BPF_CONTROL_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_BPF_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0a3, 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_BPF_LDO_RDY_PUP_TO_BPF_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Programming of the BPF LDO voltage */
#define GP_WB_READ_RX_BPF_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(0x0a3) >> 4) & 0x07), 3))

#define GP_WB_GET_RX_BPF_LDO_REFBITS_FROM_BPF_CONTROL_2(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x07), 3))

#define GP_WB_WRITE_RX_BPF_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x0a3, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BPF_LDO_REFBITS_TO_BPF_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x0F; \
          (tmp) |= ((((Int8)(val)) << 4) & 0x70); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LOBUF_CONFIG() \
        GP_WB_READ_U8(0x0a4)

#define GP_WB_WRITE_RX_LOBUF_CONFIG(val) \
      GP_WB_WRITE_U8(0x0a4, (val))

/* calibration of HR res in RX I/Q LO buffer */
#define GP_WB_READ_RX_LOBUF_RX_HRCAL() \
        (GP_WB_S8((GP_WB_READ_U8(0x0a4) & 0x07), 3))

#define GP_WB_GET_RX_LOBUF_RX_HRCAL_FROM_LOBUF_CONFIG(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_RX_LOBUF_RX_HRCAL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x0a4, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RX_LOBUF_RX_HRCAL_TO_LOBUF_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x18; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* RX LO buffer current control */
#define GP_WB_READ_RX_LOBUF_RX_BIASSEL() \
        ((GP_WB_READ_U8(0x0a4) >> 3) & 0x03)

#define GP_WB_GET_RX_LOBUF_RX_BIASSEL_FROM_LOBUF_CONFIG(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_RX_LOBUF_RX_BIASSEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0a4, 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_LOBUF_RX_BIASSEL_TO_LOBUF_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RX_LDO_RDY_STATUS() \
        GP_WB_READ_U8(0x0a5)

/* LDO ready signal of the LNAMIX LDO */
#define GP_WB_READ_RX_LNAMIX_LDO_RDY() \
        GP_WB_READ_U1(0x0a5, 0)

#define GP_WB_GET_RX_LNAMIX_LDO_RDY_FROM_RX_LDO_RDY_STATUS(tmp) \
        ((tmp) & 0x01)

/* LDO ready signal of LIMRSSI LDO */
#define GP_WB_READ_RX_LIM_LDO_RDY() \
        GP_WB_READ_U1(0x0a5, 1)

#define GP_WB_GET_RX_LIM_LDO_RDY_FROM_RX_LDO_RDY_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* LDO ready signal of the BPF LDO */
#define GP_WB_READ_RX_BPF_LDO_RDY() \
        GP_WB_READ_U1(0x0a5, 2)

#define GP_WB_GET_RX_BPF_LDO_RDY_FROM_RX_LDO_RDY_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Frequency compensation added to 2 MHz IF. Signed value with resolution of 4 kHz,  -128..127 = -512...508 kHz */
#define GP_WB_READ_RX_FREQUENCY_COMPENSATION() \
        (GP_WB_S8(GP_WB_READ_U8(0x0a6), 8))

#define GP_WB_WRITE_RX_FREQUENCY_COMPENSATION(val) do { \
          GP_WB_WRITE_U8(0x0a6, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_OFFSET() \
        GP_WB_READ_U24(0x0a8)

#define GP_WB_WRITE_RX_RSSI_OFFSET(val) \
      GP_WB_WRITE_U24(0x0a8, (val))

/* Calibrated offset compensation setting A, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_A() \
        (GP_WB_S8(GP_WB_READ_U8(0x0a8), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_A_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8(((tmp) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_A(val) do { \
          GP_WB_WRITE_U8(0x0a8, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_A_TO_RSSI_OFFSET(tmp, val) do { \
          (tmp) &= 0x01FF00; \
          (tmp) |= (((Int32)(val)) & 0x0000FF); \
        } while (0)

/* Calibrated offset compensation setting B, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_B() \
        (GP_WB_S8(GP_WB_READ_U8(0x0a9), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_B_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 8) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_B(val) do { \
          GP_WB_WRITE_U8(0x0a9, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_B_TO_RSSI_OFFSET(tmp, val) do { \
          (tmp) &= 0x0100FF; \
          (tmp) |= ((((Int32)(val)) << 8) & 0x00FF00); \
        } while (0)

/* Selects one of the calibrated offset compensation settings */
#define GP_WB_READ_RX_RSSI_OFFSET_SEL() \
        GP_WB_READ_U1(0x0aa, 0)

#define GP_WB_GET_RX_RSSI_OFFSET_SEL_FROM_RSSI_OFFSET(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_RX_RSSI_OFFSET_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x0aa, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_SEL_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_OVERRULE_SETTINGS() \
        GP_WB_READ_U16(0x0ac)

#define GP_WB_WRITE_RX_RSSI_OVERRULE_SETTINGS(val) \
      GP_WB_WRITE_U16(0x0ac, (val))

/* RSSI overrule value */
#define GP_WB_READ_RX_RSSI_OVERRULE() \
        GP_WB_READ_U8(0x0ac)

#define GP_WB_GET_RX_RSSI_OVERRULE_FROM_RSSI_OVERRULE_SETTINGS(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_OVERRULE(val) do { \
          GP_WB_WRITE_U8(0x0ac, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OVERRULE_TO_RSSI_OVERRULE_SETTINGS(tmp, val) do { \
          (tmp) &= 0x0100; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* RSSI overrule enable bit, if set to 1 the RSSI of the received packets is forced to RSSI_OVERRULE */
#define GP_WB_READ_RX_RSSI_OVERRULE_ENA() \
        GP_WB_READ_U1(0x0ad, 0)

#define GP_WB_GET_RX_RSSI_OVERRULE_ENA_FROM_RSSI_OVERRULE_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_RSSI_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x0ad, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OVERRULE_ENA_TO_RSSI_OVERRULE_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* The validation logic is enabled when set to 1, disabled otherwise */
#define GP_WB_READ_RX_VALIDATION_EN() \
        GP_WB_READ_U1(0x0ae, 0)

#define GP_WB_WRITE_RX_VALIDATION_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x0ae, (val)); \
        } while (0)


/* Threshold for preamble validation */
#define GP_WB_READ_RX_VALIDATION_THRESH() \
        GP_WB_READ_U16(0x0b0)

#define GP_WB_WRITE_RX_VALIDATION_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01FF); \
          GP_WB_WRITE_U16(0x0b0, (val)); \
        } while (0)

/***************************
 * layout: tx
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_TX_OVERRULE_ENA() \
        GP_WB_READ_U8(0x0c0)

#define GP_WB_WRITE_TX_TX_OVERRULE_ENA(val) \
      GP_WB_WRITE_U8(0x0c0, (val))

/* enable overrule control of receive / local clock phase for Tx */
#define GP_WB_READ_TX_T_PHASE_TX_OVERRULE_ENA() \
        GP_WB_READ_U1(0x0c0, 0)

#define GP_WB_GET_TX_T_PHASE_TX_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TX_T_PHASE_TX_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c0, 0, (val)); \
        } while (0)

#define GP_WB_SET_TX_T_PHASE_TX_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enable overrule control of iso_tx */
#define GP_WB_READ_TX_ISO_TX_OVERRULE_ENA() \
        GP_WB_READ_U1(0x0c0, 1)

#define GP_WB_GET_TX_ISO_TX_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TX_ISO_TX_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c0, 1, (val)); \
        } while (0)

#define GP_WB_SET_TX_ISO_TX_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* ISO_TX, overrule value */
#define GP_WB_READ_TX_ISO_TX_OVERRULE() \
        GP_WB_READ_U1(0x0c1, 0)

#define GP_WB_WRITE_TX_ISO_TX_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x0c1, (val)); \
        } while (0)


/* receive / local clock phase for Tx, overrule value */
#define GP_WB_READ_TX_T_PHASE_TX_OVERRULE() \
        GP_WB_READ_U8(0x0c2)

#define GP_WB_WRITE_TX_T_PHASE_TX_OVERRULE(val) do { \
          GP_WB_WRITE_U8(0x0c2, (val)); \
        } while (0)


/* ISO_TX status */
#define GP_WB_READ_TX_ISO_TX_STATUS() \
        GP_WB_READ_U1(0x0c3, 0)


/* receive / local clock phase for Tx, status (determined from design) */
#define GP_WB_READ_TX_T_PHASE_TX_STATUS() \
        GP_WB_READ_U8(0x0c4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_BBPTX_CONFIG() \
        GP_WB_READ_U8(0x0c5)

#define GP_WB_WRITE_TX_BBPTX_CONFIG(val) \
      GP_WB_WRITE_U8(0x0c5, (val))

/* enable invertion of MSK data */
#define GP_WB_READ_TX_EN_INV_MSK() \
        GP_WB_READ_U1(0x0c5, 0)

#define GP_WB_GET_TX_EN_INV_MSK_FROM_BBPTX_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TX_EN_INV_MSK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c5, 0, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_INV_MSK_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enable generation of continuous modulated carrier */
#define GP_WB_READ_TX_EN_CONT_MOD() \
        GP_WB_READ_U1(0x0c5, 1)

#define GP_WB_GET_TX_EN_CONT_MOD_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TX_EN_CONT_MOD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c5, 1, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_CONT_MOD_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enable PA always on when in Tx mode */
#define GP_WB_READ_TX_EN_TX_PA_ON() \
        GP_WB_READ_U1(0x0c5, 2)

#define GP_WB_GET_TX_EN_TX_PA_ON_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TX_EN_TX_PA_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c5, 2, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_TX_PA_ON_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enable noise TX */
#define GP_WB_READ_TX_EN_TX_NOISE() \
        GP_WB_READ_U1(0x0c5, 3)

#define GP_WB_GET_TX_EN_TX_NOISE_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TX_EN_TX_NOISE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c5, 3, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_TX_NOISE_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Bypasses the the tx delay coming from the TX path (so ack phase or scheduled TX phase) */
#define GP_WB_READ_TX_BYPASS_TX_DELAY() \
        GP_WB_READ_U1(0x0c5, 4)

#define GP_WB_GET_TX_BYPASS_TX_DELAY_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TX_BYPASS_TX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c5, 4, (val)); \
        } while (0)

#define GP_WB_SET_TX_BYPASS_TX_DELAY_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* PA enable variable delay (16 MHz periods) */
#define GP_WB_READ_TX_PAEN_VAR_DELAY() \
        GP_WB_READ_U8(0x0c6)

#define GP_WB_WRITE_TX_PAEN_VAR_DELAY(val) do { \
          GP_WB_WRITE_U8(0x0c6, (val)); \
        } while (0)


/* external PA enable variable delay (16 MHz periods) */
#define GP_WB_READ_TX_TXEN_VAR_DELAY() \
        GP_WB_READ_U8(0x0c7)

#define GP_WB_WRITE_TX_TXEN_VAR_DELAY(val) do { \
          GP_WB_WRITE_U8(0x0c7, (val)); \
        } while (0)


/* Tx analog modulation variable delay (16 MHz periods) */
#define GP_WB_READ_TX_TXMA_VAR_DELAY() \
        GP_WB_READ_U8(0x0c8)

#define GP_WB_WRITE_TX_TXMA_VAR_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x0c8, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_PA_CONTROL_0() \
        GP_WB_READ_U8(0x0c9)

#define GP_WB_WRITE_TX_PA_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x0c9, (val))

/* Programming of the PA LDO voltage */
#define GP_WB_READ_TX_PA_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x0c9) & 0x07), 3))

#define GP_WB_GET_TX_PA_LDO_REFBITS_FROM_PA_CONTROL_0(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_TX_PA_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x0c9, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_LDO_REFBITS_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0xF8; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Bypass filtering resistor in PA LDO */
#define GP_WB_READ_TX_PA_LDO_ENA_RESBYP() \
        GP_WB_READ_U1(0x0c9, 3)

#define GP_WB_GET_TX_PA_LDO_ENA_RESBYP_FROM_PA_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TX_PA_LDO_ENA_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c9, 3, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_LDO_ENA_RESBYP_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enable extra bleeding current for improvement stability */
#define GP_WB_READ_TX_PA_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x0c9, 4)

#define GP_WB_GET_TX_PA_LDO_ENA_BLEED_FROM_PA_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TX_PA_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c9, 4, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_LDO_ENA_BLEED_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Disables PA output stage (signal in 1.2V-domain) */
#define GP_WB_READ_TX_PA_PADDRV_ONLY() \
        GP_WB_READ_U1(0x0c9, 5)

#define GP_WB_GET_TX_PA_PADDRV_ONLY_FROM_PA_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TX_PA_PADDRV_ONLY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c9, 5, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PADDRV_ONLY_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* powers up the pa ldo */
#define GP_WB_READ_TX_PA_LDO_PUP() \
        GP_WB_READ_U1(0x0c9, 6)

#define GP_WB_GET_TX_PA_LDO_PUP_FROM_PA_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_TX_PA_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c9, 6, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_LDO_PUP_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* powers up the pa ldo rdy signal */
#define GP_WB_READ_TX_PA_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x0c9, 7)

#define GP_WB_GET_TX_PA_LDO_RDY_PUP_FROM_PA_CONTROL_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_TX_PA_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0c9, 7, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_LDO_RDY_PUP_TO_PA_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_PA_CONTROL_1() \
        GP_WB_READ_U8(0x0ca)

#define GP_WB_WRITE_TX_PA_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x0ca, (val))

/* Calibration of the 5u PTAT current for PA and PA driver */
#define GP_WB_READ_TX_PA_RESTRIM() \
        (GP_WB_READ_U8(0x0ca) & 0x07)

#define GP_WB_GET_TX_PA_RESTRIM_FROM_PA_CONTROL_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TX_PA_RESTRIM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x0ca, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_RESTRIM_TO_PA_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* VCM LDO power-up signal in 1.2V-domain */
#define GP_WB_READ_TX_PA_VCM_LDO_PUP() \
        GP_WB_READ_U1(0x0ca, 3)

#define GP_WB_GET_TX_PA_VCM_LDO_PUP_FROM_PA_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TX_PA_VCM_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0ca, 3, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_VCM_LDO_PUP_TO_PA_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Bypass filtering res in bias of PA Driver, 1.2V */
#define GP_WB_READ_TX_PA_RES_BYP_PADDRV() \
        GP_WB_READ_U1(0x0ca, 4)

#define GP_WB_GET_TX_PA_RES_BYP_PADDRV_FROM_PA_CONTROL_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TX_PA_RES_BYP_PADDRV(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0ca, 4, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_RES_BYP_PADDRV_TO_PA_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Edge select of tx mod retiming */
#define GP_WB_READ_TX_TXMOD_RETIME_EDGE() \
        GP_WB_READ_U1(0x0ca, 5)

#define GP_WB_GET_TX_TXMOD_RETIME_EDGE_FROM_PA_CONTROL_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TX_TXMOD_RETIME_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0ca, 5, (val)); \
        } while (0)

#define GP_WB_SET_TX_TXMOD_RETIME_EDGE_TO_PA_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Retiming of txmod signals off */
#define GP_WB_READ_TX_TXMOD_RETIME_OFF() \
        GP_WB_READ_U1(0x0ca, 6)

#define GP_WB_GET_TX_TXMOD_RETIME_OFF_FROM_PA_CONTROL_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_TX_TXMOD_RETIME_OFF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x0ca, 6, (val)); \
        } while (0)

#define GP_WB_SET_TX_TXMOD_RETIME_OFF_TO_PA_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_PA_PWR_CORRECTIONS() \
        GP_WB_READ_U32(0x0cc)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTIONS(val) \
      GP_WB_WRITE_U32(0x0cc, (val))

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH0() \
        (GP_WB_READ_U8(0x0cc) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH0_FROM_PA_PWR_CORRECTIONS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cc, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH0_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFFFC; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH1() \
        ((GP_WB_READ_U8(0x0cc) >> 2) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH1_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cc, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH1_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFFF3; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH2() \
        ((GP_WB_READ_U8(0x0cc) >> 4) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH2_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cc, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH2_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFFCF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH3() \
        ((GP_WB_READ_U8(0x0cc) >> 6) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH3_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cc, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH3_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFF3F; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH4() \
        (GP_WB_READ_U8(0x0cd) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH4_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cd, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH4_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFCFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH5() \
        ((GP_WB_READ_U8(0x0cd) >> 2) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH5_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cd, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH5_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFF3FF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH6() \
        ((GP_WB_READ_U8(0x0cd) >> 4) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH6_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cd, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH6_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFCFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH7() \
        ((GP_WB_READ_U8(0x0cd) >> 6) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH7_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cd, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH7_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFF3FFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH8() \
        (GP_WB_READ_U8(0x0ce) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH8_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH8(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0ce, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH8_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFCFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH9() \
        ((GP_WB_READ_U8(0x0ce) >> 2) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH9_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH9(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0ce, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH9_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFF3FFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH10() \
        ((GP_WB_READ_U8(0x0ce) >> 4) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH10_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 20) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH10(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0ce, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH10_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFCFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH11() \
        ((GP_WB_READ_U8(0x0ce) >> 6) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH11_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH11(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0ce, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH11_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFF3FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH12() \
        (GP_WB_READ_U8(0x0cf) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH12_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 24) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH12(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cf, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH12_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFCFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH13() \
        ((GP_WB_READ_U8(0x0cf) >> 2) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH13_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 26) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH13(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cf, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH13_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH14() \
        ((GP_WB_READ_U8(0x0cf) >> 4) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH14_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 28) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH14(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cf, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH14_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

/* sets channel dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_CH15() \
        ((GP_WB_READ_U8(0x0cf) >> 6) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_CH15_FROM_PA_PWR_CORRECTIONS(tmp) \
        (((tmp) >> 30) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_CH15(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0cf, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_CH15_TO_PA_PWR_CORRECTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 30); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_PA_ANT_PWR_CORRECTION() \
        GP_WB_READ_U8(0x0d0)

#define GP_WB_WRITE_TX_PA_ANT_PWR_CORRECTION(val) \
      GP_WB_WRITE_U8(0x0d0, (val))

/* sets antenna dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_ANT0() \
        (GP_WB_READ_U8(0x0d0) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_ANT0_FROM_PA_ANT_PWR_CORRECTION(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_ANT0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0d0, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_ANT0_TO_PA_ANT_PWR_CORRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* sets antenna dependant power correction (0 -> 0dbm, 3 -> 3 dbm) */
#define GP_WB_READ_TX_PA_PWR_CORRECTION_ANT1() \
        ((GP_WB_READ_U8(0x0d0) >> 2) & 0x03)

#define GP_WB_GET_TX_PA_PWR_CORRECTION_ANT1_FROM_PA_ANT_PWR_CORRECTION(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_TX_PA_PWR_CORRECTION_ANT1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x0d0, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_PA_PWR_CORRECTION_ANT1_TO_PA_ANT_PWR_CORRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* LDO ready signal of PA LDO */
#define GP_WB_READ_TX_PA_LDO_RDY() \
        GP_WB_READ_U1(0x0d1, 0)

/***************************
 * layout: trx
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_VCO_CONTROL_0() \
        GP_WB_READ_U8(0x100)

#define GP_WB_WRITE_TRX_VCO_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x100, (val))

/* Bypass filtering res pmos mirror */
#define GP_WB_READ_TRX_VCO_ENA_RES_BYP_P() \
        GP_WB_READ_U1(0x100, 0)

#define GP_WB_GET_TRX_VCO_ENA_RES_BYP_P_FROM_VCO_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_VCO_ENA_RES_BYP_P(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x100, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_VCO_ENA_RES_BYP_P_TO_VCO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* VCO pmos mirror bias programming */
#define GP_WB_READ_TRX_VCO_PCUR() \
        ((GP_WB_READ_U8(0x100) >> 1) & 0x07)

#define GP_WB_GET_TRX_VCO_PCUR_FROM_VCO_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x07)

#define GP_WB_WRITE_TRX_VCO_PCUR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x100, 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_TRX_VCO_PCUR_TO_VCO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x71; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Calibration input to let VCO bias track with HR RES corner */
#define GP_WB_READ_TRX_VCO_HRCAL() \
        (GP_WB_S8(((GP_WB_READ_U8(0x100) >> 4) & 0x07), 3))

#define GP_WB_GET_TRX_VCO_HRCAL_FROM_VCO_CONTROL_0(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x07), 3))

#define GP_WB_WRITE_TRX_VCO_HRCAL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x100, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_VCO_HRCAL_TO_VCO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x0F; \
          (tmp) |= ((((Int8)(val)) << 4) & 0x70); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_VCO_CONTROL_1() \
        GP_WB_READ_U8(0x101)

#define GP_WB_WRITE_TRX_VCO_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x101, (val))

/* Independant control for VCO voltage level */
#define GP_WB_READ_TRX_VCO_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x101) & 0x07), 3))

#define GP_WB_GET_TRX_VCO_LDO_REFBITS_FROM_VCO_CONTROL_1(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_TRX_VCO_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x101, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_VCO_LDO_REFBITS_TO_VCO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x38; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Programmability of VCO current */
#define GP_WB_READ_TRX_VCO_RESBIAS() \
        ((GP_WB_READ_U8(0x101) >> 3) & 0x03)

#define GP_WB_GET_TRX_VCO_RESBIAS_FROM_VCO_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_TRX_VCO_RESBIAS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x101, 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_VCO_RESBIAS_TO_VCO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x27; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Debug feature - reduces power of txmod ota */
#define GP_WB_READ_TRX_TXMOD_LOWPOWER() \
        GP_WB_READ_U1(0x101, 5)

#define GP_WB_GET_TRX_TXMOD_LOWPOWER_FROM_VCO_CONTROL_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_TXMOD_LOWPOWER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x101, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TXMOD_LOWPOWER_TO_VCO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LO_CONTROL_0() \
        GP_WB_READ_U8(0x102)

#define GP_WB_WRITE_TRX_LO_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x102, (val))

/* Voltage tuning of the LOGEN LDO */
#define GP_WB_READ_TRX_LO_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x102) & 0x07), 3))

#define GP_WB_GET_TRX_LO_LDO_REFBITS_FROM_LO_CONTROL_0(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_TRX_LO_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x102, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LO_LDO_REFBITS_TO_LO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x78; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Power up of the LOGEN LDO */
#define GP_WB_READ_TRX_LO_LDO_PUP() \
        GP_WB_READ_U1(0x102, 3)

#define GP_WB_GET_TRX_LO_LDO_PUP_FROM_LO_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_LO_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x102, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LO_LDO_PUP_TO_LO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Power up of the LOGEN LDO */
#define GP_WB_READ_TRX_LO_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x102, 4)

#define GP_WB_GET_TRX_LO_LDO_RDY_PUP_FROM_LO_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_LO_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x102, 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LO_LDO_RDY_PUP_TO_LO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Bypass filtering resistor in LOGEN LDO */
#define GP_WB_READ_TRX_LO_LDO_ENA_RESBYP() \
        GP_WB_READ_U1(0x102, 5)

#define GP_WB_GET_TRX_LO_LDO_ENA_RESBYP_FROM_LO_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_LO_LDO_ENA_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x102, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LO_LDO_ENA_RESBYP_TO_LO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Enable extra bleeding current f1or improvement stability */
#define GP_WB_READ_TRX_LO_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x102, 6)

#define GP_WB_GET_TRX_LO_LDO_ENA_BLEED_FROM_LO_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_TRX_LO_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x102, 6, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LO_LDO_ENA_BLEED_TO_LO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LO_CONTROL_1() \
        GP_WB_READ_U8(0x103)

#define GP_WB_WRITE_TRX_LO_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x103, (val))

/* Bypass three resistors in LOGEN block for filtering */
#define GP_WB_READ_TRX_LOBUF_RESBYP() \
        (GP_WB_READ_U8(0x103) & 0x07)

#define GP_WB_GET_TRX_LOBUF_RESBYP_FROM_LO_CONTROL_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOBUF_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x103, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOBUF_RESBYP_TO_LO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Bypass filtering res in bias of LOGEN */
#define GP_WB_READ_TRX_LOBUF_BIAS_RESBYP_ENA() \
        GP_WB_READ_U1(0x103, 3)

#define GP_WB_GET_TRX_LOBUF_BIAS_RESBYP_ENA_FROM_LO_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_LOBUF_BIAS_RESBYP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x103, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOBUF_BIAS_RESBYP_ENA_TO_LO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Programmable bias in LOGEN */
#define GP_WB_READ_TRX_LOBUF_BIAS_PROG() \
        ((GP_WB_READ_U8(0x103) >> 4) & 0x03)

#define GP_WB_GET_TRX_LOBUF_BIAS_PROG_FROM_LO_CONTROL_1(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_TRX_LOBUF_BIAS_PROG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x103, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_LOBUF_BIAS_PROG_TO_LO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RFDIV_CONTROL_0() \
        GP_WB_READ_U8(0x104)

#define GP_WB_WRITE_TRX_RFDIV_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x104, (val))

/* Divider bias cell programming */
#define GP_WB_READ_TRX_RFDIV_BIAS_PROG() \
        (GP_WB_READ_U8(0x104) & 0x03)

#define GP_WB_GET_TRX_RFDIV_BIAS_PROG_FROM_RFDIV_CONTROL_0(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TRX_RFDIV_BIAS_PROG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x104, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RFDIV_BIAS_PROG_TO_RFDIV_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x04; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Bias resistor bypass signal */
#define GP_WB_READ_TRX_RFDIV_RESBYP_ENA() \
        GP_WB_READ_U1(0x104, 2)

#define GP_WB_GET_TRX_RFDIV_RESBYP_ENA_FROM_RFDIV_CONTROL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_RFDIV_RESBYP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x104, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RFDIV_RESBYP_ENA_TO_RFDIV_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_CONTROL_0() \
        GP_WB_READ_U8(0x105)

#define GP_WB_WRITE_TRX_FLL_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x105, (val))

/* Power up of the FLL LDO */
#define GP_WB_READ_TRX_FLL_LDO_PUP() \
        GP_WB_READ_U1(0x105, 0)

#define GP_WB_GET_TRX_FLL_LDO_PUP_FROM_FLL_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x105, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LDO_PUP_TO_FLL_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Power up of the FLL RDY LDO */
#define GP_WB_READ_TRX_FLL_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x105, 1)

#define GP_WB_GET_TRX_FLL_LDO_RDY_PUP_FROM_FLL_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x105, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LDO_RDY_PUP_TO_FLL_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Bypass filtering resistor in FLL LDO */
#define GP_WB_READ_TRX_FLL_LDO_ENA_RESBYP() \
        GP_WB_READ_U1(0x105, 2)

#define GP_WB_GET_TRX_FLL_LDO_ENA_RESBYP_FROM_FLL_CONTROL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LDO_ENA_RESBYP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x105, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LDO_ENA_RESBYP_TO_FLL_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Enable extra bleeding current for improvement stability */
#define GP_WB_READ_TRX_FLL_LDO_ENA_BLEED() \
        GP_WB_READ_U1(0x105, 3)

#define GP_WB_GET_TRX_FLL_LDO_ENA_BLEED_FROM_FLL_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LDO_ENA_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x105, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LDO_ENA_BLEED_TO_FLL_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Programming of the FLL LDO voltage */
#define GP_WB_READ_TRX_FLL_LDOREFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(0x105) >> 4) & 0x07), 3))

#define GP_WB_GET_TRX_FLL_LDOREFBITS_FROM_FLL_CONTROL_0(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x07), 3))

#define GP_WB_WRITE_TRX_FLL_LDOREFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x105, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LDOREFBITS_TO_FLL_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x0F; \
          (tmp) |= ((((Int8)(val)) << 4) & 0x70); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_DIV_MIX_SAMPLER_CP_CONTROL_0() \
        GP_WB_READ_U8(0x106)

#define GP_WB_WRITE_TRX_DIV_MIX_SAMPLER_CP_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x106, (val))

/* Selection of edge of re-timer clock for DIVSAMP Output */
#define GP_WB_READ_TRX_DIV_SAM_OUT_EDGE_SEL() \
        GP_WB_READ_U1(0x106, 0)

#define GP_WB_GET_TRX_DIV_SAM_OUT_EDGE_SEL_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_DIV_SAM_OUT_EDGE_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_DIV_SAM_OUT_EDGE_SEL_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Determines if the DIVSAMP bitstream should be Retimed or not */
#define GP_WB_READ_TRX_DIVSAM_OUT_RETIME() \
        GP_WB_READ_U1(0x106, 1)

#define GP_WB_GET_TRX_DIVSAM_OUT_RETIME_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_DIVSAM_OUT_RETIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_DIVSAM_OUT_RETIME_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Determines if the MIXSAMP bit-stream should be Retimed or not */
#define GP_WB_READ_TRX_RFSAM_OUT_RETIME() \
        GP_WB_READ_U1(0x106, 2)

#define GP_WB_GET_TRX_RFSAM_OUT_RETIME_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_RFSAM_OUT_RETIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RFSAM_OUT_RETIME_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Selection of edge of re-timer clock for MIXSAMP Output. */
#define GP_WB_READ_TRX_RFSAM_OUT_EDGE_SEL() \
        GP_WB_READ_U1(0x106, 3)

#define GP_WB_GET_TRX_RFSAM_OUT_EDGE_SEL_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_RFSAM_OUT_EDGE_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RFSAM_OUT_EDGE_SEL_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Charge pump selection: 0 = 7.5uA, 1 = 10uA, 2 = 3.75uA, 3 = 5uA */
#define GP_WB_READ_TRX_CP_CUR() \
        (GP_WB_S8(((GP_WB_READ_U8(0x106) >> 4) & 0x03), 2))

#define GP_WB_GET_TRX_CP_CUR_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x03), 2))

#define GP_WB_WRITE_TRX_CP_CUR(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          GP_WB_MWRITE_U8(0x106, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_CP_CUR_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          (tmp) &= 0xCF; \
          (tmp) |= ((((Int8)(val)) << 4) & 0x30); \
        } while (0)

/* mixsampler offset-compensating DAC disable */
#define GP_WB_READ_TRX_MIXSAMP_DAC_DISABLE() \
        GP_WB_READ_U1(0x106, 6)

#define GP_WB_GET_TRX_MIXSAMP_DAC_DISABLE_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_TRX_MIXSAMP_DAC_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 6, (val)); \
        } while (0)

#define GP_WB_SET_TRX_MIXSAMP_DAC_DISABLE_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* mixsampler retiming option to shift the moment of reading the dac-code by Tclk/2 */
#define GP_WB_READ_TRX_MIXSAMP_DAC_RETIME() \
        GP_WB_READ_U1(0x106, 7)

#define GP_WB_GET_TRX_MIXSAMP_DAC_RETIME_FROM_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_TRX_MIXSAMP_DAC_RETIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x106, 7, (val)); \
        } while (0)

#define GP_WB_SET_TRX_MIXSAMP_DAC_RETIME_TO_DIV_MIX_SAMPLER_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ANTSW_CP_CONTROL_0() \
        GP_WB_READ_U8(0x107)

#define GP_WB_WRITE_TRX_ANTSW_CP_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x107, (val))

/* Override select RF port 1 */
#define GP_WB_READ_TRX_ANTSW_FIX_A1() \
        GP_WB_READ_U1(0x107, 0)

#define GP_WB_GET_TRX_ANTSW_FIX_A1_FROM_ANTSW_CP_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_ANTSW_FIX_A1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ANTSW_FIX_A1_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Override select RF port 2 */
#define GP_WB_READ_TRX_ANTSW_FIX_A2() \
        GP_WB_READ_U1(0x107, 1)

#define GP_WB_GET_TRX_ANTSW_FIX_A2_FROM_ANTSW_CP_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_ANTSW_FIX_A2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ANTSW_FIX_A2_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables a matched load, instead of short/open when not selected */
#define GP_WB_READ_TRX_ANTSW_MATCHL_ENA() \
        GP_WB_READ_U1(0x107, 2)

#define GP_WB_GET_TRX_ANTSW_MATCHL_ENA_FROM_ANTSW_CP_CONTROL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_ANTSW_MATCHL_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ANTSW_MATCHL_ENA_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* charge pump bias select */
#define GP_WB_READ_TRX_CP_BIAS_SEL() \
        GP_WB_READ_U1(0x107, 3)

#define GP_WB_GET_TRX_CP_BIAS_SEL_FROM_ANTSW_CP_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_CP_BIAS_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_CP_BIAS_SEL_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* retime CP signals edge select */
#define GP_WB_READ_TRX_CP_RETIME_EDGE() \
        GP_WB_READ_U1(0x107, 4)

#define GP_WB_GET_TRX_CP_RETIME_EDGE_FROM_ANTSW_CP_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_CP_RETIME_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_CP_RETIME_EDGE_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* retime CP signals off */
#define GP_WB_READ_TRX_CP_RETIME_OFF() \
        GP_WB_READ_U1(0x107, 5)

#define GP_WB_GET_TRX_CP_RETIME_OFF_FROM_ANTSW_CP_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_CP_RETIME_OFF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x107, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_CP_RETIME_OFF_TO_ANTSW_CP_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LDO_RDY_STATUS() \
        GP_WB_READ_U8(0x108)

/* LDO ready signal of the LOOGEN LDO */
#define GP_WB_READ_TRX_LO_LDO_RDY() \
        GP_WB_READ_U1(0x108, 0)

#define GP_WB_GET_TRX_LO_LDO_RDY_FROM_LDO_RDY_STATUS(tmp) \
        ((tmp) & 0x01)

/* LDO ready signal of CP ldo */
#define GP_WB_READ_TRX_CP_LDO_RDY() \
        GP_WB_READ_U1(0x108, 1)

#define GP_WB_GET_TRX_CP_LDO_RDY_FROM_LDO_RDY_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* LDO ready signal of FLL LDO */
#define GP_WB_READ_TRX_FLL_LDO_RDY() \
        GP_WB_READ_U1(0x108, 2)

#define GP_WB_GET_TRX_FLL_LDO_RDY_FROM_LDO_RDY_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_EXTERNAL_MODE_CONTROL() \
        GP_WB_READ_U8(0x109)

#define GP_WB_WRITE_TRX_EXTERNAL_MODE_CONTROL(val) \
      GP_WB_WRITE_U8(0x109, (val))

/* Gives a set of 4 signals that can be configured to a avalue to be set when the radio is in trx off state. These control signals can be put on pins using the mode_ctrl_(0..3)_pinmap registers */
#define GP_WB_READ_TRX_EXT_MODE_CTRL_FOR_TRX_OFF() \
        (GP_WB_READ_U8(0x109) & 0x0F)

#define GP_WB_GET_TRX_EXT_MODE_CTRL_FOR_TRX_OFF_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_MODE_CTRL_FOR_TRX_OFF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x109, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_EXT_MODE_CTRL_FOR_TRX_OFF_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Gives a set of 4 signals that can be configured to a avalue to be set when the radio is in rx on state. These control signals can be put on pins using the mode_ctrl_(0..3)_pinmap registers */
#define GP_WB_READ_TRX_EXT_MODE_CTRL_FOR_RX_ON() \
        ((GP_WB_READ_U8(0x109) >> 4) & 0x0F)

#define GP_WB_GET_TRX_EXT_MODE_CTRL_FOR_RX_ON_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_MODE_CTRL_FOR_RX_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x109, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_EXT_MODE_CTRL_FOR_RX_ON_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_PINMAP_CONFIG() \
        GP_WB_READ_U8(0x10a)

#define GP_WB_WRITE_TRX_PINMAP_CONFIG(val) \
      GP_WB_WRITE_U8(0x10a, (val))

/* Sets the pinmap for the antsw function - remark that only mappings a and b are valid */
#define GP_WB_READ_TRX_ANTSW_PINMAP() \
        (GP_WB_READ_U8(0x10a) & 0x03)

#define GP_WB_GET_TRX_ANTSW_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TRX_ANTSW_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x10a, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ANTSW_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enables output pin for antswn function */
#define GP_WB_READ_TRX_ANTSWN_PINMAP() \
        GP_WB_READ_U1(0x10a, 2)

#define GP_WB_GET_TRX_ANTSWN_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_ANTSWN_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x10a, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ANTSWN_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Enables output pin for mode(bit 0) */
#define GP_WB_READ_TRX_MODE_CTRL_0_PINMAP() \
        GP_WB_READ_U1(0x10a, 3)

#define GP_WB_GET_TRX_MODE_CTRL_0_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_MODE_CTRL_0_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x10a, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_MODE_CTRL_0_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enables output pin for mode(bit 1) */
#define GP_WB_READ_TRX_MODE_CTRL_1_PINMAP() \
        GP_WB_READ_U1(0x10a, 4)

#define GP_WB_GET_TRX_MODE_CTRL_1_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_MODE_CTRL_1_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x10a, 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_MODE_CTRL_1_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Enables output pin for mode(bit 2) */
#define GP_WB_READ_TRX_MODE_CTRL_2_PINMAP() \
        GP_WB_READ_U1(0x10a, 5)

#define GP_WB_GET_TRX_MODE_CTRL_2_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_MODE_CTRL_2_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x10a, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_MODE_CTRL_2_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Enables output pin for mode(bit 3) */
#define GP_WB_READ_TRX_MODE_CTRL_3_PINMAP() \
        ((GP_WB_READ_U8(0x10a) >> 6) & 0x03)

#define GP_WB_GET_TRX_MODE_CTRL_3_PINMAP_FROM_PINMAP_CONFIG(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_TRX_MODE_CTRL_3_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x10a, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TRX_MODE_CTRL_3_PINMAP_TO_PINMAP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


#define GP_WB_WRITE_TRX_FLL_START(val) \
      GP_WB_WRITE_U8(0x10b, (val))

/* Force a measurement of the VCO frequency (active only in closed loop) */
#define GP_WB_TRX_FLL_MEASURE_VCO_FREQ() \
        GP_WB_WRITE_U8(0x10b, 0x01)

#define GP_WB_SET_TRX_FLL_MEASURE_VCO_FREQ_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear FLL interrupt */
#define GP_WB_TRX_FLL_VCO_MEASURE_DONE_CLR_INT() \
        GP_WB_WRITE_U8(0x10b, 0x02)

#define GP_WB_SET_TRX_FLL_VCO_MEASURE_DONE_CLR_INT_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear FLL out of lock interrupt */
#define GP_WB_TRX_FLL_OUT_OF_LOCK_CLR_INT() \
        GP_WB_WRITE_U8(0x10b, 0x04)

#define GP_WB_SET_TRX_FLL_OUT_OF_LOCK_CLR_INT_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear FLL CP out of range interrupt */
#define GP_WB_TRX_FLL_CP_OUT_OF_RANGE_CLR_INT() \
        GP_WB_WRITE_U8(0x10b, 0x08)

#define GP_WB_SET_TRX_FLL_CP_OUT_OF_RANGE_CLR_INT_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Latch multibytes read only properties */
#define GP_WB_TRX_FLL_LATCH_MB_PROPS() \
        GP_WB_WRITE_U8(0x10b, 0x10)

#define GP_WB_SET_TRX_FLL_LATCH_MB_PROPS_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Allow the FSM to go to the next state (only is fll_fsm_go_nxt_state_en is 1) */
#define GP_WB_TRX_FLL_FSM_GO_NXT_STATE() \
        GP_WB_WRITE_U8(0x10b, 0x20)

#define GP_WB_SET_TRX_FLL_FSM_GO_NXT_STATE_TO_FLL_START(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Length of the prepare states (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_PREPARE_DURATION() \
        GP_WB_READ_U8(0x10c)

#define GP_WB_WRITE_TRX_FLL_PREPARE_DURATION(val) do { \
          GP_WB_WRITE_U8(0x10c, (val)); \
        } while (0)


/* Length of the channel change (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_CHANNEL_CHANGE_DURATION() \
        GP_WB_READ_U8(0x10d)

#define GP_WB_WRITE_TRX_FLL_CHANNEL_CHANGE_DURATION(val) do { \
          GP_WB_WRITE_U8(0x10d, (val)); \
        } while (0)


/* Amount of time the LFF will be disabled on top of fll_channel_change_duration (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_LFF_DISABLE_DURATION() \
        GP_WB_READ_U8(0x10e)

#define GP_WB_WRITE_TRX_FLL_LFF_DISABLE_DURATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x10e, (val)); \
        } while (0)


/* Amount of time the MOC will be hold before begin triggered on top of fll_lff_disable_duration and fll_channel_change_duration (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_MOC_WAIT_DURATION() \
        GP_WB_READ_U8(0x10f)

#define GP_WB_WRITE_TRX_FLL_MOC_WAIT_DURATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x10f, (val)); \
        } while (0)


/* Amount of time the TXMOD_SPEEDUP will be set (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_TXMOD_SPEEDUP_SET_DURATION() \
        GP_WB_READ_U8(0x110)

#define GP_WB_WRITE_TRX_FLL_TXMOD_SPEEDUP_SET_DURATION(val) do { \
          GP_WB_WRITE_U8(0x110, (val)); \
        } while (0)


/* Amount of time the txmod filter needs in order to settle on top of fll_txmod_speedup_set_duration (resolution is 125us = 4 32MHz cycles) */
#define GP_WB_READ_TRX_FLL_TXMOD_SETTLE_DURATION() \
        GP_WB_READ_U8(0x111)

#define GP_WB_WRITE_TRX_FLL_TXMOD_SETTLE_DURATION(val) do { \
          GP_WB_WRITE_U8(0x111, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_CFG_0() \
        GP_WB_READ_U8(0x112)

#define GP_WB_WRITE_TRX_FLL_CFG_0(val) \
      GP_WB_WRITE_U8(0x112, (val))

/* LOG2 of the error gain to be used in the CL */
#define GP_WB_READ_TRX_FLL_CL_ERR_GAIN() \
        (GP_WB_READ_U8(0x112) & 0x07)

#define GP_WB_GET_TRX_FLL_CL_ERR_GAIN_FROM_FLL_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_FLL_CL_ERR_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x112, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_CL_ERR_GAIN_TO_FLL_CFG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Programable delay (0:15) to be applied to the incoming msk modulation stream */
#define GP_WB_READ_TRX_FLL_MSK_DELAY() \
        ((GP_WB_READ_U8(0x112) >> 4) & 0x0F)

#define GP_WB_GET_TRX_FLL_MSK_DELAY_FROM_FLL_CFG_0(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_TRX_FLL_MSK_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x112, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_FLL_MSK_DELAY_TO_FLL_CFG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_CFG_1() \
        GP_WB_READ_U8(0x113)

#define GP_WB_WRITE_TRX_FLL_CFG_1(val) \
      GP_WB_WRITE_U8(0x113, (val))

/* When 1 the clock to the FLL is permantly enable, dynamically switched otherwise */
#define GP_WB_READ_TRX_FLL_DISABLE_CLK_GATING() \
        GP_WB_READ_U1(0x113, 0)

#define GP_WB_GET_TRX_FLL_DISABLE_CLK_GATING_FROM_FLL_CFG_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_CLK_GATING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x113, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_CLK_GATING_TO_FLL_CFG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x22; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The offset compensation is enabled when 1, disabled otherwise */
#define GP_WB_READ_TRX_FLL_OFFSET_COMP_EN() \
        GP_WB_READ_U1(0x113, 1)

#define GP_WB_GET_TRX_FLL_OFFSET_COMP_EN_FROM_FLL_CFG_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_FLL_OFFSET_COMP_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x113, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_OFFSET_COMP_EN_TO_FLL_CFG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x21; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* The error correction module is switched off when 1 */
#define GP_WB_READ_TRX_FLL_ERR_CORR_DIS() \
        GP_WB_READ_U1(0x113, 5)

#define GP_WB_GET_TRX_FLL_ERR_CORR_DIS_FROM_FLL_CFG_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_FLL_ERR_CORR_DIS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x113, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_ERR_CORR_DIS_TO_FLL_CFG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_CFG_2() \
        GP_WB_READ_U8(0x114)

#define GP_WB_WRITE_TRX_FLL_CFG_2(val) \
      GP_WB_WRITE_U8(0x114, (val))

/* Charge pump charge time (in samples) 0 = 4, 1 = 3, 2 = 8, 3 = 6 */
#define GP_WB_READ_TRX_FLL_CP_CHARGE_TIME() \
        (GP_WB_READ_U8(0x114) & 0x03)

#define GP_WB_GET_TRX_FLL_CP_CHARGE_TIME_FROM_FLL_CFG_2(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TRX_FLL_CP_CHARGE_TIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x114, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_CP_CHARGE_TIME_TO_FLL_CFG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* LFF coupling factor: 0 = 64, 1 = 128, 2 = 256, 3 = 512 */
#define GP_WB_READ_TRX_FLL_LFF_INT_COUPLING_FACTOR() \
        ((GP_WB_READ_U8(0x114) >> 2) & 0x03)

#define GP_WB_GET_TRX_FLL_LFF_INT_COUPLING_FACTOR_FROM_FLL_CFG_2(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_TRX_FLL_LFF_INT_COUPLING_FACTOR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x114, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LFF_INT_COUPLING_FACTOR_TO_FLL_CFG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Delay to be applied to the phase in order to compensate for clock delays on the input path */
#define GP_WB_READ_TRX_FLL_OFFSET_COMP_PHASE_IN_DELAY() \
        ((GP_WB_READ_U8(0x114) >> 4) & 0x03)

#define GP_WB_GET_TRX_FLL_OFFSET_COMP_PHASE_IN_DELAY_FROM_FLL_CFG_2(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_TRX_FLL_OFFSET_COMP_PHASE_IN_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x114, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_FLL_OFFSET_COMP_PHASE_IN_DELAY_TO_FLL_CFG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Delay to be applied to the phase in order to compensate for clock delays on the output path */
#define GP_WB_READ_TRX_FLL_OFFSET_COMP_PHASE_OUT_DELAY() \
        ((GP_WB_READ_U8(0x114) >> 6) & 0x03)

#define GP_WB_GET_TRX_FLL_OFFSET_COMP_PHASE_OUT_DELAY_FROM_FLL_CFG_2(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_TRX_FLL_OFFSET_COMP_PHASE_OUT_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x114, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_TRX_FLL_OFFSET_COMP_PHASE_OUT_DELAY_TO_FLL_CFG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* alpha value to be used in the CL DSM (unsigned) */
#define GP_WB_READ_TRX_FLL_CL_ALPHA() \
        GP_WB_READ_U16(0x116)

#define GP_WB_WRITE_TRX_FLL_CL_ALPHA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x116, (val)); \
        } while (0)


/* Length (with 31.25ns resolution) of the first offset measurement */
#define GP_WB_READ_TRX_FLL_OFFSET_MEASURE_LENGTH() \
        GP_WB_READ_U8(0x118)

#define GP_WB_WRITE_TRX_FLL_OFFSET_MEASURE_LENGTH(val) do { \
          GP_WB_WRITE_U8(0x118, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_CFG_5() \
        GP_WB_READ_U8(0x119)

#define GP_WB_WRITE_TRX_FLL_CFG_5(val) \
      GP_WB_WRITE_U8(0x119, (val))

/* When 0 the scaling is 2/0.5/0.125, when 1 2/0.5/0.25, 1/0.25/0.125 otherwise */
#define GP_WB_READ_TRX_FLL_OFFSET_MEASURE_SCALING() \
        (GP_WB_READ_U8(0x119) & 0x03)

#define GP_WB_GET_TRX_FLL_OFFSET_MEASURE_SCALING_FROM_FLL_CFG_5(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TRX_FLL_OFFSET_MEASURE_SCALING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x119, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_OFFSET_MEASURE_SCALING_TO_FLL_CFG_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Tracking gain calculated as 2^(-fll_offset_tracking_gain) */
#define GP_WB_READ_TRX_FLL_OFFSET_TRACKING_GAIN() \
        ((GP_WB_READ_U8(0x119) >> 2) & 0x03)

#define GP_WB_GET_TRX_FLL_OFFSET_TRACKING_GAIN_FROM_FLL_CFG_5(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_TRX_FLL_OFFSET_TRACKING_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x119, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TRX_FLL_OFFSET_TRACKING_GAIN_TO_FLL_CFG_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* State at which the FSM will stop execution */
#define GP_WB_READ_TRX_FLL_FSM_HALT() \
        GP_WB_READ_U8(0x11a)

#define GP_WB_WRITE_TRX_FLL_FSM_HALT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x11a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_DEBUG_1() \
        GP_WB_READ_U8(0x11b)

#define GP_WB_WRITE_TRX_FLL_DEBUG_1(val) \
      GP_WB_WRITE_U8(0x11b, (val))

/* When 1 the value used to drive the closed loop DSM will be cl_from_rm, it will be the internal calculated value otherwise */
#define GP_WB_READ_TRX_FLL_FORCE_CL() \
        GP_WB_READ_U1(0x11b, 0)

#define GP_WB_GET_TRX_FLL_FORCE_CL_FROM_FLL_DEBUG_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_FLL_FORCE_CL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11b, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_FORCE_CL_TO_FLL_DEBUG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1 txdata will be permanently driven by the FLL, it will dynamically switched otherwise */
#define GP_WB_READ_TRX_FLL_FORCE_CAL() \
        GP_WB_READ_U1(0x11b, 1)

#define GP_WB_GET_TRX_FLL_FORCE_CAL_FROM_FLL_DEBUG_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_FLL_FORCE_CAL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11b, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_FORCE_CAL_TO_FLL_DEBUG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_DEBUG_2() \
        GP_WB_READ_U8(0x11c)

#define GP_WB_WRITE_TRX_FLL_DEBUG_2(val) \
      GP_WB_WRITE_U8(0x11c, (val))

/* When 0, fll_lock will be forced to 1, it will be controllbed by the FLL otherwise */
#define GP_WB_READ_TRX_FLL_LOCK_ENABLE() \
        GP_WB_READ_U1(0x11c, 1)

#define GP_WB_GET_TRX_FLL_LOCK_ENABLE_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LOCK_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LOCK_ENABLE_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF8; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, the LFF register will be bypassed when the loop is closed */
#define GP_WB_READ_TRX_FLL_LFF_BYPASS() \
        GP_WB_READ_U1(0x11c, 3)

#define GP_WB_GET_TRX_FLL_LFF_BYPASS_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_FLL_LFF_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_LFF_BYPASS_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF2; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, the FSM state transitions are triggered by the OS register fll_fsm_go_nxt_state */
#define GP_WB_READ_TRX_FLL_FSM_GO_NXT_STATE_EN() \
        GP_WB_READ_U1(0x11c, 4)

#define GP_WB_GET_TRX_FLL_FSM_GO_NXT_STATE_EN_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_FLL_FSM_GO_NXT_STATE_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_FSM_GO_NXT_STATE_EN_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEA; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, the prepapre states are not inserted between the normal FSM state transitions */
#define GP_WB_READ_TRX_FLL_FSM_PREPARE_STATES_DIS() \
        GP_WB_READ_U1(0x11c, 5)

#define GP_WB_GET_TRX_FLL_FSM_PREPARE_STATES_DIS_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_FLL_FSM_PREPARE_STATES_DIS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_FSM_PREPARE_STATES_DIS_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDA; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1 the LFF will be cleared and immediately updated when the loop is closed */
#define GP_WB_READ_TRX_FLL_CL_START_LFF_CLR_AND_EN() \
        GP_WB_READ_U1(0x11c, 6)

#define GP_WB_GET_TRX_FLL_CL_START_LFF_CLR_AND_EN_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_TRX_FLL_CL_START_LFF_CLR_AND_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 6, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_CL_START_LFF_CLR_AND_EN_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBA; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1 a 20us delay state will be inserted to allow TXMOD filter to settle */
#define GP_WB_READ_TRX_FLL_INSERT_DELAY_STATE() \
        GP_WB_READ_U1(0x11c, 7)

#define GP_WB_GET_TRX_FLL_INSERT_DELAY_STATE_FROM_FLL_DEBUG_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_TRX_FLL_INSERT_DELAY_STATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x11c, 7, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_INSERT_DELAY_STATE_TO_FLL_DEBUG_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7A; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_FSM_STATUS_PB() \
        GP_WB_READ_U8(0x11d)

/* FLL main FSM status */
#define GP_WB_READ_TRX_FLL_FSM_STATUS() \
        (GP_WB_READ_U8(0x11d) & 0x3F)

#define GP_WB_GET_TRX_FLL_FSM_STATUS_FROM_FLL_FSM_STATUS_PB(tmp) \
        ((tmp) & 0x3F)

/* Set when the FSM has reached the fll_fsm_halt status */
#define GP_WB_READ_TRX_FLL_FSM_STOP() \
        GP_WB_READ_U1(0x11d, 6)

#define GP_WB_GET_TRX_FLL_FSM_STOP_FROM_FLL_FSM_STATUS_PB(tmp) \
        (((tmp) >> 6) & 0x01)

/* Set when fll_fsm_go_nxt_state_en is ste and the FSM is ready to move to the next state */
#define GP_WB_READ_TRX_FLL_FSM_WAIT_FOR_TRG() \
        GP_WB_READ_U1(0x11d, 7)

#define GP_WB_GET_TRX_FLL_FSM_WAIT_FOR_TRG_FROM_FLL_FSM_STATUS_PB(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_DONE_PB() \
        GP_WB_READ_U8(0x11e)

/* Set when the calibration is finished */
#define GP_WB_READ_TRX_FLL_DONE() \
        GP_WB_READ_U1(0x11e, 0)

#define GP_WB_GET_TRX_FLL_DONE_FROM_FLL_DONE_PB(tmp) \
        ((tmp) & 0x01)

/* Set when the TX coarse calibration is finished */
#define GP_WB_READ_TRX_FLL_TX_C_DONE() \
        GP_WB_READ_U1(0x11e, 1)

#define GP_WB_GET_TRX_FLL_TX_C_DONE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 1) & 0x01)

/* Set when the TX fine calibration is finished */
#define GP_WB_READ_TRX_FLL_TX_DONE() \
        GP_WB_READ_U1(0x11e, 2)

#define GP_WB_GET_TRX_FLL_TX_DONE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 2) & 0x01)

/* Set when the RX Coarse calibration is finished */
#define GP_WB_READ_TRX_FLL_RX_C_DONE() \
        GP_WB_READ_U1(0x11e, 3)

#define GP_WB_GET_TRX_FLL_RX_C_DONE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 3) & 0x01)

/* Set when the RX fine calibration is finished */
#define GP_WB_READ_TRX_FLL_RX_DONE() \
        GP_WB_READ_U1(0x11e, 4)

#define GP_WB_GET_TRX_FLL_RX_DONE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 4) & 0x01)

/* Unmasked value of the fll_vco_measure_done interrupt */
#define GP_WB_READ_TRX_UNMASKED_FLL_VCO_MEASURE_DONE() \
        GP_WB_READ_U1(0x11e, 5)

#define GP_WB_GET_TRX_UNMASKED_FLL_VCO_MEASURE_DONE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 5) & 0x01)

/* Unmasked value of the fll_out_of_lock interrupt */
#define GP_WB_READ_TRX_UNMASKED_FLL_OUT_OF_LOCK() \
        GP_WB_READ_U1(0x11e, 6)

#define GP_WB_GET_TRX_UNMASKED_FLL_OUT_OF_LOCK_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 6) & 0x01)

/* Unmasked value of the fll_cp_out_of_range interrupt */
#define GP_WB_READ_TRX_UNMASKED_FLL_CP_OUT_OF_RANGE() \
        GP_WB_READ_U1(0x11e, 7)

#define GP_WB_GET_TRX_UNMASKED_FLL_CP_OUT_OF_RANGE_FROM_FLL_DONE_PB(tmp) \
        (((tmp) >> 7) & 0x01)


/* Value of the CL DSM's input */
#define GP_WB_READ_TRX_FLL_CL_DSM_IN() \
        (GP_WB_S16(GP_WB_READ_U16(0x120), 12))


/* Value of the measured VCO frequency */
#define GP_WB_READ_TRX_FLL_VCO_FREQ() \
        GP_WB_READ_U16(0x122)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_TABLE_IDX_PB() \
        GP_WB_READ_U8(0x124)

#define GP_WB_WRITE_TRX_FLL_TABLE_IDX_PB(val) \
      GP_WB_WRITE_U8(0x124, (val))

/* Idx to use for accessing the internal channel config table. Corresponds to the channel_idx. this index applies for both the set interface as the status */
#define GP_WB_READ_TRX_FLL_TABLE_IDX() \
        (GP_WB_READ_U8(0x124) & 0x07)

#define GP_WB_GET_TRX_FLL_TABLE_IDX_FROM_FLL_TABLE_IDX_PB(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_FLL_TABLE_IDX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x124, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_TABLE_IDX_TO_FLL_TABLE_IDX_PB(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x08; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, the table idx that is used for set and get interface, is the one set by fll_table_idx. If not set, the channel idx is used form the channel manager */
#define GP_WB_READ_TRX_FORCE_FLL_TABLE_IDX() \
        GP_WB_READ_U1(0x124, 3)

#define GP_WB_GET_TRX_FORCE_FLL_TABLE_IDX_FROM_FLL_TABLE_IDX_PB(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_FORCE_FLL_TABLE_IDX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x124, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FORCE_FLL_TABLE_IDX_TO_FLL_TABLE_IDX_PB(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Generic configuration entry to be used to set the different channel config table values */
#define GP_WB_READ_TRX_CHANNEL_CONFIG_TABLE_ENTRY() \
        GP_WB_READ_U24(0x126)

#define GP_WB_WRITE_TRX_CHANNEL_CONFIG_TABLE_ENTRY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x126, (val)); \
        } while (0)


#define GP_WB_WRITE_TRX_SET_CHANNEL_CONFIG_TABLE(val) \
      GP_WB_WRITE_U16(0x12a, (val))

/* Sets the vco_tx_coarse cap bank value of the channel config table entry indexed by fll_table_idx to the value set in the generic config register */
#define GP_WB_TRX_SET_FLL_TX_COARSE() \
        GP_WB_WRITE_U8(0x12a, 0x01)

#define GP_WB_SET_TRX_SET_FLL_TX_COARSE_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Sets the vco_tx_fine cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_TX_FINE() \
        GP_WB_WRITE_U8(0x12a, 0x02)

#define GP_WB_SET_TRX_SET_FLL_TX_FINE_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Sets the vco_rx_coarse cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_RX_COARSE() \
        GP_WB_WRITE_U8(0x12a, 0x04)

#define GP_WB_SET_TRX_SET_FLL_RX_COARSE_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Sets the vco_rx_fine cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_RX_FINE() \
        GP_WB_WRITE_U8(0x12a, 0x08)

#define GP_WB_SET_TRX_SET_FLL_RX_FINE_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Sets the modulation index calibration value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_MI() \
        GP_WB_WRITE_U8(0x12a, 0x10)

#define GP_WB_SET_TRX_SET_FLL_MI_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Sets the loopgain calibration value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_LOOPGAIN() \
        GP_WB_WRITE_U8(0x12a, 0x20)

#define GP_WB_SET_TRX_SET_FLL_LOOPGAIN_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Sets tx Low frequency filter value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_TX_LFF() \
        GP_WB_WRITE_U8(0x12a, 0x40)

#define GP_WB_SET_TRX_SET_FLL_TX_LFF_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Sets rx Low frequency filter value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_FLL_RX_LFF() \
        GP_WB_WRITE_U8(0x12a, 0x80)

#define GP_WB_SET_TRX_SET_FLL_RX_LFF_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* sets the update disablesd for  the channel config table entry indexed by fll_table_idx */
#define GP_WB_TRX_SET_DISABLE_UPDATES() \
        GP_WB_WRITE_U8(0x12b, 0x01)

#define GP_WB_SET_TRX_SET_DISABLE_UPDATES_TO_SET_CHANNEL_CONFIG_TABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_FLL_DISABLE_CONFIG_TABLE_UPDATES() \
        GP_WB_READ_U8(0x12c)

#define GP_WB_WRITE_TRX_FLL_DISABLE_CONFIG_TABLE_UPDATES(val) \
      GP_WB_WRITE_U8(0x12c, (val))

/* Disables / enables updates to the rx cap bank values for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_TX_CB_UPDATES() \
        GP_WB_READ_U1(0x12c, 0)

#define GP_WB_GET_TRX_FLL_DISABLE_TX_CB_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_TX_CB_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 0, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_TX_CB_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Disables / enables updates to the tx cap bank values for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_RX_CB_UPDATES() \
        GP_WB_READ_U1(0x12c, 1)

#define GP_WB_GET_TRX_FLL_DISABLE_RX_CB_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_RX_CB_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 1, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_RX_CB_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Disables / enables updates modulation index calibration value for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_MI_UPDATES() \
        GP_WB_READ_U1(0x12c, 2)

#define GP_WB_GET_TRX_FLL_DISABLE_MI_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_MI_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 2, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_MI_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Disables / enables updates loopgain calibration value for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_LOOPGAIN_UPDATES() \
        GP_WB_READ_U1(0x12c, 3)

#define GP_WB_GET_TRX_FLL_DISABLE_LOOPGAIN_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_LOOPGAIN_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_LOOPGAIN_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Disables / enables updates to tx lff value for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_TX_LFF_UPDATES() \
        GP_WB_READ_U1(0x12c, 4)

#define GP_WB_GET_TRX_FLL_DISABLE_TX_LFF_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_TX_LFF_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_TX_LFF_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Disables / enables updates to rx lff value for table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_FLL_DISABLE_RX_LFF_UPDATES() \
        GP_WB_READ_U1(0x12c, 5)

#define GP_WB_GET_TRX_FLL_DISABLE_RX_LFF_UPDATES_FROM_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_FLL_DISABLE_RX_LFF_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x12c, 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_FLL_DISABLE_RX_LFF_UPDATES_TO_FLL_DISABLE_CONFIG_TABLE_UPDATES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* gets the vco_tx_coarse cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_TX_COARSE() \
        GP_WB_READ_U8(0x12d)


/* gets the vco_tx_fine cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_TX_FINE() \
        GP_WB_READ_U8(0x12e)


/* gets the vco_rx_coarse cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_RX_COARSE() \
        GP_WB_READ_U8(0x12f)


/* gets the vco_rx_fine cap bank value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_RX_FINE() \
        GP_WB_READ_U8(0x130)


/* gets the modulation index calibration value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_MI() \
        GP_WB_READ_U16(0x132)


/* gets the loopgain calibration value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_LOOPGAIN() \
        (GP_WB_S8(GP_WB_READ_U8(0x134), 7))


/* gets the tx Low frequency filter value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_TX_LFF() \
        (GP_WB_S24(GP_WB_READ_U24(0x136), 19))


/* gets bits 0 to 7 of the rx Low frequency filter value of the channel config table entry indexed by fll_table_idx */
#define GP_WB_READ_TRX_GET_FLL_RX_LFF() \
        (GP_WB_S24(GP_WB_READ_U24(0x13a), 19))


#define GP_WB_WRITE_TRX_SET_OFFSET_COMPENSATION_INTEGRATORS(val) \
      GP_WB_WRITE_U8(0x13d, (val))

/* Set the Mixsampler Offset Compensation Modulated Channel Integrator 0 */
#define GP_WB_TRX_SET_MOC_MCH_INT0() \
        GP_WB_WRITE_U8(0x13d, 0x01)

#define GP_WB_SET_TRX_SET_MOC_MCH_INT0_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the Mixsampler Offset Compensation Modulated Channel Integrator 1 */
#define GP_WB_TRX_SET_MOC_MCH_INT1() \
        GP_WB_WRITE_U8(0x13d, 0x02)

#define GP_WB_SET_TRX_SET_MOC_MCH_INT1_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the Mixsampler Offset Compensation Modulated Channel Integrator 2 */
#define GP_WB_TRX_SET_MOC_MCH_INT2() \
        GP_WB_WRITE_U8(0x13d, 0x04)

#define GP_WB_SET_TRX_SET_MOC_MCH_INT2_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the Mixsampler Offset Compensation Modulated Channel Integrator 3 */
#define GP_WB_TRX_SET_MOC_MCH_INT3() \
        GP_WB_WRITE_U8(0x13d, 0x08)

#define GP_WB_SET_TRX_SET_MOC_MCH_INT3_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Set the Mixsampler Offset Compensation Not Modulated Channel Integrator */
#define GP_WB_TRX_SET_MOC_NMCH_INT() \
        GP_WB_WRITE_U8(0x13d, 0x10)

#define GP_WB_SET_TRX_SET_MOC_NMCH_INT_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Set the Mixsampler Offset Compensation Tracking enabled bits */
#define GP_WB_TRX_SET_MOC_TRACKING_EN() \
        GP_WB_WRITE_U8(0x13d, 0x20)

#define GP_WB_SET_TRX_SET_MOC_TRACKING_EN_TO_SET_OFFSET_COMPENSATION_INTEGRATORS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Data to be written into the Mixsampler Offset Compensation Modulated Channel Integrator selected but the set_moc trigger */
#define GP_WB_READ_TRX_SET_MOC_INT_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x13e), 7))

#define GP_WB_WRITE_TRX_SET_MOC_INT_VALUE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_WRITE_U8(0x13e, (val)); \
        } while (0)


/* gets the Mixsampler Offset Compensation Modulated Channel Integrator 0 */
#define GP_WB_READ_TRX_GET_MOC_MCH_INT0_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x13f), 7))


/* gets the Mixsampler Offset Compensation Modulated Channel Integrator 1 */
#define GP_WB_READ_TRX_GET_MOC_MCH_INT1_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x140), 7))


/* gets the Mixsampler Offset Compensation Modulated Channel Integrator 2 */
#define GP_WB_READ_TRX_GET_MOC_MCH_INT2_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x141), 7))


/* gets the Mixsampler Offset Compensation Modulated Channel Integrator 3 */
#define GP_WB_READ_TRX_GET_MOC_MCH_INT3_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x142), 7))


/* gets the Mixsampler Offset Compensation Not Modulated Channel Integrator */
#define GP_WB_READ_TRX_GET_MOC_NMCH_INT_VALUE() \
        (GP_WB_S8(GP_WB_READ_U8(0x143), 7))


/* gets the Mixsampler Offset Compensation tracking enable bits */
#define GP_WB_READ_TRX_GET_MOC_TRACKING_EN() \
        (GP_WB_S8(GP_WB_READ_U8(0x144), 2))

/***************************
 * layout: radioitf
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_RX_OVERRULE_CONTROL() \
        GP_WB_READ_U16(0x180)

#define GP_WB_WRITE_RADIOITF_RX_OVERRULE_CONTROL(val) \
      GP_WB_WRITE_U16(0x180, (val))

/* swaps I and Q of incoming stream */
#define GP_WB_READ_RADIOITF_SWAP_RX_IQ() \
        GP_WB_READ_U1(0x180, 0)

#define GP_WB_GET_RADIOITF_SWAP_RX_IQ_FROM_RX_OVERRULE_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_SWAP_RX_IQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SWAP_RX_IQ_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* swaps I and Q of incoming stream */
#define GP_WB_READ_RADIOITF_RX_IQ_OVERRULE_ENA() \
        GP_WB_READ_U1(0x180, 1)

#define GP_WB_GET_RADIOITF_RX_IQ_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_IQ_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_IQ_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_MIXSAMPLER_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(0x180, 2)

#define GP_WB_GET_RADIOITF_MIXSAMPLER_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMPLER_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMPLER_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(0x180, 3)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_MIXSAMPLER_OVERRULE_ENA() \
        GP_WB_READ_U1(0x180, 4)

#define GP_WB_GET_RADIOITF_MIXSAMPLER_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMPLER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMPLER_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_OVERRULE_ENA() \
        GP_WB_READ_U1(0x180, 5)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_ENA() \
        GP_WB_READ_U1(0x180, 6)

#define GP_WB_GET_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_ENA() \
        GP_WB_READ_U1(0x180, 7)

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x180, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_OUT_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(0x181, 0)

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_OUT_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMP_LF_LO_OUT_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_LF_LO_OUT_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* overrule in phase rx output */
#define GP_WB_READ_RADIOITF_RXI_OVERRULE() \
        GP_WB_READ_U1(0x181, 1)

#define GP_WB_GET_RADIOITF_RXI_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_RXI_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RXI_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* overrule quadrature rx output */
#define GP_WB_READ_RADIOITF_RXQ_OVERRULE() \
        GP_WB_READ_U1(0x181, 2)

#define GP_WB_GET_RADIOITF_RXQ_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_RXQ_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RXQ_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* overrule 32 MHz output stream from MIX sampler */
#define GP_WB_READ_RADIOITF_MIXSAMPLER_OVERRULE() \
        GP_WB_READ_U1(0x181, 3)

#define GP_WB_GET_RADIOITF_MIXSAMPLER_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMPLER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMPLER_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* overrule 32 MHz output stream from DIV sampler */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_OVERRULE() \
        GP_WB_READ_U1(0x181, 4)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* overrule indication when FLL is outside its compliance */
#define GP_WB_READ_RADIOITF_CP_OUT_OF_RANGE_OVERRULE() \
        GP_WB_READ_U1(0x181, 5)

#define GP_WB_GET_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_OUT_OF_RANGE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x181, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_OUT_OF_RANGE_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

/* overrule 8MHz mixsampler LO output I and Q . Sequence depends on value of mixsamp_lf_lo_freq */
#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE() \
        ((GP_WB_READ_U8(0x181) >> 6) & 0x03)

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x181, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_LF_LO_OUT_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_0() \
        GP_WB_READ_U8(0x182)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_0(val) \
      GP_WB_WRITE_U8(0x182, (val))

#define GP_WB_READ_RADIOITF_TX_DAC_IN_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 0)

#define GP_WB_GET_RADIOITF_TX_DAC_IN_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_DAC_IN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_DAC_IN_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_TXDATA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 1)

#define GP_WB_GET_RADIOITF_TXDATA_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_TXDATA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXDATA_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 2)

#define GP_WB_GET_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_PUP_N_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 3)

#define GP_WB_GET_RADIOITF_PA_PUP_N_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_N_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_N_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_PUP_P_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 4)

#define GP_WB_GET_RADIOITF_PA_PUP_P_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_P_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_P_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_TXMOD_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 5)

#define GP_WB_GET_RADIOITF_TXMOD_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_TXMOD_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXMOD_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_TXMOD_SPEEDUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 6)

#define GP_WB_GET_RADIOITF_TXMOD_SPEEDUP_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_TXMOD_SPEEDUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXMOD_SPEEDUP_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x182, 7)

#define GP_WB_GET_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x182, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_1() \
        GP_WB_READ_U8(0x183)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_1(val) \
      GP_WB_WRITE_U8(0x183, (val))

#define GP_WB_READ_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 0)

#define GP_WB_GET_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_BPF_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 1)

#define GP_WB_GET_RADIOITF_BPF_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_BPF_CLK_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 2)

#define GP_WB_GET_RADIOITF_BPF_CLK_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_CLK_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_CLK_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 3)

#define GP_WB_GET_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 4)

#define GP_WB_GET_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_LNA_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 5)

#define GP_WB_GET_RADIOITF_LNA_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 6)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_LNA_CORE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x183, 7)

#define GP_WB_GET_RADIOITF_LNA_CORE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_CORE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x183, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_CORE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_2() \
        GP_WB_READ_U8(0x184)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_2(val) \
      GP_WB_WRITE_U8(0x184, (val))

#define GP_WB_READ_RADIOITF_LIM_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 0)

#define GP_WB_GET_RADIOITF_LIM_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 1)

#define GP_WB_GET_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 2)

#define GP_WB_GET_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 3)

#define GP_WB_GET_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 4)

#define GP_WB_GET_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 5)

#define GP_WB_GET_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 6)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x184, 7)

#define GP_WB_GET_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_ENA_FROM_OVERRULE_ENA_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x184, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_ENA_TO_OVERRULE_ENA_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_3() \
        GP_WB_READ_U8(0x185)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_3(val) \
      GP_WB_WRITE_U8(0x185, (val))

#define GP_WB_READ_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 0)

#define GP_WB_GET_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_DOWN_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 1)

#define GP_WB_GET_RADIOITF_CP_DOWN_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_DOWN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_DOWN_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_REFDAC_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 2)

#define GP_WB_GET_RADIOITF_CP_REFDAC_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_REFDAC_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_REFDAC_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_UP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 3)

#define GP_WB_GET_RADIOITF_CP_UP_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_UP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_UP_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_DIV16_64_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 4)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV16_64_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV16_64_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 5)

#define GP_WB_GET_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_ENA() \
        GP_WB_READ_U1(0x185, 6)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_ENA_FROM_OVERRULE_ENA_3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x185, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_ENA_TO_OVERRULE_ENA_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_4() \
        GP_WB_READ_U8(0x186)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_4(val) \
      GP_WB_WRITE_U8(0x186, (val))

#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SW_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 0)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SW_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_RCMEAS_SW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_RCMEAS_SW_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_VMID_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 1)

#define GP_WB_GET_RADIOITF_FLL_VMID_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_VMID_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_VMID_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 2)

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_VCO_C_COARSE_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 3)

#define GP_WB_GET_RADIOITF_VCO_C_COARSE_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_VCO_C_COARSE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_C_COARSE_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_VCO_C_FINE_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 4)

#define GP_WB_GET_RADIOITF_VCO_C_FINE_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_VCO_C_FINE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_C_FINE_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_ANTSW_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 5)

#define GP_WB_GET_RADIOITF_ANTSW_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_ANTSW_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_ANTSW_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 6)

#define GP_WB_GET_RADIOITF_CP_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_CP_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x186, 7)

#define GP_WB_GET_RADIOITF_CP_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_4(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x186, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_5() \
        GP_WB_READ_U8(0x187)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_5(val) \
      GP_WB_WRITE_U8(0x187, (val))

#define GP_WB_READ_RADIOITF_PA_TX_SEL_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 0)

#define GP_WB_GET_RADIOITF_PA_TX_SEL_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_TX_SEL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_TX_SEL_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_DIV_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 1)

#define GP_WB_GET_RADIOITF_FLL_DIV_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 2)

#define GP_WB_GET_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 3)

#define GP_WB_GET_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_RX_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 4)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_RX_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_RX_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_RX_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x187, 5)

#define GP_WB_GET_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_5(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x187, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_6() \
        GP_WB_READ_U8(0x188)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_6(val) \
      GP_WB_WRITE_U8(0x188, (val))

#define GP_WB_READ_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 0)

#define GP_WB_GET_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 1)

#define GP_WB_GET_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 2)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 3)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLL_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 4)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLL_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_FLL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_FLL_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 5)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_PA_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 6)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_PA_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_PA_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_PA_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RADIOITF_MIXSAMP_OFFSET_OVERRULE_ENA() \
        GP_WB_READ_U1(0x188, 7)

#define GP_WB_GET_RADIOITF_MIXSAMP_OFFSET_OVERRULE_ENA_FROM_OVERRULE_ENA_6(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_MIXSAMP_OFFSET_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x188, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_OFFSET_OVERRULE_ENA_TO_OVERRULE_ENA_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_7() \
        GP_WB_READ_U8(0x189)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_7(val) \
      GP_WB_WRITE_U8(0x189, (val))

#define GP_WB_READ_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 0)

#define GP_WB_GET_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_RFDIV_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 1)

#define GP_WB_GET_RADIOITF_RFDIV_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFDIV_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFDIV_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_VCO_PMIR_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 2)

#define GP_WB_GET_RADIOITF_VCO_PMIR_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_VCO_PMIR_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_PMIR_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_ANT_SW_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 3)

#define GP_WB_GET_RADIOITF_PA_ANT_SW_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_ANT_SW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_ANT_SW_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 4)

#define GP_WB_GET_RADIOITF_PA_BIAS_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_BIAS_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x189, 5)

#define GP_WB_GET_RADIOITF_PA_PUP_OVERRULE_ENA_FROM_OVERRULE_ENA_7(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x189, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_OVERRULE_ENA_TO_OVERRULE_ENA_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_ENA_8() \
        GP_WB_READ_U8(0x18a)

#define GP_WB_WRITE_RADIOITF_OVERRULE_ENA_8(val) \
      GP_WB_WRITE_U8(0x18a, (val))

#define GP_WB_READ_RADIOITF_ANTSW_ANT_SW_OVERRULE_ENA() \
        GP_WB_READ_U1(0x18a, 0)

#define GP_WB_GET_RADIOITF_ANTSW_ANT_SW_OVERRULE_ENA_FROM_OVERRULE_ENA_8(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_ANTSW_ANT_SW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18a, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_ANTSW_ANT_SW_OVERRULE_ENA_TO_OVERRULE_ENA_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_PWR_OVERRULE_ENA() \
        GP_WB_READ_U1(0x18a, 1)

#define GP_WB_GET_RADIOITF_PA_PWR_OVERRULE_ENA_FROM_OVERRULE_ENA_8(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PWR_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18a, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PWR_OVERRULE_ENA_TO_OVERRULE_ENA_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_LOW_OVERRULE_ENA() \
        GP_WB_READ_U1(0x18a, 2)

#define GP_WB_GET_RADIOITF_PA_LOW_OVERRULE_ENA_FROM_OVERRULE_ENA_8(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_LOW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18a, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_LOW_OVERRULE_ENA_TO_OVERRULE_ENA_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RADIOITF_PA_ULTRALOW_OVERRULE_ENA() \
        GP_WB_READ_U1(0x18a, 3)

#define GP_WB_GET_RADIOITF_PA_ULTRALOW_OVERRULE_ENA_FROM_OVERRULE_ENA_8(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_ULTRALOW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18a, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_ULTRALOW_OVERRULE_ENA_TO_OVERRULE_ENA_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_0() \
        GP_WB_READ_U8(0x18b)

#define GP_WB_WRITE_RADIOITF_OVERRULE_0(val) \
      GP_WB_WRITE_U8(0x18b, (val))

/* overrule DAC sigma delta input */
#define GP_WB_READ_RADIOITF_TX_DAC_IN_OVERRULE() \
        GP_WB_READ_U1(0x18b, 0)

#define GP_WB_GET_RADIOITF_TX_DAC_IN_OVERRULE_FROM_OVERRULE_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_DAC_IN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_DAC_IN_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule Modulation data */
#define GP_WB_READ_RADIOITF_TXDATA_OVERRULE() \
        ((GP_WB_READ_U8(0x18b) >> 1) & 0x03)

#define GP_WB_GET_RADIOITF_TXDATA_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_WRITE_RADIOITF_TXDATA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x18b, 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXDATA_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF9; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule enable for PA LDO low-power mode */
#define GP_WB_READ_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x18b, 3)

#define GP_WB_GET_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule enable for negative single ended branch of PA */
#define GP_WB_READ_RADIOITF_PA_PUP_N_OVERRULE() \
        GP_WB_READ_U1(0x18b, 4)

#define GP_WB_GET_RADIOITF_PA_PUP_N_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_N_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_N_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule enable for positive single ended branch of PA */
#define GP_WB_READ_RADIOITF_PA_PUP_P_OVERRULE() \
        GP_WB_READ_U1(0x18b, 5)

#define GP_WB_GET_RADIOITF_PA_PUP_P_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_P_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_P_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* overrule pup for PWR-up of tx mod block */
#define GP_WB_READ_RADIOITF_TXMOD_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18b, 6)

#define GP_WB_GET_RADIOITF_TXMOD_PUP_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_TXMOD_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXMOD_PUP_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overrule speed up of tx mod block */
#define GP_WB_READ_RADIOITF_TXMOD_SPEEDUP_OVERRULE() \
        GP_WB_READ_U1(0x18b, 7)

#define GP_WB_GET_RADIOITF_TXMOD_SPEEDUP_OVERRULE_FROM_OVERRULE_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_TXMOD_SPEEDUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18b, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TXMOD_SPEEDUP_OVERRULE_TO_OVERRULE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_1() \
        GP_WB_READ_U8(0x18c)

#define GP_WB_WRITE_RADIOITF_OVERRULE_1(val) \
      GP_WB_WRITE_U8(0x18c, (val))

/* overrule Power up of the NMOS SC-bias cell */
#define GP_WB_READ_RADIOITF_BPF_BIAS_N_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18c, 0)

#define GP_WB_GET_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_FROM_OVERRULE_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_N_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_N_PUP_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule Power up of the PMOS SC-bias cell */
#define GP_WB_READ_RADIOITF_BPF_BIAS_P_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18c, 1)

#define GP_WB_GET_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_FROM_OVERRULE_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_P_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_P_PUP_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule Power up of the combined SC-bias cell */
#define GP_WB_READ_RADIOITF_BPF_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18c, 2)

#define GP_WB_GET_RADIOITF_BPF_BIAS_PUP_OVERRULE_FROM_OVERRULE_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_BIAS_PUP_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule SC-bias circuit clock input */
#define GP_WB_READ_RADIOITF_BPF_CLK_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18c, 3)

#define GP_WB_GET_RADIOITF_BPF_CLK_PUP_OVERRULE_FROM_OVERRULE_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_CLK_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_CLK_PUP_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule LDO power-up signal of the BPF constant-gm LDO */
#define GP_WB_READ_RADIOITF_BPF_INT_LDO_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18c, 4)

#define GP_WB_GET_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_FROM_OVERRULE_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_INT_LDO_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_INT_LDO_PUP_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule Scale down LDO current factor 4 LP:mode */
#define GP_WB_READ_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x18c, 5)

#define GP_WB_GET_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18c, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_BPF_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_2() \
        GP_WB_READ_U8(0x18d)

#define GP_WB_WRITE_RADIOITF_OVERRULE_2(val) \
      GP_WB_WRITE_U8(0x18d, (val))

/* overrule Power up signal for biasing LNA */
#define GP_WB_READ_RADIOITF_LNA_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 0)

#define GP_WB_GET_RADIOITF_LNA_BIAS_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BIAS_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule Pwr-up bias Limiters */
#define GP_WB_READ_RADIOITF_LIM_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 1)

#define GP_WB_GET_RADIOITF_LIM_BIAS_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_BIAS_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule Pwr-up in-phase diff2se */
#define GP_WB_READ_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 2)

#define GP_WB_GET_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_I_DIFF2SE_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule Pwr-up limiters */
#define GP_WB_READ_RADIOITF_LIM_I_STAGE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 3)

#define GP_WB_GET_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_I_STAGE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_I_STAGE_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule Pwr-up quadrature diff2se */
#define GP_WB_READ_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 4)

#define GP_WB_GET_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_Q_DIFF2SE_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule Pwr-up quadrature limiters */
#define GP_WB_READ_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 5)

#define GP_WB_GET_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_Q_STAGE_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* overrule scale down LDO current factor 4: LP mode */
#define GP_WB_READ_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x18d, 6)

#define GP_WB_GET_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LIM_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overrule power up signal for LNA buffer (2nd stage) */
#define GP_WB_READ_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x18d, 7)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_FROM_OVERRULE_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18d, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BUFFER_CORE_PUP_OVERRULE_TO_OVERRULE_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_3() \
        GP_WB_READ_U8(0x18e)

#define GP_WB_WRITE_RADIOITF_OVERRULE_3(val) \
      GP_WB_WRITE_U8(0x18e, (val))

/* overrule bypass filtering resistor in LNAMIX LDO */
#define GP_WB_READ_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE() \
        GP_WB_READ_U1(0x18e, 0)

#define GP_WB_GET_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_FROM_OVERRULE_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18e, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNAMIX_ENA_LDO_RESBYP_OVERRULE_TO_OVERRULE_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule bypass filtering resistor in LNAMIX LDO */
#define GP_WB_READ_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x18e, 1)

#define GP_WB_GET_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18e, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNAMIX_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule down signal for CP: sink current from loop-filter */
#define GP_WB_READ_RADIOITF_CP_DOWN_OVERRULE() \
        GP_WB_READ_U1(0x18e, 2)

#define GP_WB_GET_RADIOITF_CP_DOWN_OVERRULE_FROM_OVERRULE_3(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_DOWN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18e, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_DOWN_OVERRULE_TO_OVERRULE_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_4() \
        GP_WB_READ_U8(0x18f)

#define GP_WB_WRITE_RADIOITF_OVERRULE_4(val) \
      GP_WB_WRITE_U8(0x18f, (val))

/* overrule Down signal for CP: sink current from loop-filter */
#define GP_WB_READ_RADIOITF_CP_UP_OVERRULE() \
        GP_WB_READ_U1(0x18f, 0)

#define GP_WB_GET_RADIOITF_CP_UP_OVERRULE_FROM_OVERRULE_4(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_UP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x18f, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_UP_OVERRULE_TO_OVERRULE_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule cp_refdac */
#define GP_WB_READ_RADIOITF_CP_REFDAC_OVERRULE() \
        (GP_WB_S8(((GP_WB_READ_U8(0x18f) >> 1) & 0x7F), 7))

#define GP_WB_GET_RADIOITF_CP_REFDAC_OVERRULE_FROM_OVERRULE_4(tmp) \
        (GP_WB_S8((((tmp) >> 1) & 0x7F), 7))

#define GP_WB_WRITE_RADIOITF_CP_REFDAC_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(0x18f, 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_REFDAC_OVERRULE_TO_OVERRULE_4(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x01; \
          (tmp) |= ((((Int8)(val)) << 1) & 0xFE); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_5() \
        GP_WB_READ_U8(0x190)

#define GP_WB_WRITE_RADIOITF_OVERRULE_5(val) \
      GP_WB_WRITE_U8(0x190, (val))

/* overrule loopfilter speedup */
#define GP_WB_READ_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE() \
        GP_WB_READ_U1(0x190, 0)

#define GP_WB_GET_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_FROM_OVERRULE_5(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LOOPFILT_SPEEDUP_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule Connect loopfilter cap to zero or 1.2V */
#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE() \
        GP_WB_READ_U1(0x190, 1)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_FROM_OVERRULE_5(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_RCMEAS_SIGN_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule Open Resistor of loop filter */
#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SW_OVERRULE() \
        GP_WB_READ_U1(0x190, 2)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SW_OVERRULE_FROM_OVERRULE_5(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_RCMEAS_SW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_RCMEAS_SW_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule fix vtune half way the supply */
#define GP_WB_READ_RADIOITF_FLL_VMID_PUP_OVERRULE() \
        GP_WB_READ_U1(0x190, 3)

#define GP_WB_GET_RADIOITF_FLL_VMID_PUP_OVERRULE_FROM_OVERRULE_5(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_VMID_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_VMID_PUP_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule frequency of the 8 MHz LO */
#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE() \
        (GP_WB_S8(((GP_WB_READ_U8(0x190) >> 4) & 0x03), 2))

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_FROM_OVERRULE_5(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x03), 2))

#define GP_WB_WRITE_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          GP_WB_MWRITE_U8(0x190, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_RADIOITF_MIXSAMP_LF_LO_FREQ_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          (tmp) &= 0xCF; \
          (tmp) |= ((((Int8)(val)) << 4) & 0x30); \
        } while (0)

/* overrule power up signal for diversity switch */
#define GP_WB_READ_RADIOITF_ANTSW_PUP_OVERRULE() \
        GP_WB_READ_U1(0x190, 6)

#define GP_WB_GET_RADIOITF_ANTSW_PUP_OVERRULE_FROM_OVERRULE_5(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_ANTSW_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_ANTSW_PUP_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overrule charge-pump bias power-up */
#define GP_WB_READ_RADIOITF_CP_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x190, 7)

#define GP_WB_GET_RADIOITF_CP_BIAS_PUP_OVERRULE_FROM_OVERRULE_5(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x190, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_BIAS_PUP_OVERRULE_TO_OVERRULE_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_6() \
        GP_WB_READ_U8(0x191)

#define GP_WB_WRITE_RADIOITF_OVERRULE_6(val) \
      GP_WB_WRITE_U8(0x191, (val))

/* overrule coarse tune cap bank of 4.8 GHz VCO */
#define GP_WB_READ_RADIOITF_VCO_C_COARSE_OVERRULE() \
        (GP_WB_READ_U8(0x191) & 0x1F)

#define GP_WB_GET_RADIOITF_VCO_C_COARSE_OVERRULE_FROM_OVERRULE_6(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_RADIOITF_VCO_C_COARSE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_MWRITE_U8(0x191, 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_C_COARSE_OVERRULE_TO_OVERRULE_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          (tmp) &= 0x20; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule VCM TX setting */
#define GP_WB_READ_RADIOITF_PA_TX_SEL_OVERRULE() \
        GP_WB_READ_U1(0x191, 5)

#define GP_WB_GET_RADIOITF_PA_TX_SEL_OVERRULE_FROM_OVERRULE_6(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_TX_SEL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x191, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_TX_SEL_OVERRULE_TO_OVERRULE_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_7() \
        GP_WB_READ_U8(0x192)

#define GP_WB_WRITE_RADIOITF_OVERRULE_7(val) \
      GP_WB_WRITE_U8(0x192, (val))

/* overrule fine tune cap bank of 4.8 GHz VCO */
#define GP_WB_READ_RADIOITF_VCO_C_FINE_OVERRULE() \
        (GP_WB_READ_U8(0x192) & 0x1F)

#define GP_WB_GET_RADIOITF_VCO_C_FINE_OVERRULE_FROM_OVERRULE_7(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_RADIOITF_VCO_C_FINE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_MWRITE_U8(0x192, 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_C_FINE_OVERRULE_TO_OVERRULE_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          (tmp) &= 0xE0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule FLL acquisition divider power up (div by 16 or 64) */
#define GP_WB_READ_RADIOITF_FLL_DIV_PUP_OVERRULE() \
        GP_WB_READ_U1(0x192, 5)

#define GP_WB_GET_RADIOITF_FLL_DIV_PUP_OVERRULE_FROM_OVERRULE_7(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x192, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV_PUP_OVERRULE_TO_OVERRULE_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* overrule enable for divsamp */
#define GP_WB_READ_RADIOITF_FLL_DIVSAM_PUP_OVERRULE() \
        GP_WB_READ_U1(0x192, 6)

#define GP_WB_GET_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_FROM_OVERRULE_7(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIVSAM_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x192, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIVSAM_PUP_OVERRULE_TO_OVERRULE_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overrule scale down LDO current factor 4: LP mode */
#define GP_WB_READ_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x192, 7)

#define GP_WB_GET_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_7(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x192, 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_8() \
        GP_WB_READ_U8(0x193)

#define GP_WB_WRITE_RADIOITF_OVERRULE_8(val) \
      GP_WB_WRITE_U8(0x193, (val))

/* overrule enable LO Buffer to RX IQ mixer */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_RX_OVERRULE() \
        GP_WB_READ_U1(0x193, 0)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_RX_OVERRULE_FROM_OVERRULE_8(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_RX_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_RX_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule Power-up signal of MIX sampler */
#define GP_WB_READ_RADIOITF_FLL_MIXSAM_PUP_OVERRULE() \
        GP_WB_READ_U1(0x193, 1)

#define GP_WB_GET_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_MIXSAM_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_MIXSAM_PUP_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule enable for scale down LDO current factor 4: LP mode */
#define GP_WB_READ_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE() \
        GP_WB_READ_U1(0x193, 2)

#define GP_WB_GET_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LO_LDO_LPMODE_ENA_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule for enable the clock to the BPF for constant-GM sw-cap circuit */
#define GP_WB_READ_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE() \
        GP_WB_READ_U1(0x193, 3)

#define GP_WB_GET_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XOSC_CLK_16MEG_ENA_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule first stage pup signal of LO buffers */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_OVERRULE() \
        GP_WB_READ_U1(0x193, 4)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule PUP-signal LO Buffer to BIAS */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_BIAS_OVERRULE() \
        GP_WB_READ_U1(0x193, 5)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_BIAS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_BIAS_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* overrule PUP-signal LO Buffer to FLL MIXsampler (I/Q) */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLL_OVERRULE() \
        GP_WB_READ_U1(0x193, 6)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLL_OVERRULE_FROM_OVERRULE_8(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_FLL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x193, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_FLL_OVERRULE_TO_OVERRULE_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_9() \
        GP_WB_READ_U8(0x194)

#define GP_WB_WRITE_RADIOITF_OVERRULE_9(val) \
      GP_WB_WRITE_U8(0x194, (val))

/* overrule PUP-signal LO Buffer to FLL DIV */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE() \
        GP_WB_READ_U1(0x194, 0)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_FROM_OVERRULE_9(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_FLLDIV_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule PUP-signal for LO Buffer to PA */
#define GP_WB_READ_RADIOITF_LOBUF_PUP_PA_OVERRULE() \
        GP_WB_READ_U1(0x194, 1)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_PA_OVERRULE_FROM_OVERRULE_9(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_LOBUF_PUP_PA_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LOBUF_PUP_PA_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule divider bias cell */
#define GP_WB_READ_RADIOITF_RFDIV_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x194, 2)

#define GP_WB_GET_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_FROM_OVERRULE_9(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFDIV_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFDIV_BIAS_PUP_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule divider cml dff pup signal */
#define GP_WB_READ_RADIOITF_RFDIV_PUP_OVERRULE() \
        GP_WB_READ_U1(0x194, 3)

#define GP_WB_GET_RADIOITF_RFDIV_PUP_OVERRULE_FROM_OVERRULE_9(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFDIV_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFDIV_PUP_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule power-up pmos current mirror */
#define GP_WB_READ_RADIOITF_VCO_PMIR_PUP_OVERRULE() \
        GP_WB_READ_U1(0x194, 4)

#define GP_WB_GET_RADIOITF_VCO_PMIR_PUP_OVERRULE_FROM_OVERRULE_9(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_VCO_PMIR_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VCO_PMIR_PUP_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule FLL acquisition divider selection 16 or 64 */
#define GP_WB_READ_RADIOITF_FLL_DIV16_64_OVERRULE() \
        GP_WB_READ_U1(0x194, 5)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_OVERRULE_FROM_OVERRULE_9(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV16_64_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x194, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV16_64_OVERRULE_TO_OVERRULE_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* overrule mixsampler offset word : [6]=sign [5:0]=magnitude */
#define GP_WB_READ_RADIOITF_MIXSAMP_OFFSET_OVERRULE() \
        (GP_WB_S8(GP_WB_READ_U8(0x195), 7))

#define GP_WB_WRITE_RADIOITF_MIXSAMP_OFFSET_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_WRITE_U8(0x195, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_11() \
        GP_WB_READ_U8(0x196)

#define GP_WB_WRITE_RADIOITF_OVERRULE_11(val) \
      GP_WB_WRITE_U8(0x196, (val))

/* overrule charge pump power-up */
#define GP_WB_READ_RADIOITF_CP_PUP_OVERRULE() \
        GP_WB_READ_U1(0x196, 0)

#define GP_WB_GET_RADIOITF_CP_PUP_OVERRULE_FROM_OVERRULE_11(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_CP_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x196, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CP_PUP_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule select either port RF1 or port RF2 */
#define GP_WB_READ_RADIOITF_PA_ANT_SW_OVERRULE() \
        GP_WB_READ_U1(0x196, 1)

#define GP_WB_GET_RADIOITF_PA_ANT_SW_OVERRULE_FROM_OVERRULE_11(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_ANT_SW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x196, 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_ANT_SW_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule power up of PA bias block */
#define GP_WB_READ_RADIOITF_PA_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(0x196, 2)

#define GP_WB_GET_RADIOITF_PA_BIAS_PUP_OVERRULE_FROM_OVERRULE_11(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x196, 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_BIAS_PUP_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* overrule PA and PA-driver power-up signal in 1.2V-domain */
#define GP_WB_READ_RADIOITF_PA_PUP_OVERRULE() \
        GP_WB_READ_U1(0x196, 3)

#define GP_WB_GET_RADIOITF_PA_PUP_OVERRULE_FROM_OVERRULE_11(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x196, 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PUP_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* overrule select either port RF1 or port RF2 */
#define GP_WB_READ_RADIOITF_ANTSW_ANT_SW_OVERRULE() \
        GP_WB_READ_U1(0x196, 4)

#define GP_WB_GET_RADIOITF_ANTSW_ANT_SW_OVERRULE_FROM_OVERRULE_11(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_ANTSW_ANT_SW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x196, 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_ANTSW_ANT_SW_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* overrule lna buffer bias pull up */
#define GP_WB_READ_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE() \
        ((GP_WB_READ_U8(0x196) >> 5) & 0x03)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_FROM_OVERRULE_11(tmp) \
        (((tmp) >> 5) & 0x03)

#define GP_WB_WRITE_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x196, 0x60, (val) << 5); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_BUFFER_BIAS_PUP_OVERRULE_TO_OVERRULE_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_OVERRULE_12() \
        GP_WB_READ_U8(0x197)

#define GP_WB_WRITE_RADIOITF_OVERRULE_12(val) \
      GP_WB_WRITE_U8(0x197, (val))

/* overrule lna core pull up */
#define GP_WB_READ_RADIOITF_LNA_CORE_PUP_OVERRULE() \
        GP_WB_READ_U1(0x197, 0)

#define GP_WB_GET_RADIOITF_LNA_CORE_PUP_OVERRULE_FROM_OVERRULE_12(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_LNA_CORE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x197, 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_LNA_CORE_PUP_OVERRULE_TO_OVERRULE_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* overrule PA output power */
#define GP_WB_READ_RADIOITF_PA_PWR_OVERRULE() \
        ((GP_WB_READ_U8(0x197) >> 1) & 0x0F)

#define GP_WB_GET_RADIOITF_PA_PWR_OVERRULE_FROM_OVERRULE_12(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_RADIOITF_PA_PWR_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x197, 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_PWR_OVERRULE_TO_OVERRULE_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x61; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* low-power mode */
#define GP_WB_READ_RADIOITF_PA_LOW_OVERRULE() \
        GP_WB_READ_U1(0x197, 5)

#define GP_WB_GET_RADIOITF_PA_LOW_OVERRULE_FROM_OVERRULE_12(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_LOW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x197, 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_LOW_OVERRULE_TO_OVERRULE_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Puts PA in ultra-low power mode (-30dBm), 1.2V */
#define GP_WB_READ_RADIOITF_PA_ULTRALOW_OVERRULE() \
        GP_WB_READ_U1(0x197, 6)

#define GP_WB_GET_RADIOITF_PA_ULTRALOW_OVERRULE_FROM_OVERRULE_12(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_PA_ULTRALOW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x197, 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_PA_ULTRALOW_OVERRULE_TO_OVERRULE_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_0() \
        GP_WB_READ_U8(0x198)

#define GP_WB_READ_RADIOITF_TX_DAC_IN_STATUS() \
        GP_WB_READ_U1(0x198, 0)

#define GP_WB_GET_RADIOITF_TX_DAC_IN_STATUS_FROM_STATUS_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_TXDATA_STATUS() \
        ((GP_WB_READ_U8(0x198) >> 1) & 0x03)

#define GP_WB_GET_RADIOITF_TXDATA_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_READ_RADIOITF_PA_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x198, 3)

#define GP_WB_GET_RADIOITF_PA_LDO_LPMODE_ENA_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_PA_PUP_N_STATUS() \
        GP_WB_READ_U1(0x198, 4)

#define GP_WB_GET_RADIOITF_PA_PUP_N_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_PA_PUP_P_STATUS() \
        GP_WB_READ_U1(0x198, 5)

#define GP_WB_GET_RADIOITF_PA_PUP_P_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RADIOITF_TXMOD_PUP_STATUS() \
        GP_WB_READ_U1(0x198, 6)

#define GP_WB_GET_RADIOITF_TXMOD_PUP_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_RADIOITF_TXMOD_SPEEDUP_STATUS() \
        GP_WB_READ_U1(0x198, 7)

#define GP_WB_GET_RADIOITF_TXMOD_SPEEDUP_STATUS_FROM_STATUS_0(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_1() \
        GP_WB_READ_U8(0x199)

#define GP_WB_READ_RADIOITF_BPF_BIAS_N_PUP_STATUS() \
        GP_WB_READ_U1(0x199, 0)

#define GP_WB_GET_RADIOITF_BPF_BIAS_N_PUP_STATUS_FROM_STATUS_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_BPF_BIAS_P_PUP_STATUS() \
        GP_WB_READ_U1(0x199, 1)

#define GP_WB_GET_RADIOITF_BPF_BIAS_P_PUP_STATUS_FROM_STATUS_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_BPF_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x199, 2)

#define GP_WB_GET_RADIOITF_BPF_BIAS_PUP_STATUS_FROM_STATUS_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_BPF_CLK_PUP_STATUS() \
        GP_WB_READ_U1(0x199, 3)

#define GP_WB_GET_RADIOITF_BPF_CLK_PUP_STATUS_FROM_STATUS_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_BPF_INT_LDO_PUP_STATUS() \
        GP_WB_READ_U1(0x199, 4)

#define GP_WB_GET_RADIOITF_BPF_INT_LDO_PUP_STATUS_FROM_STATUS_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_BPF_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x199, 5)

#define GP_WB_GET_RADIOITF_BPF_LDO_LPMODE_ENA_STATUS_FROM_STATUS_1(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_2() \
        GP_WB_READ_U8(0x19a)

#define GP_WB_READ_RADIOITF_LNA_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 0)

#define GP_WB_GET_RADIOITF_LNA_BIAS_PUP_STATUS_FROM_STATUS_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 1)

#define GP_WB_GET_RADIOITF_LIM_BIAS_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_I_DIFF2SE_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 2)

#define GP_WB_GET_RADIOITF_LIM_I_DIFF2SE_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_I_STAGE_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 3)

#define GP_WB_GET_RADIOITF_LIM_I_STAGE_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_Q_DIFF2SE_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 4)

#define GP_WB_GET_RADIOITF_LIM_Q_DIFF2SE_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_Q_STAGE_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 5)

#define GP_WB_GET_RADIOITF_LIM_Q_STAGE_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RADIOITF_LIM_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x19a, 6)

#define GP_WB_GET_RADIOITF_LIM_LDO_LPMODE_ENA_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_RADIOITF_LNA_BUFFER_CORE_PUP_STATUS() \
        GP_WB_READ_U1(0x19a, 7)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_CORE_PUP_STATUS_FROM_STATUS_2(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_3() \
        GP_WB_READ_U8(0x19b)

#define GP_WB_READ_RADIOITF_LNAMIX_ENA_LDO_RESBYP_STATUS() \
        GP_WB_READ_U1(0x19b, 0)

#define GP_WB_GET_RADIOITF_LNAMIX_ENA_LDO_RESBYP_STATUS_FROM_STATUS_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_LNAMIX_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x19b, 1)

#define GP_WB_GET_RADIOITF_LNAMIX_LDO_LPMODE_ENA_STATUS_FROM_STATUS_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_CP_DOWN_STATUS() \
        GP_WB_READ_U1(0x19b, 2)

#define GP_WB_GET_RADIOITF_CP_DOWN_STATUS_FROM_STATUS_3(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_4() \
        GP_WB_READ_U8(0x19c)

#define GP_WB_READ_RADIOITF_CP_UP_STATUS() \
        GP_WB_READ_U1(0x19c, 0)

#define GP_WB_GET_RADIOITF_CP_UP_STATUS_FROM_STATUS_4(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_CP_REFDAC_STATUS() \
        (GP_WB_S8(((GP_WB_READ_U8(0x19c) >> 1) & 0x7F), 7))

#define GP_WB_GET_RADIOITF_CP_REFDAC_STATUS_FROM_STATUS_4(tmp) \
        (GP_WB_S8((((tmp) >> 1) & 0x7F), 7))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_5() \
        GP_WB_READ_U8(0x19d)

#define GP_WB_READ_RADIOITF_FLL_LOOPFILT_SPEEDUP_STATUS() \
        GP_WB_READ_U1(0x19d, 0)

#define GP_WB_GET_RADIOITF_FLL_LOOPFILT_SPEEDUP_STATUS_FROM_STATUS_5(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SIGN_STATUS() \
        GP_WB_READ_U1(0x19d, 1)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SIGN_STATUS_FROM_STATUS_5(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_RCMEAS_SW_STATUS() \
        GP_WB_READ_U1(0x19d, 2)

#define GP_WB_GET_RADIOITF_FLL_RCMEAS_SW_STATUS_FROM_STATUS_5(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_VMID_PUP_STATUS() \
        GP_WB_READ_U1(0x19d, 3)

#define GP_WB_GET_RADIOITF_FLL_VMID_PUP_STATUS_FROM_STATUS_5(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_MIXSAMP_LF_LO_FREQ_STATUS() \
        (GP_WB_S8(((GP_WB_READ_U8(0x19d) >> 4) & 0x03), 2))

#define GP_WB_GET_RADIOITF_MIXSAMP_LF_LO_FREQ_STATUS_FROM_STATUS_5(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x03), 2))

#define GP_WB_READ_RADIOITF_ANTSW_PUP_STATUS() \
        GP_WB_READ_U1(0x19d, 6)

#define GP_WB_GET_RADIOITF_ANTSW_PUP_STATUS_FROM_STATUS_5(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_RADIOITF_CP_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x19d, 7)

#define GP_WB_GET_RADIOITF_CP_BIAS_PUP_STATUS_FROM_STATUS_5(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_6() \
        GP_WB_READ_U8(0x19e)

#define GP_WB_READ_RADIOITF_VCO_C_COARSE_STATUS() \
        (GP_WB_READ_U8(0x19e) & 0x1F)

#define GP_WB_GET_RADIOITF_VCO_C_COARSE_STATUS_FROM_STATUS_6(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_RADIOITF_PA_TX_SEL_STATUS() \
        GP_WB_READ_U1(0x19e, 5)

#define GP_WB_GET_RADIOITF_PA_TX_SEL_STATUS_FROM_STATUS_6(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_7() \
        GP_WB_READ_U8(0x19f)

#define GP_WB_READ_RADIOITF_VCO_C_FINE_STATUS() \
        (GP_WB_READ_U8(0x19f) & 0x1F)

#define GP_WB_GET_RADIOITF_VCO_C_FINE_STATUS_FROM_STATUS_7(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_RADIOITF_FLL_DIV_PUP_STATUS() \
        GP_WB_READ_U1(0x19f, 5)

#define GP_WB_GET_RADIOITF_FLL_DIV_PUP_STATUS_FROM_STATUS_7(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_DIVSAM_PUP_STATUS() \
        GP_WB_READ_U1(0x19f, 6)

#define GP_WB_GET_RADIOITF_FLL_DIVSAM_PUP_STATUS_FROM_STATUS_7(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x19f, 7)

#define GP_WB_GET_RADIOITF_FLL_LDO_LPMODE_ENA_STATUS_FROM_STATUS_7(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_8() \
        GP_WB_READ_U8(0x1a0)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_RX_STATUS() \
        GP_WB_READ_U1(0x1a0, 0)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_RX_STATUS_FROM_STATUS_8(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_MIXSAM_PUP_STATUS() \
        GP_WB_READ_U1(0x1a0, 1)

#define GP_WB_GET_RADIOITF_FLL_MIXSAM_PUP_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_LO_LDO_LPMODE_ENA_STATUS() \
        GP_WB_READ_U1(0x1a0, 2)

#define GP_WB_GET_RADIOITF_LO_LDO_LPMODE_ENA_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_XOSC_CLK_16MEG_ENA_STATUS() \
        GP_WB_READ_U1(0x1a0, 3)

#define GP_WB_GET_RADIOITF_XOSC_CLK_16MEG_ENA_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_STATUS() \
        GP_WB_READ_U1(0x1a0, 4)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_BIAS_STATUS() \
        GP_WB_READ_U1(0x1a0, 5)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_BIAS_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLL_STATUS() \
        GP_WB_READ_U1(0x1a0, 6)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLL_STATUS_FROM_STATUS_8(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_9() \
        GP_WB_READ_U8(0x1a1)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_FLLDIV_STATUS() \
        GP_WB_READ_U1(0x1a1, 0)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_FLLDIV_STATUS_FROM_STATUS_9(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_LOBUF_PUP_PA_STATUS() \
        GP_WB_READ_U1(0x1a1, 1)

#define GP_WB_GET_RADIOITF_LOBUF_PUP_PA_STATUS_FROM_STATUS_9(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_RFDIV_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x1a1, 2)

#define GP_WB_GET_RADIOITF_RFDIV_BIAS_PUP_STATUS_FROM_STATUS_9(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_RFDIV_PUP_STATUS() \
        GP_WB_READ_U1(0x1a1, 3)

#define GP_WB_GET_RADIOITF_RFDIV_PUP_STATUS_FROM_STATUS_9(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_VCO_PMIR_PUP_STATUS() \
        GP_WB_READ_U1(0x1a1, 4)

#define GP_WB_GET_RADIOITF_VCO_PMIR_PUP_STATUS_FROM_STATUS_9(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_FLL_DIV16_64_STATUS() \
        GP_WB_READ_U1(0x1a1, 5)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_STATUS_FROM_STATUS_9(tmp) \
        (((tmp) >> 5) & 0x01)


#define GP_WB_READ_RADIOITF_MIXSAMP_OFFSET_STATUS() \
        (GP_WB_S8(GP_WB_READ_U8(0x1a2), 7))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_11() \
        GP_WB_READ_U8(0x1a3)

#define GP_WB_READ_RADIOITF_CP_PUP_STATUS() \
        GP_WB_READ_U1(0x1a3, 0)

#define GP_WB_GET_RADIOITF_CP_PUP_STATUS_FROM_STATUS_11(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_PA_ANT_SW_STATUS() \
        GP_WB_READ_U1(0x1a3, 1)

#define GP_WB_GET_RADIOITF_PA_ANT_SW_STATUS_FROM_STATUS_11(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIOITF_PA_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(0x1a3, 2)

#define GP_WB_GET_RADIOITF_PA_BIAS_PUP_STATUS_FROM_STATUS_11(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RADIOITF_PA_PUP_STATUS() \
        GP_WB_READ_U1(0x1a3, 3)

#define GP_WB_GET_RADIOITF_PA_PUP_STATUS_FROM_STATUS_11(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RADIOITF_ANTSW_ANT_SW_STATUS() \
        GP_WB_READ_U1(0x1a3, 4)

#define GP_WB_GET_RADIOITF_ANTSW_ANT_SW_STATUS_FROM_STATUS_11(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RADIOITF_LNA_BUFFER_BIAS_PUP_STATUS() \
        ((GP_WB_READ_U8(0x1a3) >> 5) & 0x03)

#define GP_WB_GET_RADIOITF_LNA_BUFFER_BIAS_PUP_STATUS_FROM_STATUS_11(tmp) \
        (((tmp) >> 5) & 0x03)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_STATUS_12() \
        GP_WB_READ_U8(0x1a4)

#define GP_WB_READ_RADIOITF_LNA_CORE_PUP_STATUS() \
        GP_WB_READ_U1(0x1a4, 0)

#define GP_WB_GET_RADIOITF_LNA_CORE_PUP_STATUS_FROM_STATUS_12(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIOITF_PA_PWR_STATUS() \
        ((GP_WB_READ_U8(0x1a4) >> 1) & 0x0F)

#define GP_WB_GET_RADIOITF_PA_PWR_STATUS_FROM_STATUS_12(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_READ_RADIOITF_PA_LOW_STATUS() \
        GP_WB_READ_U1(0x1a4, 5)

#define GP_WB_GET_RADIOITF_PA_LOW_STATUS_FROM_STATUS_12(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RADIOITF_PA_ULTRALOW_STATUS() \
        GP_WB_READ_U1(0x1a4, 6)

#define GP_WB_GET_RADIOITF_PA_ULTRALOW_STATUS_FROM_STATUS_12(tmp) \
        (((tmp) >> 6) & 0x01)

/***************************
 * layout: gpio
 ***************************/

/* Gpio clock enabled when 0x1 */
#define GP_WB_READ_GPIO_GPIO_CLOCK_ENABLE() \
        GP_WB_READ_U1(0x200, 0)

#define GP_WB_WRITE_GPIO_GPIO_CLOCK_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x200, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_DIRECTION() \
        GP_WB_READ_U8(0x201)

#define GP_WB_WRITE_GPIO_GPIO_PORTA_DIRECTION(val) \
      GP_WB_WRITE_U8(0x201, (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO0_DIRECTION() \
        GP_WB_READ_U1(0x201, 0)

#define GP_WB_GET_GPIO_GPIO0_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO0_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO0_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO1_DIRECTION() \
        GP_WB_READ_U1(0x201, 1)

#define GP_WB_GET_GPIO_GPIO1_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO1_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO1_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO2_DIRECTION() \
        GP_WB_READ_U1(0x201, 2)

#define GP_WB_GET_GPIO_GPIO2_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO2_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO2_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO3_DIRECTION() \
        GP_WB_READ_U1(0x201, 3)

#define GP_WB_GET_GPIO_GPIO3_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO3_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO3_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO4_DIRECTION() \
        GP_WB_READ_U1(0x201, 4)

#define GP_WB_GET_GPIO_GPIO4_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO4_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO4_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO5_DIRECTION() \
        GP_WB_READ_U1(0x201, 5)

#define GP_WB_GET_GPIO_GPIO5_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO5_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO5_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO6_DIRECTION() \
        GP_WB_READ_U1(0x201, 6)

#define GP_WB_GET_GPIO_GPIO6_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO6_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO6_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO7_DIRECTION() \
        GP_WB_READ_U1(0x201, 7)

#define GP_WB_GET_GPIO_GPIO7_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO7_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x201, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO7_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_DIRECTION() \
        GP_WB_READ_U8(0x202)

#define GP_WB_WRITE_GPIO_GPIO_PORTB_DIRECTION(val) \
      GP_WB_WRITE_U8(0x202, (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO8_DIRECTION() \
        GP_WB_READ_U1(0x202, 0)

#define GP_WB_GET_GPIO_GPIO8_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO8_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO8_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO9_DIRECTION() \
        GP_WB_READ_U1(0x202, 1)

#define GP_WB_GET_GPIO_GPIO9_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO9_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO9_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO10_DIRECTION() \
        GP_WB_READ_U1(0x202, 2)

#define GP_WB_GET_GPIO_GPIO10_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO10_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO10_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO11_DIRECTION() \
        GP_WB_READ_U1(0x202, 3)

#define GP_WB_GET_GPIO_GPIO11_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO11_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO11_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO12_DIRECTION() \
        GP_WB_READ_U1(0x202, 4)

#define GP_WB_GET_GPIO_GPIO12_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO12_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO12_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO13_DIRECTION() \
        GP_WB_READ_U1(0x202, 5)

#define GP_WB_GET_GPIO_GPIO13_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO13_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO13_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO14_DIRECTION() \
        GP_WB_READ_U1(0x202, 6)

#define GP_WB_GET_GPIO_GPIO14_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO14_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO14_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO15_DIRECTION() \
        GP_WB_READ_U1(0x202, 7)

#define GP_WB_GET_GPIO_GPIO15_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO15_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x202, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO15_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_DIRECTION() \
        GP_WB_READ_U8(0x203)

#define GP_WB_WRITE_GPIO_GPIO_PORTC_DIRECTION(val) \
      GP_WB_WRITE_U8(0x203, (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO16_DIRECTION() \
        GP_WB_READ_U1(0x203, 0)

#define GP_WB_GET_GPIO_GPIO16_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO16_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO16_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO17_DIRECTION() \
        GP_WB_READ_U1(0x203, 1)

#define GP_WB_GET_GPIO_GPIO17_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO17_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO17_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO18_DIRECTION() \
        GP_WB_READ_U1(0x203, 2)

#define GP_WB_GET_GPIO_GPIO18_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO18_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO18_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO19_DIRECTION() \
        GP_WB_READ_U1(0x203, 3)

#define GP_WB_GET_GPIO_GPIO19_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO19_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO19_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO20_DIRECTION() \
        GP_WB_READ_U1(0x203, 4)

#define GP_WB_GET_GPIO_GPIO20_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO20_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO20_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO21_DIRECTION() \
        GP_WB_READ_U1(0x203, 5)

#define GP_WB_GET_GPIO_GPIO21_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO21_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO21_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO22_DIRECTION() \
        GP_WB_READ_U1(0x203, 6)

#define GP_WB_GET_GPIO_GPIO22_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO22_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO22_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO23_DIRECTION() \
        GP_WB_READ_U1(0x203, 7)

#define GP_WB_GET_GPIO_GPIO23_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO23_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x203, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO23_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTD_DIRECTION() \
        GP_WB_READ_U8(0x204)

#define GP_WB_WRITE_GPIO_GPIO_PORTD_DIRECTION(val) \
      GP_WB_WRITE_U8(0x204, (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO24_DIRECTION() \
        GP_WB_READ_U1(0x204, 0)

#define GP_WB_GET_GPIO_GPIO24_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO24_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO24_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO25_DIRECTION() \
        GP_WB_READ_U1(0x204, 1)

#define GP_WB_GET_GPIO_GPIO25_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO25_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO25_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO26_DIRECTION() \
        GP_WB_READ_U1(0x204, 2)

#define GP_WB_GET_GPIO_GPIO26_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO26_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO26_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO27_DIRECTION() \
        GP_WB_READ_U1(0x204, 3)

#define GP_WB_GET_GPIO_GPIO27_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO27_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO27_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO28_DIRECTION() \
        GP_WB_READ_U1(0x204, 4)

#define GP_WB_GET_GPIO_GPIO28_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO28_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO28_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO29_DIRECTION() \
        GP_WB_READ_U1(0x204, 5)

#define GP_WB_GET_GPIO_GPIO29_DIRECTION_FROM_GPIO_PORTD_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO29_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x204, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO29_DIRECTION_TO_GPIO_PORTD_DIRECTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_OUTPUT_VALUE() \
        GP_WB_READ_U8(0x205)

#define GP_WB_WRITE_GPIO_GPIO_PORTA_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(0x205, (val))

#define GP_WB_READ_GPIO_GPIO0_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 0)

#define GP_WB_GET_GPIO_GPIO0_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO0_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO0_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO1_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 1)

#define GP_WB_GET_GPIO_GPIO1_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO1_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO1_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO2_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 2)

#define GP_WB_GET_GPIO_GPIO2_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO2_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO2_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO3_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 3)

#define GP_WB_GET_GPIO_GPIO3_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO3_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO3_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO4_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 4)

#define GP_WB_GET_GPIO_GPIO4_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO4_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO4_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO5_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 5)

#define GP_WB_GET_GPIO_GPIO5_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO5_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO5_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO6_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 6)

#define GP_WB_GET_GPIO_GPIO6_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO6_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO6_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO7_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x205, 7)

#define GP_WB_GET_GPIO_GPIO7_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO7_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x205, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO7_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_OUTPUT_VALUE() \
        GP_WB_READ_U8(0x206)

#define GP_WB_WRITE_GPIO_GPIO_PORTB_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(0x206, (val))

#define GP_WB_READ_GPIO_GPIO8_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 0)

#define GP_WB_GET_GPIO_GPIO8_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO8_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO8_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO9_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 1)

#define GP_WB_GET_GPIO_GPIO9_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO9_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO9_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO10_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 2)

#define GP_WB_GET_GPIO_GPIO10_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO10_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO10_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO11_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 3)

#define GP_WB_GET_GPIO_GPIO11_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO11_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO11_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO12_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 4)

#define GP_WB_GET_GPIO_GPIO12_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO12_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO12_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO13_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 5)

#define GP_WB_GET_GPIO_GPIO13_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO13_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO13_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO14_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 6)

#define GP_WB_GET_GPIO_GPIO14_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO14_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO14_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO15_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x206, 7)

#define GP_WB_GET_GPIO_GPIO15_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO15_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x206, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO15_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_OUTPUT_VALUE() \
        GP_WB_READ_U8(0x207)

#define GP_WB_WRITE_GPIO_GPIO_PORTC_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(0x207, (val))

#define GP_WB_READ_GPIO_GPIO16_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 0)

#define GP_WB_GET_GPIO_GPIO16_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO16_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO16_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO17_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 1)

#define GP_WB_GET_GPIO_GPIO17_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO17_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO17_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO18_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 2)

#define GP_WB_GET_GPIO_GPIO18_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO18_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO18_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO19_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 3)

#define GP_WB_GET_GPIO_GPIO19_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO19_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO19_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO20_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 4)

#define GP_WB_GET_GPIO_GPIO20_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO20_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO20_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO21_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 5)

#define GP_WB_GET_GPIO_GPIO21_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO21_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO21_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO22_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 6)

#define GP_WB_GET_GPIO_GPIO22_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO22_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO22_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO23_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x207, 7)

#define GP_WB_GET_GPIO_GPIO23_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO23_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x207, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO23_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTD_OUTPUT_VALUE() \
        GP_WB_READ_U8(0x208)

#define GP_WB_WRITE_GPIO_GPIO_PORTD_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(0x208, (val))

#define GP_WB_READ_GPIO_GPIO24_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 0)

#define GP_WB_GET_GPIO_GPIO24_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO24_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO24_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO25_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 1)

#define GP_WB_GET_GPIO_GPIO25_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO25_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO25_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO26_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 2)

#define GP_WB_GET_GPIO_GPIO26_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO26_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO26_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO27_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 3)

#define GP_WB_GET_GPIO_GPIO27_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO27_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO27_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO28_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 4)

#define GP_WB_GET_GPIO_GPIO28_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO28_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO28_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO29_OUTPUT_VALUE() \
        GP_WB_READ_U1(0x208, 5)

#define GP_WB_GET_GPIO_GPIO29_OUTPUT_VALUE_FROM_GPIO_PORTD_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO29_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x208, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO29_OUTPUT_VALUE_TO_GPIO_PORTD_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_INPUT_VALUE() \
        GP_WB_READ_U8(0x209)

#define GP_WB_READ_GPIO_GPIO0_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 0)

#define GP_WB_GET_GPIO_GPIO0_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO1_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 1)

#define GP_WB_GET_GPIO_GPIO1_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO2_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 2)

#define GP_WB_GET_GPIO_GPIO2_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO3_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 3)

#define GP_WB_GET_GPIO_GPIO3_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO4_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 4)

#define GP_WB_GET_GPIO_GPIO4_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO5_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 5)

#define GP_WB_GET_GPIO_GPIO5_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO6_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 6)

#define GP_WB_GET_GPIO_GPIO6_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_GPIO_GPIO7_INPUT_VALUE() \
        GP_WB_READ_U1(0x209, 7)

#define GP_WB_GET_GPIO_GPIO7_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_INPUT_VALUE() \
        GP_WB_READ_U8(0x20a)

#define GP_WB_READ_GPIO_GPIO8_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 0)

#define GP_WB_GET_GPIO_GPIO8_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO9_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 1)

#define GP_WB_GET_GPIO_GPIO9_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO10_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 2)

#define GP_WB_GET_GPIO_GPIO10_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO11_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 3)

#define GP_WB_GET_GPIO_GPIO11_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO12_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 4)

#define GP_WB_GET_GPIO_GPIO12_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO13_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 5)

#define GP_WB_GET_GPIO_GPIO13_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO14_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 6)

#define GP_WB_GET_GPIO_GPIO14_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_GPIO_GPIO15_INPUT_VALUE() \
        GP_WB_READ_U1(0x20a, 7)

#define GP_WB_GET_GPIO_GPIO15_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_INPUT_VALUE() \
        GP_WB_READ_U8(0x20b)

#define GP_WB_READ_GPIO_GPIO16_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 0)

#define GP_WB_GET_GPIO_GPIO16_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO17_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 1)

#define GP_WB_GET_GPIO_GPIO17_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO18_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 2)

#define GP_WB_GET_GPIO_GPIO18_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO19_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 3)

#define GP_WB_GET_GPIO_GPIO19_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO20_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 4)

#define GP_WB_GET_GPIO_GPIO20_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO21_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 5)

#define GP_WB_GET_GPIO_GPIO21_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO22_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 6)

#define GP_WB_GET_GPIO_GPIO22_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_GPIO_GPIO23_INPUT_VALUE() \
        GP_WB_READ_U1(0x20b, 7)

#define GP_WB_GET_GPIO_GPIO23_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTD_INPUT_VALUE() \
        GP_WB_READ_U8(0x20c)

#define GP_WB_READ_GPIO_GPIO24_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 0)

#define GP_WB_GET_GPIO_GPIO24_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO25_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 1)

#define GP_WB_GET_GPIO_GPIO25_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO26_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 2)

#define GP_WB_GET_GPIO_GPIO26_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO27_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 3)

#define GP_WB_GET_GPIO_GPIO27_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO28_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 4)

#define GP_WB_GET_GPIO_GPIO28_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO29_INPUT_VALUE() \
        GP_WB_READ_U1(0x20c, 5)

#define GP_WB_GET_GPIO_GPIO29_INPUT_VALUE_FROM_GPIO_PORTD_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_EXTI_PORT_SEL() \
        GP_WB_READ_U16(0x20e)

#define GP_WB_WRITE_GPIO_EXTI_PORT_SEL(val) \
      GP_WB_WRITE_U16(0x20e, (val))

/* Select the correct port for the exti0 interrupt */
#define GP_WB_READ_GPIO_EXTI0_PORT_SEL() \
        (GP_WB_READ_U8(0x20e) & 0x03)

#define GP_WB_GET_GPIO_EXTI0_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI0_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20e, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI0_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Select the correct port for the exti1 interrupt */
#define GP_WB_READ_GPIO_EXTI1_PORT_SEL() \
        ((GP_WB_READ_U8(0x20e) >> 2) & 0x03)

#define GP_WB_GET_GPIO_EXTI1_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI1_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20e, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI1_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFF3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Select the correct port for the exti2 interrupt */
#define GP_WB_READ_GPIO_EXTI2_PORT_SEL() \
        ((GP_WB_READ_U8(0x20e) >> 4) & 0x03)

#define GP_WB_GET_GPIO_EXTI2_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI2_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20e, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI2_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFCF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Select the correct port for the exti3 interrupt */
#define GP_WB_READ_GPIO_EXTI3_PORT_SEL() \
        ((GP_WB_READ_U8(0x20e) >> 6) & 0x03)

#define GP_WB_GET_GPIO_EXTI3_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI3_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20e, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI3_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFF3F; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Select the correct port for the exti4 interrupt */
#define GP_WB_READ_GPIO_EXTI4_PORT_SEL() \
        (GP_WB_READ_U8(0x20f) & 0x03)

#define GP_WB_GET_GPIO_EXTI4_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI4_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20f, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI4_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFCFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Select the correct port for the exti5 interrupt */
#define GP_WB_READ_GPIO_EXTI5_PORT_SEL() \
        ((GP_WB_READ_U8(0x20f) >> 2) & 0x03)

#define GP_WB_GET_GPIO_EXTI5_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI5_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20f, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI5_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Select the correct port for the exti6 interrupt */
#define GP_WB_READ_GPIO_EXTI6_PORT_SEL() \
        ((GP_WB_READ_U8(0x20f) >> 4) & 0x03)

#define GP_WB_GET_GPIO_EXTI6_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI6_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20f, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI6_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Select the correct port for the exti7 interrupt */
#define GP_WB_READ_GPIO_EXTI7_PORT_SEL() \
        ((GP_WB_READ_U8(0x20f) >> 6) & 0x03)

#define GP_WB_GET_GPIO_EXTI7_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI7_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x20f, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI7_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_EXTI_EXPECTED_VALUE() \
        GP_WB_READ_U8(0x210)

#define GP_WB_WRITE_GPIO_EXTI_EXPECTED_VALUE(val) \
      GP_WB_WRITE_U8(0x210, (val))

/* Expected value for the pin associated with exti0 interrupt */
#define GP_WB_READ_GPIO_EXTI0_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 0)

#define GP_WB_GET_GPIO_EXTI0_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI0_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI0_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Expected value for the pin associated with exti1 interrupt */
#define GP_WB_READ_GPIO_EXTI1_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 1)

#define GP_WB_GET_GPIO_EXTI1_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI1_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI1_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Expected value for the pin associated with exti2 interrupt */
#define GP_WB_READ_GPIO_EXTI2_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 2)

#define GP_WB_GET_GPIO_EXTI2_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI2_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI2_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Expected value for the pin associated with exti3 interrupt */
#define GP_WB_READ_GPIO_EXTI3_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 3)

#define GP_WB_GET_GPIO_EXTI3_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI3_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI3_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Expected value for the pin associated with exti4 interrupt */
#define GP_WB_READ_GPIO_EXTI4_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 4)

#define GP_WB_GET_GPIO_EXTI4_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI4_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI4_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Expected value for the pin associated with exti5 interrupt */
#define GP_WB_READ_GPIO_EXTI5_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 5)

#define GP_WB_GET_GPIO_EXTI5_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI5_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI5_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Expected value for the pin associated with exti6 interrupt */
#define GP_WB_READ_GPIO_EXTI6_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 6)

#define GP_WB_GET_GPIO_EXTI6_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI6_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI6_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Expected value for the pin associated with exti7 interrupt */
#define GP_WB_READ_GPIO_EXTI7_EXPECTED_VALUE() \
        GP_WB_READ_U1(0x210, 7)

#define GP_WB_GET_GPIO_EXTI7_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI7_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x210, 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI7_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_INTERRUPT_STATUS() \
        GP_WB_READ_U8(0x211)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(0x211, 0)

#define GP_WB_GET_GPIO_UNMASKED_EXTI0_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        ((tmp) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(0x211, 1)

#define GP_WB_GET_GPIO_UNMASKED_EXTI1_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(0x211, 2)

#define GP_WB_GET_GPIO_UNMASKED_EXTI2_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(0x211, 3)

#define GP_WB_GET_GPIO_UNMASKED_EXTI3_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(0x211, 4)

#define GP_WB_GET_GPIO_UNMASKED_EXTI4_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(0x211, 5)

#define GP_WB_GET_GPIO_UNMASKED_EXTI5_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(0x211, 6)

#define GP_WB_GET_GPIO_UNMASKED_EXTI6_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(0x211, 7)

#define GP_WB_GET_GPIO_UNMASKED_EXTI7_INTERRUPT_FROM_GPIO_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)


#define GP_WB_WRITE_GPIO_CLEAR_EXTI_INTERRUPT(val) \
      GP_WB_WRITE_U8(0x212, (val))

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI0_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x01)

#define GP_WB_SET_GPIO_CLEAR_EXTI0_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI1_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x02)

#define GP_WB_SET_GPIO_CLEAR_EXTI1_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI2_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x04)

#define GP_WB_SET_GPIO_CLEAR_EXTI2_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI3_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x08)

#define GP_WB_SET_GPIO_CLEAR_EXTI3_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI4_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x10)

#define GP_WB_SET_GPIO_CLEAR_EXTI4_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI5_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x20)

#define GP_WB_SET_GPIO_CLEAR_EXTI5_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI6_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x40)

#define GP_WB_SET_GPIO_CLEAR_EXTI6_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLEAR_EXTI7_INTERRUPT() \
        GP_WB_WRITE_U8(0x212, 0x80)

#define GP_WB_SET_GPIO_CLEAR_EXTI7_INTERRUPT_TO_CLEAR_EXTI_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

/***************************
 * layout: twi_ms
 ***************************/

#define GP_WB_READ_TWI_MS_PRESCALER() \
        GP_WB_READ_U16(0x220)

#define GP_WB_WRITE_TWI_MS_PRESCALER(val) do { \
          GP_WB_WRITE_U16(0x220, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TWI_MS_PIN_CONFIG() \
        GP_WB_READ_U8(0x222)

#define GP_WB_WRITE_TWI_MS_PIN_CONFIG(val) \
      GP_WB_WRITE_U8(0x222, (val))

/* Sets the pinmap for the sda pin - remark that only mappings a to d are valid mappings */
#define GP_WB_READ_TWI_MS_SDA_PINMAP() \
        (GP_WB_READ_U8(0x222) & 0x07)

#define GP_WB_GET_TWI_MS_SDA_PINMAP_FROM_PIN_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TWI_MS_SDA_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x222, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TWI_MS_SDA_PINMAP_TO_PIN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the pinmap for the sclk pin - remark that only mappings a to d are valid mappings */
#define GP_WB_READ_TWI_MS_SCLK_PINMAP() \
        ((GP_WB_READ_U8(0x222) >> 3) & 0x07)

#define GP_WB_GET_TWI_MS_SCLK_PINMAP_FROM_PIN_CONFIG(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TWI_MS_SCLK_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x222, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TWI_MS_SCLK_PINMAP_TO_PIN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TWI_MS_CONFIG() \
        GP_WB_READ_U8(0x223)

#define GP_WB_WRITE_TWI_MS_CONFIG(val) \
      GP_WB_WRITE_U8(0x223, (val))

/* Enable core when '1' : en has to be put to '0' when a new prescaler value is loaded */
#define GP_WB_READ_TWI_MS_ENABLE() \
        GP_WB_READ_U1(0x223, 0)

#define GP_WB_GET_TWI_MS_ENABLE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TWI_MS_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x223, 0, (val)); \
        } while (0)

#define GP_WB_SET_TWI_MS_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* ACK to be transmitted */
#define GP_WB_READ_TWI_MS_ACK() \
        GP_WB_READ_U1(0x223, 1)

#define GP_WB_GET_TWI_MS_ACK_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TWI_MS_ACK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x223, 1, (val)); \
        } while (0)

#define GP_WB_SET_TWI_MS_ACK_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Disable clock synchronization slave wait detection */
#define GP_WB_READ_TWI_MS_CLK_SYNC_DISABLE() \
        GP_WB_READ_U1(0x223, 2)

#define GP_WB_GET_TWI_MS_CLK_SYNC_DISABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TWI_MS_CLK_SYNC_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x223, 2, (val)); \
        } while (0)

#define GP_WB_SET_TWI_MS_CLK_SYNC_DISABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Byte to be transferred */
#define GP_WB_READ_TWI_MS_TX_DATA() \
        GP_WB_READ_U8(0x224)

#define GP_WB_WRITE_TWI_MS_TX_DATA(val) do { \
          GP_WB_WRITE_U8(0x224, (val)); \
        } while (0)


/* Byte received */
#define GP_WB_READ_TWI_MS_RX_DATA() \
        GP_WB_READ_U8(0x225)


#define GP_WB_WRITE_TWI_MS_CONTROL(val) \
      GP_WB_WRITE_U8(0x226, (val))

/* Write to slave */
#define GP_WB_TWI_MS_WRITE() \
        GP_WB_WRITE_U8(0x226, 0x01)

#define GP_WB_SET_TWI_MS_WRITE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Read from slave */
#define GP_WB_TWI_MS_READ() \
        GP_WB_WRITE_U8(0x226, 0x02)

#define GP_WB_SET_TWI_MS_READ_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Generate stop condition */
#define GP_WB_TWI_MS_STOP() \
        GP_WB_WRITE_U8(0x226, 0x04)

#define GP_WB_SET_TWI_MS_STOP_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Generate (repeated) start condition */
#define GP_WB_TWI_MS_START() \
        GP_WB_WRITE_U8(0x226, 0x08)

#define GP_WB_SET_TWI_MS_START_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* TWI Done Interrupt clear */
#define GP_WB_TWI_MS_CLEAR_DONE_INT() \
        GP_WB_WRITE_U8(0x226, 0x10)

#define GP_WB_SET_TWI_MS_CLEAR_DONE_INT_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* TWI Arbitration Lost Interrupt clear */
#define GP_WB_TWI_MS_CLEAR_ARB_LOST_INT() \
        GP_WB_WRITE_U8(0x226, 0x20)

#define GP_WB_SET_TWI_MS_CLEAR_ARB_LOST_INT_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* TWI Clock Synchronization Slave Wait Interrupt clear */
#define GP_WB_TWI_MS_CLEAR_CLK_SYNC_INT() \
        GP_WB_WRITE_U8(0x226, 0x40)

#define GP_WB_SET_TWI_MS_CLEAR_CLK_SYNC_INT_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TWI_MS_STATUS() \
        GP_WB_READ_U8(0x227)

/* Byte Read or Byte Write in progress */
#define GP_WB_READ_TWI_MS_READ_WRITE_BUSY() \
        GP_WB_READ_U1(0x227, 0)

#define GP_WB_GET_TWI_MS_READ_WRITE_BUSY_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Data Transfer in progress (between start and stop condition) */
#define GP_WB_READ_TWI_MS_TRANSFER_BUSY() \
        GP_WB_READ_U1(0x227, 1)

#define GP_WB_GET_TWI_MS_TRANSFER_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* ACK from slave received */
#define GP_WB_READ_TWI_MS_RX_ACK() \
        GP_WB_READ_U1(0x227, 2)

#define GP_WB_GET_TWI_MS_RX_ACK_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Clock Synchornization Slave Wait */
#define GP_WB_READ_TWI_MS_CLK_SYNC() \
        GP_WB_READ_U1(0x227, 3)

#define GP_WB_GET_TWI_MS_CLK_SYNC_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Unmasked Done Interrupt */
#define GP_WB_READ_TWI_MS_UNMASKED_DONE_INT() \
        GP_WB_READ_U1(0x227, 4)

#define GP_WB_GET_TWI_MS_UNMASKED_DONE_INT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Unmasked Arbitration Lost Interrupt */
#define GP_WB_READ_TWI_MS_UNMASKED_ARB_LOST_INT() \
        GP_WB_READ_U1(0x227, 5)

#define GP_WB_GET_TWI_MS_UNMASKED_ARB_LOST_INT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Unmasked Clock Synchronization Slave Wait Interrupt */
#define GP_WB_READ_TWI_MS_UNMASKED_CLK_SYNC_INT() \
        GP_WB_READ_U1(0x227, 6)

#define GP_WB_GET_TWI_MS_UNMASKED_CLK_SYNC_INT_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/***************************
 * layout: adcif
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_GENERAL_CONFIG() \
        GP_WB_READ_U8(0x240)

#define GP_WB_WRITE_ADCIF_GENERAL_CONFIG(val) \
      GP_WB_WRITE_U8(0x240, (val))

/* Defines when the adc measurement is triggered - see enum for possibilities */
#define GP_WB_READ_ADCIF_TRIGGER_MODE() \
        (GP_WB_READ_U8(0x240) & 0x03)

#define GP_WB_GET_ADCIF_TRIGGER_MODE_FROM_GENERAL_CONFIG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_ADCIF_TRIGGER_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x240, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_TRIGGER_MODE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the number of conversions that are rejected between 2 measurements on different channels - acoounts for channel select mux settling time */
#define GP_WB_READ_ADCIF_NBR_OF_REJECTED_CONVERSIONS() \
        ((GP_WB_READ_U8(0x240) >> 2) & 0x0F)

#define GP_WB_GET_ADCIF_NBR_OF_REJECTED_CONVERSIONS_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_ADCIF_NBR_OF_REJECTED_CONVERSIONS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x240, 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_ADCIF_NBR_OF_REJECTED_CONVERSIONS_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xC3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Sets the number of slots that are used in a measurement cycle. Up to 4 slots can be used, resulting in an way to measure 4 different channels per cycle. This setting specifies the number of slots-1 (so setting 0 -> 1 slot, setting 3 -> 4 slots) */
#define GP_WB_READ_ADCIF_NBR_OF_SLOTS_IN_CYCLE() \
        ((GP_WB_READ_U8(0x240) >> 6) & 0x03)

#define GP_WB_GET_ADCIF_NBR_OF_SLOTS_IN_CYCLE_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_ADCIF_NBR_OF_SLOTS_IN_CYCLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x240, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_ADCIF_NBR_OF_SLOTS_IN_CYCLE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_A_CONFIG() \
        GP_WB_READ_U8(0x241)

#define GP_WB_WRITE_ADCIF_SLOT_A_CONFIG(val) \
      GP_WB_WRITE_U8(0x241, (val))

/* The adc channel for slot a */
#define GP_WB_READ_ADCIF_SLOT_A_CHANNEL() \
        (GP_WB_READ_U8(0x241) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_A_CHANNEL_FROM_SLOT_A_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_A_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x241, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_CHANNEL_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* post result of measurement to RSSI */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_RSSI() \
        GP_WB_READ_U1(0x241, 4)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_RSSI_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x241, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_RSSI_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(0x241, 5)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_BUFFER_A_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x241, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_BUFFER_A_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(0x241, 6)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_BUFFER_B_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x241, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_BUFFER_B_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_FIFO() \
        GP_WB_READ_U1(0x241, 7)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_FIFO_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x241, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_FIFO_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_B_CONFIG() \
        GP_WB_READ_U8(0x242)

#define GP_WB_WRITE_ADCIF_SLOT_B_CONFIG(val) \
      GP_WB_WRITE_U8(0x242, (val))

/* The adc channel for slot b */
#define GP_WB_READ_ADCIF_SLOT_B_CHANNEL() \
        (GP_WB_READ_U8(0x242) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_B_CHANNEL_FROM_SLOT_B_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_B_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x242, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_CHANNEL_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* post result of measurement to RSSI */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_RSSI() \
        GP_WB_READ_U1(0x242, 4)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_RSSI_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x242, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_RSSI_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(0x242, 5)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_BUFFER_A_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x242, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_BUFFER_A_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(0x242, 6)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_BUFFER_B_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x242, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_BUFFER_B_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_FIFO() \
        GP_WB_READ_U1(0x242, 7)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_FIFO_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x242, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_FIFO_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_C_CONFIG() \
        GP_WB_READ_U8(0x243)

#define GP_WB_WRITE_ADCIF_SLOT_C_CONFIG(val) \
      GP_WB_WRITE_U8(0x243, (val))

/* The adc channel for slot c */
#define GP_WB_READ_ADCIF_SLOT_C_CHANNEL() \
        (GP_WB_READ_U8(0x243) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_C_CHANNEL_FROM_SLOT_C_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_C_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x243, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_CHANNEL_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* post result of measurement to RSSI */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_RSSI() \
        GP_WB_READ_U1(0x243, 4)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_RSSI_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x243, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_RSSI_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(0x243, 5)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_BUFFER_A_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x243, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_BUFFER_A_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(0x243, 6)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_BUFFER_B_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x243, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_BUFFER_B_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_FIFO() \
        GP_WB_READ_U1(0x243, 7)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_FIFO_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x243, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_FIFO_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_D_CONFIG() \
        GP_WB_READ_U8(0x244)

#define GP_WB_WRITE_ADCIF_SLOT_D_CONFIG(val) \
      GP_WB_WRITE_U8(0x244, (val))

/* The adc channel for slot d */
#define GP_WB_READ_ADCIF_SLOT_D_CHANNEL() \
        (GP_WB_READ_U8(0x244) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_D_CHANNEL_FROM_SLOT_D_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_D_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x244, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_CHANNEL_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* post result of measurement to RSSI */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_RSSI() \
        GP_WB_READ_U1(0x244, 4)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_RSSI_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x244, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_RSSI_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(0x244, 5)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_BUFFER_A_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x244, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_BUFFER_A_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(0x244, 6)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_BUFFER_B_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x244, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_BUFFER_B_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_FIFO() \
        GP_WB_READ_U1(0x244, 7)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_FIFO_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x244, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_FIFO_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* This is the value that is used to preset buffer_a/b when preset_buffer_a/b is applied */
#define GP_WB_READ_ADCIF_BUFFER_PRESET_VALUE() \
        GP_WB_READ_U16(0x246)

#define GP_WB_WRITE_ADCIF_BUFFER_PRESET_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03FF); \
          GP_WB_WRITE_U16(0x246, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_MAILBOX_CONFIG() \
        GP_WB_READ_U16(0x248)

#define GP_WB_WRITE_ADCIF_MAILBOX_CONFIG(val) \
      GP_WB_WRITE_U16(0x248, (val))

/* Defines the rate at which samples are put into the fifo (every fifo_subsample_rate+1 'th sample is used) */
#define GP_WB_READ_ADCIF_FIFO_SUBSAMPLE_RATE() \
        (GP_WB_READ_U8(0x248) & 0x07)

#define GP_WB_GET_ADCIF_FIFO_SUBSAMPLE_RATE_FROM_MAILBOX_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_ADCIF_FIFO_SUBSAMPLE_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x248, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_FIFO_SUBSAMPLE_RATE_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x03F8; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Puts fifo in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of fifo */
#define GP_WB_READ_ADCIF_FIFO_MODE8BITS() \
        GP_WB_READ_U1(0x248, 3)

#define GP_WB_GET_ADCIF_FIFO_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADCIF_FIFO_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x248, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_FIFO_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Enables minimum hold mode of buffer a (lowest adc result is retained) */
#define GP_WB_READ_ADCIF_BUFFER_A_MIN_HOLD() \
        GP_WB_READ_U1(0x248, 4)

#define GP_WB_GET_ADCIF_BUFFER_A_MIN_HOLD_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_A_MIN_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x248, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_A_MIN_HOLD_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Enables maximum hold mode of buffer a (highest adc result is retained) */
#define GP_WB_READ_ADCIF_BUFFER_A_MAX_HOLD() \
        GP_WB_READ_U1(0x248, 5)

#define GP_WB_GET_ADCIF_BUFFER_A_MAX_HOLD_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_A_MAX_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x248, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_A_MAX_HOLD_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Puts buffer a in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_a */
#define GP_WB_READ_ADCIF_BUFFER_A_MODE8BITS() \
        GP_WB_READ_U1(0x248, 6)

#define GP_WB_GET_ADCIF_BUFFER_A_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_A_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x248, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_A_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Enables minimum hold mode of buffer b (lowest adc result is retained) */
#define GP_WB_READ_ADCIF_BUFFER_B_MIN_HOLD() \
        GP_WB_READ_U1(0x248, 7)

#define GP_WB_GET_ADCIF_BUFFER_B_MIN_HOLD_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_B_MIN_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x248, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_B_MIN_HOLD_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enables maximum hold mode of buffer b (highest adc result is retained) */
#define GP_WB_READ_ADCIF_BUFFER_B_MAX_HOLD() \
        GP_WB_READ_U1(0x249, 0)

#define GP_WB_GET_ADCIF_BUFFER_B_MAX_HOLD_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_B_MAX_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x249, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_B_MAX_HOLD_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Puts buffer b in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_a */
#define GP_WB_READ_ADCIF_BUFFER_B_MODE8BITS() \
        GP_WB_READ_U1(0x249, 1)

#define GP_WB_GET_ADCIF_BUFFER_B_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_B_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x249, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_B_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


#define GP_WB_WRITE_ADCIF_ACTION_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x24a, (val))

/* When set, buffer a will be preset with the value set by buffer_preset_value */
#define GP_WB_ADCIF_BUFFER_A_PRESET() \
        GP_WB_WRITE_U8(0x24a, 0x01)

#define GP_WB_SET_ADCIF_BUFFER_A_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, buffer b will be preset with the value set by buffer_preset_value */
#define GP_WB_ADCIF_BUFFER_B_PRESET() \
        GP_WB_WRITE_U8(0x24a, 0x02)

#define GP_WB_SET_ADCIF_BUFFER_B_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets the FIFO subsample counter */
#define GP_WB_ADCIF_CLR_FIFO_SUBSAMPLE_CNT() \
        GP_WB_WRITE_U8(0x24a, 0x04)

#define GP_WB_SET_ADCIF_CLR_FIFO_SUBSAMPLE_CNT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* buffer_a_updated interrupt clear */
#define GP_WB_ADCIF_CLR_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_WRITE_U8(0x24a, 0x08)

#define GP_WB_SET_ADCIF_CLR_BUFFER_A_UPDATED_INTERRUPT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* buffer_b_updated interrupt clear */
#define GP_WB_ADCIF_CLR_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_WRITE_U8(0x24a, 0x10)

#define GP_WB_SET_ADCIF_CLR_BUFFER_B_UPDATED_INTERRUPT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* fifo overrun interrupt clear */
#define GP_WB_ADCIF_CLR_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x24a, 0x20)

#define GP_WB_SET_ADCIF_CLR_FIFO_OVERRUN_INTERRUPT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* measurement cycle done interrupt clear */
#define GP_WB_ADCIF_CLR_CYCLE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(0x24a, 0x40)

#define GP_WB_SET_ADCIF_CLR_CYCLE_DONE_INTERRUPT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overvoltage interrupt clear */
#define GP_WB_ADCIF_CLR_OVERVOLTAGE_INTERRUPT() \
        GP_WB_WRITE_U8(0x24a, 0x80)

#define GP_WB_SET_ADCIF_CLR_OVERVOLTAGE_INTERRUPT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_FIFO_RESULT_PB() \
        GP_WB_READ_U16(0x24c)

/* LSB bits of the result FIFO (clear on read - clear is done when MSB bits are read) */
#define GP_WB_READ_ADCIF_FIFO_RESULT_0() \
        GP_WB_READ_U8(0x24c)

#define GP_WB_GET_ADCIF_FIFO_RESULT_0_FROM_FIFO_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result FIFO (clear on read - clear is done when MSB bits are read) */
#define GP_WB_READ_ADCIF_FIFO_RESULT() \
        (GP_WB_READ_U16(0x24c) & 0x03FF)

#define GP_WB_GET_ADCIF_FIFO_RESULT_FROM_FIFO_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT_PB() \
        GP_WB_READ_U16(0x24e)

/* LSB bits of the result buffer a */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT_0() \
        GP_WB_READ_U8(0x24e)

#define GP_WB_GET_ADCIF_BUFFER_A_RESULT_0_FROM_BUFFER_A_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result buffer a */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT() \
        (GP_WB_READ_U16(0x24e) & 0x03FF)

#define GP_WB_GET_ADCIF_BUFFER_A_RESULT_FROM_BUFFER_A_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT_PB() \
        GP_WB_READ_U16(0x250)

/* LSB bits of the result buffer b */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT_0() \
        GP_WB_READ_U8(0x250)

#define GP_WB_GET_ADCIF_BUFFER_B_RESULT_0_FROM_BUFFER_B_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result buffer b */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT() \
        (GP_WB_READ_U16(0x250) & 0x03FF)

#define GP_WB_GET_ADCIF_BUFFER_B_RESULT_FROM_BUFFER_B_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ADC_ANA_CONFIG() \
        GP_WB_READ_U16(0x252)

#define GP_WB_WRITE_ADCIF_ADC_ANA_CONFIG(val) \
      GP_WB_WRITE_U16(0x252, (val))

/* Trimming bits for the ADC LDO in- and output voltages */
#define GP_WB_READ_ADCIF_ADC_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(0x252) & 0x07), 3))

#define GP_WB_GET_ADCIF_ADC_LDO_REFBITS_FROM_ADC_ANA_CONFIG(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_ADCIF_ADC_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x252, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_REFBITS_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x7FF8; \
          (tmp) |= (((Int16)(val)) & 0x0007); \
        } while (0)

/* Enable signal for the ADC LDO */
#define GP_WB_READ_ADCIF_ADC_LDO_PUP() \
        GP_WB_READ_U1(0x252, 3)

#define GP_WB_GET_ADCIF_ADC_LDO_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x252, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Enable signal for the circuit generating the ADC LDO ready signal */
#define GP_WB_READ_ADCIF_ADC_LDO_RDY_PUP() \
        GP_WB_READ_U1(0x252, 4)

#define GP_WB_GET_ADCIF_ADC_LDO_RDY_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_LDO_RDY_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x252, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_RDY_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Enable signal for the ADC vddref buffer */
#define GP_WB_READ_ADCIF_ADC_VDDREF_BUF_PUP() \
        GP_WB_READ_U1(0x252, 5)

#define GP_WB_GET_ADCIF_ADC_VDDREF_BUF_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_VDDREF_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x252, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_VDDREF_BUF_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Enable signal for the ADC vcm buffer, 1.2V */
#define GP_WB_READ_ADCIF_ADC_VCM_BUF_PUP() \
        GP_WB_READ_U1(0x252, 6)

#define GP_WB_GET_ADCIF_ADC_VCM_BUF_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_VCM_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x252, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_VCM_BUF_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Enable signal for the ADC clocked comparator biasing */
#define GP_WB_READ_ADCIF_ADC_CLK_COMP_PUP() \
        GP_WB_READ_U1(0x252, 7)

#define GP_WB_GET_ADCIF_ADC_CLK_COMP_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_CLK_COMP_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x252, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_CLK_COMP_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable signal for the input buffer for ANIO signals */
#define GP_WB_READ_ADCIF_ADC_INPUT_BUF_PUP() \
        GP_WB_READ_U1(0x253, 0)

#define GP_WB_GET_ADCIF_ADC_INPUT_BUF_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_INPUT_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_INPUT_BUF_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Enable signal for the temperature sensor */
#define GP_WB_READ_ADCIF_ADC_TEMP_SENSOR_PUP() \
        GP_WB_READ_U1(0x253, 1)

#define GP_WB_GET_ADCIF_ADC_TEMP_SENSOR_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_TEMP_SENSOR_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_TEMP_SENSOR_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* Enable signal for the divider-by-three for ANIO signals */
#define GP_WB_READ_ADCIF_ADC_VOLT_DIV_ENA() \
        GP_WB_READ_U1(0x253, 2)

#define GP_WB_GET_ADCIF_ADC_VOLT_DIV_ENA_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_VOLT_DIV_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_VOLT_DIV_ENA_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Enable signal for the ADC clamp comparator */
#define GP_WB_READ_ADCIF_ADC_CLAMP_COMP_PUP() \
        GP_WB_READ_U1(0x253, 3)

#define GP_WB_GET_ADCIF_ADC_CLAMP_COMP_PUP_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_CLAMP_COMP_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_CLAMP_COMP_PUP_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* Enable signal for the ADC LDO low-power mode */
#define GP_WB_READ_ADCIF_ADC_LDO_LPMODE_ENA() \
        GP_WB_READ_U1(0x253, 4)

#define GP_WB_GET_ADCIF_ADC_LDO_LPMODE_ENA_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_LDO_LPMODE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_LPMODE_ENA_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Signal increasing the bias current in the ADC LDO output stage */
#define GP_WB_READ_ADCIF_ADC_LDO_BLEED_ENA() \
        GP_WB_READ_U1(0x253, 5)

#define GP_WB_GET_ADCIF_ADC_LDO_BLEED_ENA_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_LDO_BLEED_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_BLEED_ENA_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5FFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

/* Signal short-circuiting the resistance in the ADC LDO input filter */
#define GP_WB_READ_ADCIF_ADC_LDO_RESBYP_ENA() \
        GP_WB_READ_U1(0x253, 6)

#define GP_WB_GET_ADCIF_ADC_LDO_RESBYP_ENA_FROM_ADC_ANA_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_LDO_RESBYP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x253, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_LDO_RESBYP_ENA_TO_ADC_ANA_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* Debug bits, to be used if needed */
#define GP_WB_READ_ADCIF_ADC_DEBUG() \
        GP_WB_READ_U8(0x254)

#define GP_WB_WRITE_ADCIF_ADC_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x254, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ADC_ANA_OVERRULE() \
        GP_WB_READ_U8(0x255)

#define GP_WB_WRITE_ADCIF_ADC_ANA_OVERRULE(val) \
      GP_WB_WRITE_U8(0x255, (val))

/* This value is or-ed with the conv request generated by the digital adc circuitry. This allows for anabling the conv_request, even if the internal adc is not generating requests */
#define GP_WB_READ_ADCIF_ADC_CONV_REQUEST() \
        GP_WB_READ_U1(0x255, 0)

#define GP_WB_GET_ADCIF_ADC_CONV_REQUEST_FROM_ADC_ANA_OVERRULE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_CONV_REQUEST(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x255, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_CONV_REQUEST_TO_ADC_ANA_OVERRULE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* adc channel overrule enable */
#define GP_WB_READ_ADCIF_ADC_SEL_OVERRULE_ENA() \
        GP_WB_READ_U1(0x255, 1)

#define GP_WB_GET_ADCIF_ADC_SEL_OVERRULE_ENA_FROM_ADC_ANA_OVERRULE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SEL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x255, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SEL_OVERRULE_ENA_TO_ADC_ANA_OVERRULE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrules adc_sel (going to analog) when adc_sel_overrule_ena is set - if not set adc_sel is driven by design */
#define GP_WB_READ_ADCIF_ADC_SEL_OVERRULE() \
        ((GP_WB_READ_U8(0x255) >> 2) & 0x0F)

#define GP_WB_GET_ADCIF_ADC_SEL_OVERRULE_FROM_ADC_ANA_OVERRULE(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_ADCIF_ADC_SEL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x255, 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SEL_OVERRULE_TO_ADC_ANA_OVERRULE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_GENERAL_STATUS() \
        GP_WB_READ_U16(0x256)

/* Interrupt triggered when the value in buffer a updated */
#define GP_WB_READ_ADCIF_UNMASKED_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x256, 0)

#define GP_WB_GET_ADCIF_UNMASKED_BUFFER_A_UPDATED_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        ((tmp) & 0x01)

/* Interrupt triggered when the value in buffer b updated */
#define GP_WB_READ_ADCIF_UNMASKED_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x256, 1)

#define GP_WB_GET_ADCIF_UNMASKED_BUFFER_B_UPDATED_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Interrupts generated when there is data in the FIFO */
#define GP_WB_READ_ADCIF_UNMASKED_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x256, 2)

#define GP_WB_GET_ADCIF_UNMASKED_FIFO_NOT_EMPTY_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Interrupts generated when new data was available while FIFO was full */
#define GP_WB_READ_ADCIF_UNMASKED_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x256, 3)

#define GP_WB_GET_ADCIF_UNMASKED_FIFO_OVERRUN_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Interrupts generated when a complete measurement cycle finished */
#define GP_WB_READ_ADCIF_UNMASKED_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x256, 4)

#define GP_WB_GET_ADCIF_UNMASKED_CYCLE_DONE_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* interrupt indicating that the voltage at the ADC input was too high during a measurement */
#define GP_WB_READ_ADCIF_UNMASKED_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(0x256, 5)

#define GP_WB_GET_ADCIF_UNMASKED_OVERVOLTAGE_INTERRUPT_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Indicates that a conversion is ongoing */
#define GP_WB_READ_ADCIF_CONVERSION_CYCLE_BUSY() \
        GP_WB_READ_U1(0x256, 6)

#define GP_WB_GET_ADCIF_CONVERSION_CYCLE_BUSY_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* The slot index of the currently active slot */
#define GP_WB_READ_ADCIF_ACTIVE_SLOT_IDX() \
        (GP_WB_READ_U8(0x257) & 0x03)

#define GP_WB_GET_ADCIF_ACTIVE_SLOT_IDX_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 8) & 0x03)

/* The current value of the end of conversion counter */
#define GP_WB_READ_ADCIF_EOC_COUNTER_VALUE() \
        ((GP_WB_READ_U8(0x257) >> 2) & 0x0F)

#define GP_WB_GET_ADCIF_EOC_COUNTER_VALUE_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 10) & 0x0F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ANALOG_STATUS() \
        GP_WB_READ_U8(0x258)

/* Ready signal generated by ADC LDO - debug only */
#define GP_WB_READ_ADCIF_ADC_LDO_RDY() \
        GP_WB_READ_U1(0x258, 0)

#define GP_WB_GET_ADCIF_ADC_LDO_RDY_FROM_ANALOG_STATUS(tmp) \
        ((tmp) & 0x01)

/* Flag indicating that the voltage at the ADC input is too high */
#define GP_WB_READ_ADCIF_ADC_OVERVOLTAGE() \
        GP_WB_READ_U1(0x258, 1)

#define GP_WB_GET_ADCIF_ADC_OVERVOLTAGE_FROM_ANALOG_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/***************************
 * layout: ssp
 ***************************/

/* Authentication pointer */
#define GP_WB_READ_SSP_A_PTR() \
        GP_WB_READ_U24(0x260)

#define GP_WB_WRITE_SSP_A_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x260, (val)); \
        } while (0)


/* Authentication length */
#define GP_WB_READ_SSP_A_LEN() \
        GP_WB_READ_U8(0x263)

#define GP_WB_WRITE_SSP_A_LEN(val) do { \
          GP_WB_WRITE_U8(0x263, (val)); \
        } while (0)


/* Message in pointer */
#define GP_WB_READ_SSP_MSG_PTR() \
        GP_WB_READ_U24(0x264)

#define GP_WB_WRITE_SSP_MSG_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x264, (val)); \
        } while (0)


/* Message length */
#define GP_WB_READ_SSP_MSG_LEN() \
        GP_WB_READ_U8(0x267)

#define GP_WB_WRITE_SSP_MSG_LEN(val) do { \
          GP_WB_WRITE_U8(0x267, (val)); \
        } while (0)


/* Mic pointer */
#define GP_WB_READ_SSP_MIC_PTR() \
        GP_WB_READ_U24(0x268)

#define GP_WB_WRITE_SSP_MIC_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x268, (val)); \
        } while (0)


/* key pointer - for access to secured keys, key pointer has to be a multiple of 16 bytes */
#define GP_WB_READ_SSP_KEY_PTR() \
        GP_WB_READ_U24(0x26c)

#define GP_WB_WRITE_SSP_KEY_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x26c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_KEY_MIC_LEN() \
        GP_WB_READ_U8(0x26f)

#define GP_WB_WRITE_SSP_KEY_MIC_LEN(val) \
      GP_WB_WRITE_U8(0x26f, (val))

/* key length enumerate : "00" = 128 bit key, "01" = 192 bit key, "10" = 256 bit key */
#define GP_WB_READ_SSP_KEY_LEN() \
        (GP_WB_READ_U8(0x26f) & 0x03)

#define GP_WB_GET_SSP_KEY_LEN_FROM_KEY_MIC_LEN(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_SSP_KEY_LEN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x26f, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SSP_KEY_LEN_TO_KEY_MIC_LEN(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mic length/2 (actual length is the value set by this property multiplied by 2) */
#define GP_WB_READ_SSP_MIC_LEN() \
        ((GP_WB_READ_U8(0x26f) >> 2) & 0x0F)

#define GP_WB_GET_SSP_MIC_LEN_FROM_KEY_MIC_LEN(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_SSP_MIC_LEN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x26f, 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_SSP_MIC_LEN_TO_KEY_MIC_LEN(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Pointer to destination loaction for encrypted data */
#define GP_WB_READ_SSP_MSG_OUT_PTR() \
        GP_WB_READ_U24(0x270)

#define GP_WB_WRITE_SSP_MSG_OUT_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x270, (val)); \
        } while (0)


/* Pointer to destination loaction for encrypted data */
#define GP_WB_READ_SSP_NONCE_PTR() \
        GP_WB_READ_U24(0x274)

#define GP_WB_WRITE_SSP_NONCE_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x274, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_MODE_AND_INT_CONTROL() \
        GP_WB_READ_U8(0x277)

#define GP_WB_WRITE_SSP_MODE_AND_INT_CONTROL(val) \
      GP_WB_WRITE_U8(0x277, (val))

/* "00" = Encryption, "01" = decryption, "10" = aes mode, "11" = reserved */
#define GP_WB_READ_SSP_MODE() \
        (GP_WB_READ_U8(0x277) & 0x03)

#define GP_WB_GET_SSP_MODE_FROM_MODE_AND_INT_CONTROL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_SSP_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x277, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SSP_MODE_TO_MODE_AND_INT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x04; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* uses internal secret key  when '1' */
#define GP_WB_READ_SSP_USE_SKEY() \
        GP_WB_READ_U1(0x277, 2)

#define GP_WB_GET_SSP_USE_SKEY_FROM_MODE_AND_INT_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SSP_USE_SKEY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x277, 2, (val)); \
        } while (0)

#define GP_WB_SET_SSP_USE_SKEY_TO_MODE_AND_INT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


#define GP_WB_WRITE_SSP_ENCRYPTION_CONTROL(val) \
      GP_WB_WRITE_U8(0x278, (val))

/* Starts an encryption cycle */
#define GP_WB_SSP_START_ENCRYPT() \
        GP_WB_WRITE_U8(0x278, 0x01)

#define GP_WB_SET_SSP_START_ENCRYPT_TO_ENCRYPTION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt clear */
#define GP_WB_SSP_CLR_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(0x278, 0x02)

#define GP_WB_SET_SSP_CLR_DONE_INTERRUPT_TO_ENCRYPTION_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_ENCRYPTION_STATUS() \
        GP_WB_READ_U8(0x279)

/* Indicates the encryption cycle is running */
#define GP_WB_READ_SSP_BUSY() \
        GP_WB_READ_U1(0x279, 0)

#define GP_WB_GET_SSP_BUSY_FROM_ENCRYPTION_STATUS(tmp) \
        ((tmp) & 0x01)

/* Set when an error occurred while accessing the memory */
#define GP_WB_READ_SSP_MEM_ERR() \
        GP_WB_READ_U1(0x279, 1)

#define GP_WB_GET_SSP_MEM_ERR_FROM_ENCRYPTION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked interrupt indicating encryption cycle finished */
#define GP_WB_READ_SSP_DONE_UNMASKED_INTERRUPT() \
        GP_WB_READ_U1(0x279, 2)

#define GP_WB_GET_SSP_DONE_UNMASKED_INTERRUPT_FROM_ENCRYPTION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/***************************
 * layout: uart
 ***************************/

#define GP_WB_WRITE_UART_TX_DATA(val) \
      GP_WB_WRITE_U16(0x280, (val))

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_TX_DATA_0(val) do { \
          GP_WB_WRITE_U8(0x280, (val)); \
        } while (0)

#define GP_WB_SET_UART_TX_DATA_0_TO_TX_DATA(tmp, val) do { \
          (tmp) &= 0x0100; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* TX data FIFO MSB. In case of 9 data bits, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_TX_DATA_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x281, (val)); \
        } while (0)

#define GP_WB_SET_UART_TX_DATA_1_TO_TX_DATA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_RX_DATA() \
        GP_WB_READ_U16(0x282)

/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_RX_DATA_0() \
        GP_WB_READ_U8(0x282)

#define GP_WB_GET_UART_RX_DATA_0_FROM_RX_DATA(tmp) \
        ((tmp) & 0xFF)

/* RX data FIFO MSB. In case of 9 data bits, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_RX_DATA_1() \
        GP_WB_READ_U1(0x283, 0)

#define GP_WB_GET_UART_RX_DATA_1_FROM_RX_DATA(tmp) \
        (((tmp) >> 8) & 0x01)


/* Actual baud rate = 16MHz / 8*(baud_rate+1) */
#define GP_WB_READ_UART_BAUD_RATE() \
        GP_WB_READ_U16(0x284)

#define GP_WB_WRITE_UART_BAUD_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0FFF); \
          GP_WB_WRITE_U16(0x284, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_CONFIG() \
        GP_WB_READ_U16(0x286)

#define GP_WB_WRITE_UART_CONFIG(val) \
      GP_WB_WRITE_U16(0x286, (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_UART_DATA_BITS() \
        (GP_WB_READ_U8(0x286) & 0x0F)

#define GP_WB_GET_UART_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_UART_DATA_BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x286, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_UART_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x03F0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Parity bit mode. Controls both the generation for TX and the check for RX. */
#define GP_WB_READ_UART_PARITY() \
        ((GP_WB_READ_U8(0x286) >> 4) & 0x03)

#define GP_WB_GET_UART_PARITY_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_UART_PARITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x286, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_UART_PARITY_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03CF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked) */
#define GP_WB_READ_UART_STOP_BITS() \
        GP_WB_READ_U1(0x286, 6)

#define GP_WB_GET_UART_STOP_BITS_FROM_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_UART_STOP_BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x286, 6, (val)); \
        } while (0)

#define GP_WB_SET_UART_STOP_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic. */
#define GP_WB_READ_UART_USE_SYNC_BIT() \
        GP_WB_READ_U1(0x286, 7)

#define GP_WB_GET_UART_USE_SYNC_BIT_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_UART_USE_SYNC_BIT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x286, 7, (val)); \
        } while (0)

#define GP_WB_SET_UART_USE_SYNC_BIT_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data) */
#define GP_WB_READ_UART_RX_ENABLE() \
        GP_WB_READ_U1(0x287, 0)

#define GP_WB_GET_UART_RX_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_UART_RX_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x287, 0, (val)); \
        } while (0)

#define GP_WB_SET_UART_RX_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime. */
#define GP_WB_READ_UART_BIT_REVERSE_REPLY() \
        GP_WB_READ_U1(0x287, 1)

#define GP_WB_GET_UART_BIT_REVERSE_REPLY_FROM_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_UART_BIT_REVERSE_REPLY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x287, 1, (val)); \
        } while (0)

#define GP_WB_SET_UART_BIT_REVERSE_REPLY_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_PIN_CONFIG() \
        GP_WB_READ_U8(0x288)

#define GP_WB_WRITE_UART_PIN_CONFIG(val) \
      GP_WB_WRITE_U8(0x288, (val))

/* Pin mapping for the RX signal - only mappings a, b, c and d in use */
#define GP_WB_READ_UART_RX_MAP() \
        (GP_WB_READ_U8(0x288) & 0x07)

#define GP_WB_GET_UART_RX_MAP_FROM_PIN_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_UART_RX_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x288, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_UART_RX_MAP_TO_PIN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Pin mapping for the TX signal - only mappings a, b, c and d in use */
#define GP_WB_READ_UART_TX_MAP() \
        ((GP_WB_READ_U8(0x288) >> 3) & 0x07)

#define GP_WB_GET_UART_TX_MAP_FROM_PIN_CONFIG(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_UART_TX_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x288, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_UART_TX_MAP_TO_PIN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_STATUS() \
        GP_WB_READ_U8(0x289)

/* Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_UART_UNMASKED_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x289, 0)

#define GP_WB_GET_UART_UNMASKED_TX_NOT_BUSY_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_UART_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x289, 1)

#define GP_WB_GET_UART_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_UART_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x289, 2)

#define GP_WB_GET_UART_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x289, 3)

#define GP_WB_GET_UART_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x289, 4)

#define GP_WB_GET_UART_UNMASKED_RX_PARITY_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x289, 5)

#define GP_WB_GET_UART_UNMASKED_RX_FRAMING_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status flag for UART RX not busy. Active when no RX transfer is ongoing. */
#define GP_WB_READ_UART_RX_NOT_BUSY() \
        GP_WB_READ_U1(0x289, 6)

#define GP_WB_GET_UART_RX_NOT_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)


#define GP_WB_WRITE_UART_CLEAR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(0x28a, (val))

/* Clear the rx_overrun_interrupt. */
#define GP_WB_UART_CLEAR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x28a, 0x01)

#define GP_WB_SET_UART_CLEAR_RX_OVERRUN_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the rx_parity_error_interrupt. */
#define GP_WB_UART_CLEAR_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(0x28a, 0x02)

#define GP_WB_SET_UART_CLEAR_RX_PARITY_ERROR_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the rx_framining_error_interrupt. */
#define GP_WB_UART_CLEAR_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(0x28a, 0x04)

#define GP_WB_SET_UART_CLEAR_RX_FRAMING_ERROR_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: spi_m
 ***************************/

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_SPI_M_TX_DATA_0(val) do { \
          GP_WB_WRITE_U8(0x2a0, (val)); \
        } while (0)


/* TX data FIFO MSB. In case of 9 data bits or more, transmission in triggered by writing this. */
#define GP_WB_WRITE_SPI_M_TX_DATA_1(val) do { \
          GP_WB_WRITE_U8(0x2a1, (val)); \
        } while (0)


/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_SPI_M_RX_DATA_0() \
        GP_WB_READ_U8(0x2a2)


/* RX data FIFO MSB. In case of 9 data bits or more, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_SPI_M_RX_DATA_1() \
        GP_WB_READ_U8(0x2a3)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_CONFIG() \
        GP_WB_READ_U16(0x2a4)

#define GP_WB_WRITE_SPI_M_CONFIG(val) \
      GP_WB_WRITE_U16(0x2a4, (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_SPI_M_DATA_BITS() \
        (GP_WB_READ_U8(0x2a4) & 0x0F)

#define GP_WB_GET_SPI_M_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_SPI_M_DATA_BITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x2a4, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x07F0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* SCLK clock frequency: 8MHz / 2**sclk_freq */
#define GP_WB_READ_SPI_M_SCLK_FREQ() \
        ((GP_WB_READ_U8(0x2a4) >> 4) & 0x07)

#define GP_WB_GET_SPI_M_SCLK_FREQ_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_SPI_M_SCLK_FREQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2a4, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_SPI_M_SCLK_FREQ_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x078F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Master SPI data order. */
#define GP_WB_READ_SPI_M_LSB_FIRST() \
        GP_WB_READ_U1(0x2a4, 7)

#define GP_WB_GET_SPI_M_LSB_FIRST_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SPI_M_LSB_FIRST(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2a4, 7, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_LSB_FIRST_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Master SPI mode */
#define GP_WB_READ_SPI_M_MODE() \
        (GP_WB_READ_U8(0x2a5) & 0x03)

#define GP_WB_GET_SPI_M_MODE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_SPI_M_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x2a5, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_MODE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x04FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Free running mode, spi transfers are back-to-back triggered, even when no new tx_data is provided. Can be used for capturing PDM outputs. */
#define GP_WB_READ_SPI_M_FREE_RUNNING() \
        GP_WB_READ_U1(0x2a5, 2)

#define GP_WB_GET_SPI_M_FREE_RUNNING_FROM_CONFIG(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_SPI_M_FREE_RUNNING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2a5, 2, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_FREE_RUNNING_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_PIN_CONFIG_A() \
        GP_WB_READ_U8(0x2a6)

#define GP_WB_WRITE_SPI_M_PIN_CONFIG_A(val) \
      GP_WB_WRITE_U8(0x2a6, (val))

/* Pin mapping for the miso signal (only mappings a, b, c, and d are valid). */
#define GP_WB_READ_SPI_M_MISO_MAP() \
        (GP_WB_READ_U8(0x2a6) & 0x07)

#define GP_WB_GET_SPI_M_MISO_MAP_FROM_PIN_CONFIG_A(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_SPI_M_MISO_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2a6, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_MISO_MAP_TO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Pin mapping for the ssn signal  (only mappings a, b, c, and d are valid). */
#define GP_WB_READ_SPI_M_SS_MAP() \
        ((GP_WB_READ_U8(0x2a6) >> 3) & 0x07)

#define GP_WB_GET_SPI_M_SS_MAP_FROM_PIN_CONFIG_A(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_SPI_M_SS_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2a6, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_SPI_M_SS_MAP_TO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_PIN_CONFIG_B() \
        GP_WB_READ_U8(0x2a7)

#define GP_WB_WRITE_SPI_M_PIN_CONFIG_B(val) \
      GP_WB_WRITE_U8(0x2a7, (val))

/* Pin mapping for the sck signal (only mappings a, b, c, and d are valid) */
#define GP_WB_READ_SPI_M_SCK_MAP() \
        (GP_WB_READ_U8(0x2a7) & 0x07)

#define GP_WB_GET_SPI_M_SCK_MAP_FROM_PIN_CONFIG_B(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_SPI_M_SCK_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2a7, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_SCK_MAP_TO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Pin mapping for the mosi signal (only mappings a, b, c, and d are valid) */
#define GP_WB_READ_SPI_M_MOSI_MAP() \
        ((GP_WB_READ_U8(0x2a7) >> 3) & 0x07)

#define GP_WB_GET_SPI_M_MOSI_MAP_FROM_PIN_CONFIG_B(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_SPI_M_MOSI_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2a7, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_SPI_M_MOSI_MAP_TO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(0x2a8)

/* Status and unmasked interrupt flag for transfer not busy. The interrupt is cleared implicitly when writing new TX data. Active when no transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x2a8, 0)

#define GP_WB_GET_SPI_M_UNMASKED_NOT_BUSY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x2a8, 1)

#define GP_WB_GET_SPI_M_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x2a8, 2)

#define GP_WB_GET_SPI_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_M_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x2a8, 3)

#define GP_WB_GET_SPI_M_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* Clear the rx_overrun_interrupt. */
#define GP_WB_SPI_M_CLEAR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x2a9, 0x01)

/***************************
 * layout: keypad_scan
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_CONFIG() \
        GP_WB_READ_U8(0x2c0)

#define GP_WB_WRITE_KEYPAD_SCAN_KEYPAD_CONFIG(val) \
      GP_WB_WRITE_U8(0x2c0, (val))

/* Keypad scan enabled */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_ENABLE() \
        GP_WB_READ_U1(0x2c0, 0)

#define GP_WB_GET_KEYPAD_SCAN_KEYPAD_ENABLE_FROM_KEYPAD_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_KEYPAD_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 0, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_KEYPAD_ENABLE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When '1' the scan outputs are driven to 0 during active to allow new keypad press to be detected */
#define GP_WB_READ_KEYPAD_SCAN_SENSITIVE_DURING_ACTIVE() \
        GP_WB_READ_U1(0x2c0, 1)

#define GP_WB_GET_KEYPAD_SCAN_SENSITIVE_DURING_ACTIVE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_SENSITIVE_DURING_ACTIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 1, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_SENSITIVE_DURING_ACTIVE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When '1', the scan outputs are driven to 0 after the real measurement (debug) */
#define GP_WB_READ_KEYPAD_SCAN_PROLONGED_ROW_DRIVE() \
        GP_WB_READ_U1(0x2c0, 2)

#define GP_WB_GET_KEYPAD_SCAN_PROLONGED_ROW_DRIVE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_PROLONGED_ROW_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 2, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_PROLONGED_ROW_DRIVE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When '1' the scan inputs (0 to 3) and outputs (0) use the alternative pin mapping */
#define GP_WB_READ_KEYPAD_SCAN_KEYP_SELECT_ALTERNATIVE_PIN_MAP() \
        GP_WB_READ_U1(0x2c0, 3)

#define GP_WB_GET_KEYPAD_SCAN_KEYP_SELECT_ALTERNATIVE_PIN_MAP_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_KEYP_SELECT_ALTERNATIVE_PIN_MAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 3, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_KEYP_SELECT_ALTERNATIVE_PIN_MAP_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Spreads output changes over time to reduce sso effects */
#define GP_WB_READ_KEYPAD_SCAN_SSO_SPREAD_ENABLE() \
        GP_WB_READ_U1(0x2c0, 4)

#define GP_WB_GET_KEYPAD_SCAN_SSO_SPREAD_ENABLE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_SSO_SPREAD_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 4, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_SSO_SPREAD_ENABLE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Enables clock gating (to be enabled when changing sensitive_during_active setting) */
#define GP_WB_READ_KEYPAD_SCAN_ENABLE_CLK_KEYPAD_BY_UC() \
        GP_WB_READ_U1(0x2c0, 5)

#define GP_WB_GET_KEYPAD_SCAN_ENABLE_CLK_KEYPAD_BY_UC_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_ENABLE_CLK_KEYPAD_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2c0, 5, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_ENABLE_CLK_KEYPAD_BY_UC_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Enable bit map for matrix scan lines (rows) */
#define GP_WB_READ_KEYPAD_SCAN_MATRIX_SCANS() \
        GP_WB_READ_U8(0x2c1)

#define GP_WB_WRITE_KEYPAD_SCAN_MATRIX_SCANS(val) do { \
          GP_WB_WRITE_U8(0x2c1, (val)); \
        } while (0)


/* Enable bit map matrix sense lines (columns) */
#define GP_WB_READ_KEYPAD_SCAN_MATRIX_SENSES() \
        GP_WB_READ_U8(0x2c2)

#define GP_WB_WRITE_KEYPAD_SCAN_MATRIX_SENSES(val) do { \
          GP_WB_WRITE_U8(0x2c2, (val)); \
        } while (0)


/* Active columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled */
#define GP_WB_READ_KEYPAD_SCAN_ACTIVE_COLUMNS_CHARGE_PERIOD() \
        GP_WB_READ_U8(0x2c3)

#define GP_WB_WRITE_KEYPAD_SCAN_ACTIVE_COLUMNS_CHARGE_PERIOD(val) do { \
          GP_WB_WRITE_U8(0x2c3, (val)); \
        } while (0)


/* Passive columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled */
#define GP_WB_READ_KEYPAD_SCAN_PASSIVE_COLUMNS_CHARGE_PERIOD() \
        GP_WB_READ_U8(0x2c4)

#define GP_WB_WRITE_KEYPAD_SCAN_PASSIVE_COLUMNS_CHARGE_PERIOD(val) do { \
          GP_WB_WRITE_U8(0x2c4, (val)); \
        } while (0)


/* Time that scan outputs are driven to 0 before measurement is done:0=250ns 1=500ns, 2=750ns, ..., FF = 63750ns */
#define GP_WB_READ_KEYPAD_SCAN_ROW_DRIVE_PERIOD() \
        GP_WB_READ_U8(0x2c5)

#define GP_WB_WRITE_KEYPAD_SCAN_ROW_DRIVE_PERIOD(val) do { \
          GP_WB_WRITE_U8(0x2c5, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_STATE() \
        GP_WB_READ_U8(0x2c6)

/* Indicates if a keypad scan is busy */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SCAN_BUSY() \
        GP_WB_READ_U1(0x2c6, 0)

#define GP_WB_GET_KEYPAD_SCAN_KEYPAD_SCAN_BUSY_FROM_KEYPAD_STATE(tmp) \
        ((tmp) & 0x01)

/* Indicates the state of a ongoing keypad scan */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SCAN_STATE() \
        ((GP_WB_READ_U8(0x2c6) >> 1) & 0x07)

#define GP_WB_GET_KEYPAD_SCAN_KEYPAD_SCAN_STATE_FROM_KEYPAD_STATE(tmp) \
        (((tmp) >> 1) & 0x07)

/* Indicates the row counter of a ongoing keypad scan */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SCAN_COUNTER() \
        ((GP_WB_READ_U8(0x2c6) >> 4) & 0x07)

#define GP_WB_GET_KEYPAD_SCAN_KEYPAD_SCAN_COUNTER_FROM_KEYPAD_STATE(tmp) \
        (((tmp) >> 4) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_STATUS() \
        GP_WB_READ_U8(0x2c7)

/* Results updated indication: this bit is set to 0x1 when one of the scan results is updated, cleared by writing 0x1 to clear_results_updated */
#define GP_WB_READ_KEYPAD_SCAN_RESULTS_UPDATED() \
        GP_WB_READ_U1(0x2c7, 0)

#define GP_WB_GET_KEYPAD_SCAN_RESULTS_UPDATED_FROM_KEYPAD_STATUS(tmp) \
        ((tmp) & 0x01)

/* Results changed indication: this bit is set to 0x1 when one of the scan results is updated and was different from previous value, cleared by writing 0x1 to clear_results_changed */
#define GP_WB_READ_KEYPAD_SCAN_RESULTS_CHANGED() \
        GP_WB_READ_U1(0x2c7, 1)

#define GP_WB_GET_KEYPAD_SCAN_RESULTS_CHANGED_FROM_KEYPAD_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Results valid indication: this bit is set to 0x1 when all of the keypad scan's inputs are connected to the device's input pads. Cleared by writing 0x1 to clear_results_valid */
#define GP_WB_READ_KEYPAD_SCAN_RESULTS_VALID() \
        GP_WB_READ_U1(0x2c7, 2)

#define GP_WB_GET_KEYPAD_SCAN_RESULTS_VALID_FROM_KEYPAD_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Read back of keypad scan output value */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SCANS() \
        GP_WB_READ_U8(0x2c8)


/* Read back of keypad senses active charge output value */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SENSES_ACTIVE_CHARGE() \
        GP_WB_READ_U8(0x2c9)


/* Read back of keypad senses input value */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_SENSES() \
        GP_WB_READ_U8(0x2ca)


#define GP_WB_WRITE_KEYPAD_SCAN_KEYPAD_CONTROL(val) \
      GP_WB_WRITE_U8(0x2cb, (val))

/* Clears results updated */
#define GP_WB_KEYPAD_SCAN_CLEAR_RESULTS_UPDATED() \
        GP_WB_WRITE_U8(0x2cb, 0x01)

#define GP_WB_SET_KEYPAD_SCAN_CLEAR_RESULTS_UPDATED_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clears results changed */
#define GP_WB_KEYPAD_SCAN_CLEAR_RESULTS_CHANGED() \
        GP_WB_WRITE_U8(0x2cb, 0x02)

#define GP_WB_SET_KEYPAD_SCAN_CLEAR_RESULTS_CHANGED_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clears results valid */
#define GP_WB_KEYPAD_SCAN_CLEAR_RESULTS_VALID() \
        GP_WB_WRITE_U8(0x2cb, 0x04)

#define GP_WB_SET_KEYPAD_SCAN_CLEAR_RESULTS_VALID_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Counts the number of consecutive times the same result was detected, cleared by writing 0x0 */
#define GP_WB_READ_KEYPAD_SCAN_RESULTS_STABLE_COUNTER() \
        GP_WB_READ_U8(0x2cc)

#define GP_WB_WRITE_KEYPAD_SCAN_RESULTS_STABLE_COUNTER(val) do { \
          GP_WB_WRITE_U8(0x2cc, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_RESULT_SUMMARY() \
        GP_WB_READ_U8(0x2cd)

#define GP_WB_WRITE_KEYPAD_SCAN_KEYPAD_RESULT_SUMMARY(val) \
      GP_WB_WRITE_U8(0x2cd, (val))

/* Number of keys detected, 0=no key, 1=single key, 2=two keys, 3= more than 2 keys. */
#define GP_WB_READ_KEYPAD_SCAN_NUMBER_OF_KEYS() \
        (GP_WB_READ_U8(0x2cd) & 0x03)

#define GP_WB_GET_KEYPAD_SCAN_NUMBER_OF_KEYS_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_KEYPAD_SCAN_NUMBER_OF_KEYS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x2cd, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_NUMBER_OF_KEYS_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Single key scan (row) number (0...7). */
#define GP_WB_READ_KEYPAD_SCAN_SINGLE_KEY_SCAN() \
        ((GP_WB_READ_U8(0x2cd) >> 2) & 0x07)

#define GP_WB_GET_KEYPAD_SCAN_SINGLE_KEY_SCAN_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        (((tmp) >> 2) & 0x07)

#define GP_WB_WRITE_KEYPAD_SCAN_SINGLE_KEY_SCAN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2cd, 0x1C, (val) << 2); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_SINGLE_KEY_SCAN_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xE3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Single key sense (column) number (0...7). */
#define GP_WB_READ_KEYPAD_SCAN_SINGLE_KEY_SENSE() \
        ((GP_WB_READ_U8(0x2cd) >> 5) & 0x07)

#define GP_WB_GET_KEYPAD_SCAN_SINGLE_KEY_SENSE_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_WRITE_KEYPAD_SCAN_SINGLE_KEY_SENSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2cd, 0xE0, (val) << 5); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_SINGLE_KEY_SENSE_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Key sense vector 0. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_0() \
        GP_WB_READ_U8(0x2ce)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_0(val) do { \
          GP_WB_WRITE_U8(0x2ce, (val)); \
        } while (0)


/* Key sense vector 1. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_1() \
        GP_WB_READ_U8(0x2cf)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_1(val) do { \
          GP_WB_WRITE_U8(0x2cf, (val)); \
        } while (0)


/* Key sense vector 2. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_2() \
        GP_WB_READ_U8(0x2d0)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_2(val) do { \
          GP_WB_WRITE_U8(0x2d0, (val)); \
        } while (0)


/* Key sense vector 3. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_3() \
        GP_WB_READ_U8(0x2d1)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_3(val) do { \
          GP_WB_WRITE_U8(0x2d1, (val)); \
        } while (0)


/* Key sense vector 4. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_4() \
        GP_WB_READ_U8(0x2d2)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_4(val) do { \
          GP_WB_WRITE_U8(0x2d2, (val)); \
        } while (0)


/* Key sense vector 5. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_5() \
        GP_WB_READ_U8(0x2d3)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_5(val) do { \
          GP_WB_WRITE_U8(0x2d3, (val)); \
        } while (0)


/* Key sense vector 6. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_6() \
        GP_WB_READ_U8(0x2d4)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_6(val) do { \
          GP_WB_WRITE_U8(0x2d4, (val)); \
        } while (0)


/* Key sense vector 7. */
#define GP_WB_READ_KEYPAD_SCAN_KEY_VECTOR_7() \
        GP_WB_READ_U8(0x2d5)

#define GP_WB_WRITE_KEYPAD_SCAN_KEY_VECTOR_7(val) do { \
          GP_WB_WRITE_U8(0x2d5, (val)); \
        } while (0)


/* Unmasked interrupt event status,  Active when 0x1 */
#define GP_WB_READ_KEYPAD_SCAN_UNMASKED_KEYPAD_INTERRUPT() \
        GP_WB_READ_U1(0x2d6, 0)


/* Interrupt event clear by writing 0x1 */
#define GP_WB_KEYPAD_SCAN_CLEAR_KEYPAD_INTERRUPT() \
        GP_WB_WRITE_U8(0x2d7, 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_SCAN_KEYPAD_RETENTION() \
        GP_WB_READ_U8(0x2d8)

#define GP_WB_WRITE_KEYPAD_SCAN_KEYPAD_RETENTION(val) \
      GP_WB_WRITE_U8(0x2d8, (val))

/* Retention unmasked keypad interrupt */
#define GP_WB_READ_KEYPAD_SCAN_RETENTION_UNMASKED_KEYPAD_INTERRUPT() \
        GP_WB_READ_U1(0x2d8, 0)

#define GP_WB_GET_KEYPAD_SCAN_RETENTION_UNMASKED_KEYPAD_INTERRUPT_FROM_KEYPAD_RETENTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_RETENTION_UNMASKED_KEYPAD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2d8, 0, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_RETENTION_UNMASKED_KEYPAD_INTERRUPT_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Retention results updated */
#define GP_WB_READ_KEYPAD_SCAN_RETENTION_RESULTS_UPDATED() \
        GP_WB_READ_U1(0x2d8, 1)

#define GP_WB_GET_KEYPAD_SCAN_RETENTION_RESULTS_UPDATED_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_RETENTION_RESULTS_UPDATED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2d8, 1, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_RETENTION_RESULTS_UPDATED_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Retention results changed */
#define GP_WB_READ_KEYPAD_SCAN_RETENTION_RESULTS_CHANGED() \
        GP_WB_READ_U1(0x2d8, 2)

#define GP_WB_GET_KEYPAD_SCAN_RETENTION_RESULTS_CHANGED_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_RETENTION_RESULTS_CHANGED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2d8, 2, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_RETENTION_RESULTS_CHANGED_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Retention results valid */
#define GP_WB_READ_KEYPAD_SCAN_RETENTION_RESULTS_VALID() \
        GP_WB_READ_U1(0x2d8, 3)

#define GP_WB_GET_KEYPAD_SCAN_RETENTION_RESULTS_VALID_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_KEYPAD_SCAN_RETENTION_RESULTS_VALID(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2d8, 3, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SCAN_RETENTION_RESULTS_VALID_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/***************************
 * layout: ir
 ***************************/

/* Sets the divide factor for the prescaler. The prescaled frequecy is 16MHz/(2**prescale_div). */
#define GP_WB_READ_IR_PRESCALE_DIV() \
        GP_WB_READ_U8(0x2e0)

#define GP_WB_WRITE_IR_PRESCALE_DIV(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x2e0, (val)); \
        } while (0)


/* Sets the 'on' time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals '0'. */
#define GP_WB_READ_IR_THRESHOLD() \
        GP_WB_READ_U8(0x2e1)

#define GP_WB_WRITE_IR_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(0x2e1, (val)); \
        } while (0)


/* Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals '0'. */
#define GP_WB_READ_IR_WRAP() \
        GP_WB_READ_U8(0x2e2)

#define GP_WB_WRITE_IR_WRAP(val) do { \
          GP_WB_WRITE_U8(0x2e2, (val)); \
        } while (0)


/* Sets the 'on' time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals '1'. */
#define GP_WB_READ_IR_ALT_THRESHOLD() \
        GP_WB_READ_U8(0x2e3)

#define GP_WB_WRITE_IR_ALT_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(0x2e3, (val)); \
        } while (0)


/* Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals '1'. */
#define GP_WB_READ_IR_ALT_WRAP() \
        GP_WB_READ_U8(0x2e4)

#define GP_WB_WRITE_IR_ALT_WRAP(val) do { \
          GP_WB_WRITE_U8(0x2e4, (val)); \
        } while (0)


/* Sets the carrier Tu in number of carrier rising edges. Is used when ir  driver is in pattern mode */
#define GP_WB_READ_IR_CARRIER_TU() \
        GP_WB_READ_U8(0x2e5)

#define GP_WB_WRITE_IR_CARRIER_TU(val) do { \
          GP_WB_WRITE_U8(0x2e5, (val)); \
        } while (0)


/* Sets the time unit for the time based ram sequence mode. The time unit can be 500ns, 1us(=default), 2us or 4 us */
#define GP_WB_READ_IR_TIMER_TU() \
        GP_WB_READ_U8(0x2e6)

#define GP_WB_WRITE_IR_TIMER_TU(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x2e6, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_CONTROL_0() \
        GP_WB_READ_U8(0x2e7)

#define GP_WB_WRITE_IR_MODULATION_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x2e7, (val))

/* Selects what source will be used for envelope modulation. Can be from registermap, from external pin, from  event scheduler or from ram sequence */
#define GP_WB_READ_IR_MODULATION_MODE() \
        (GP_WB_READ_U8(0x2e7) & 0x07)

#define GP_WB_GET_IR_MODULATION_MODE_FROM_MODULATION_CONTROL_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_IR_MODULATION_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2e7, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_MODE_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', the carrier only starts running when the modulation is on. So the carrier is always aligned with the modulation start */
#define GP_WB_READ_IR_ALIGN_ON_START() \
        GP_WB_READ_U1(0x2e7, 3)

#define GP_WB_GET_IR_ALIGN_ON_START_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IR_ALIGN_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e7, 3, (val)); \
        } while (0)

#define GP_WB_SET_IR_ALIGN_ON_START_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set to '1', the value of the modulation (or envelope) is sampled when the carrier period starts. In this way it can be guaranteed that carrier period is not interrupted (so no glitches) */
#define GP_WB_READ_IR_MODULATION_LATCH_ON_START() \
        GP_WB_READ_U1(0x2e7, 4)

#define GP_WB_GET_IR_MODULATION_LATCH_ON_START_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IR_MODULATION_LATCH_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e7, 4, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_LATCH_ON_START_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* direct control of the modulation in the case the register_based modulation mode is chosen */
#define GP_WB_READ_IR_MODULATION() \
        GP_WB_READ_U1(0x2e7, 5)

#define GP_WB_GET_IR_MODULATION_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IR_MODULATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e7, 5, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set to '1', the ram sequence will be repeated when it is finished (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_REPEAT_SEQUENCE() \
        GP_WB_READ_U1(0x2e7, 6)

#define GP_WB_GET_IR_REPEAT_SEQUENCE_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_IR_REPEAT_SEQUENCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e7, 6, (val)); \
        } while (0)

#define GP_WB_SET_IR_REPEAT_SEQUENCE_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_CONTROL_1() \
        GP_WB_READ_U8(0x2e8)

#define GP_WB_WRITE_IR_MODULATION_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x2e8, (val))

/* When set to '1', the ram sequence start pointer and ram sequence length are latched when a ram sequence is fired (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START() \
        GP_WB_READ_U1(0x2e8, 0)

#define GP_WB_GET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START_FROM_MODULATION_CONTROL_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e8, 0, (val)); \
        } while (0)

#define GP_WB_SET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', the ram sequence start pointer and ram sequence length are latched when a ram sequence is repeated, because the repeat seuance bit was set (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT() \
        GP_WB_READ_U1(0x2e8, 1)

#define GP_WB_GET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e8, 1, (val)); \
        } while (0)

#define GP_WB_SET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set to '1', the use_alt_carrier_config will be toggle on an index match (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH() \
        GP_WB_READ_U1(0x2e8, 2)

#define GP_WB_GET_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e8, 2, (val)); \
        } while (0)

#define GP_WB_SET_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set to '1', the ram sequencer can be start by the ES (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_SENSITIVE_FOR_ES_START() \
        GP_WB_READ_U1(0x2e8, 3)

#define GP_WB_GET_IR_SENSITIVE_FOR_ES_START_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IR_SENSITIVE_FOR_ES_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2e8, 3, (val)); \
        } while (0)

#define GP_WB_SET_IR_SENSITIVE_FOR_ES_START_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Sets the start pointer of the ram modulation sequence block (16 bit word address offset with respect to RAM start adddress) */
#define GP_WB_READ_IR_RAM_SEQUENCE_START_PTR() \
        GP_WB_READ_U16(0x2ea)

#define GP_WB_WRITE_IR_RAM_SEQUENCE_START_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFF); \
          GP_WB_WRITE_U16(0x2ea, (val)); \
        } while (0)


/* Sets the length of the ram sequence - len is set to number of entries - 1 */
#define GP_WB_READ_IR_RAM_SEQUENCE_LEN() \
        GP_WB_READ_U8(0x2ec)

#define GP_WB_WRITE_IR_RAM_SEQUENCE_LEN(val) do { \
          GP_WB_WRITE_U8(0x2ec, (val)); \
        } while (0)


/* Sets the index value that is checked for matches */
#define GP_WB_READ_IR_RAM_SEQUENCE_MATCH_INDEX() \
        GP_WB_READ_U8(0x2ed)

#define GP_WB_WRITE_IR_RAM_SEQUENCE_MATCH_INDEX(val) do { \
          GP_WB_WRITE_U8(0x2ed, (val)); \
        } while (0)


#define GP_WB_WRITE_IR_MODULATION_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x2ee, (val))

/* Fire of a ram sequence */
#define GP_WB_IR_START_RAM_SEQUENCER() \
        GP_WB_WRITE_U8(0x2ee, 0x01)

#define GP_WB_SET_IR_START_RAM_SEQUENCER_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set use_alt_carrier_configuration to 1 */
#define GP_WB_IR_ALT_CARRIER_SET() \
        GP_WB_WRITE_U8(0x2ee, 0x02)

#define GP_WB_SET_IR_ALT_CARRIER_SET_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set use_alt_carrier_configuration to 0 */
#define GP_WB_IR_ALT_CARRIER_UNSET() \
        GP_WB_WRITE_U8(0x2ee, 0x04)

#define GP_WB_SET_IR_ALT_CARRIER_UNSET_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


#define GP_WB_WRITE_IR_INTERRUPT_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x2ef, (val))

/* sequence start interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_START_INTERRUPT() \
        GP_WB_WRITE_U8(0x2ef, 0x01)

#define GP_WB_SET_IR_CLR_SEQUENCE_START_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* sequence repeat interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_WRITE_U8(0x2ef, 0x02)

#define GP_WB_SET_IR_CLR_SEQUENCE_REPEAT_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* sequence done interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(0x2ef, 0x04)

#define GP_WB_SET_IR_CLR_SEQUENCE_DONE_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* index match interrupt clear */
#define GP_WB_IR_CLR_INDEX_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(0x2ef, 0x08)

#define GP_WB_SET_IR_CLR_INDEX_MATCH_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_STATUS() \
        GP_WB_READ_U8(0x2f0)

/* ram sequence is ongoing */
#define GP_WB_READ_IR_BUSY() \
        GP_WB_READ_U1(0x2f0, 0)

#define GP_WB_GET_IR_BUSY_FROM_MODULATION_STATUS(tmp) \
        ((tmp) & 0x01)

/* indicates that the ram sequence was aborted because of a memory access err-or */
#define GP_WB_READ_IR_MEM_ERR() \
        GP_WB_READ_U1(0x2f0, 1)

#define GP_WB_GET_IR_MEM_ERR_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Shows the status of the envelope - just for observability */
#define GP_WB_READ_IR_ENVELOPE() \
        GP_WB_READ_U1(0x2f0, 2)

#define GP_WB_GET_IR_ENVELOPE_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Shows the status of the carrier - just for observability */
#define GP_WB_READ_IR_CARRIER() \
        GP_WB_READ_U1(0x2f0, 3)

#define GP_WB_GET_IR_CARRIER_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* when '0', threshold and wrap are used for carrier generation. when '1', alt_threshold and alt_wrap are used for carrier generation. */
#define GP_WB_READ_IR_USE_ALT_CARRIER_CONFIG() \
        GP_WB_READ_U1(0x2f0, 4)

#define GP_WB_GET_IR_USE_ALT_CARRIER_CONFIG_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_INTERRUPT_STATUS() \
        GP_WB_READ_U8(0x2f1)

/* unmasked interrupt status of the interrupt triggered by starting a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(0x2f1, 0)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_START_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        ((tmp) & 0x01)

/* unmasked interrupt status of the interrupt triggered by repeating a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(0x2f1, 1)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_REPEAT_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked interrupt status of the interrupt triggered by finishing a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x2f1, 2)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_DONE_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* unmasked interrupt status of the interrupt triggered by the ram sequence hitting a certain index */
#define GP_WB_READ_IR_UNMASKED_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x2f1, 3)

#define GP_WB_GET_IR_UNMASKED_INDEX_MATCH_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)


/* shows the what index in the ram sequence is currently being executed */
#define GP_WB_READ_IR_SEQUENCE_IDX() \
        GP_WB_READ_U8(0x2f2)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_IO_CONTROL() \
        GP_WB_READ_U8(0x2f3)

#define GP_WB_WRITE_IR_IO_CONTROL(val) \
      GP_WB_WRITE_U8(0x2f3, (val))

/* Sets the pin map for the output (remark that only mappings a/b/c and d are used - other mappings result into unmapped) */
#define GP_WB_READ_IR_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x2f3) & 0x07)

#define GP_WB_GET_IR_OUTPUT_PINMAP_FROM_IO_CONTROL(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_IR_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x2f3, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_IR_OUTPUT_PINMAP_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the pin map for the input - 1 disabled, 0 enabled */
#define GP_WB_READ_IR_INPUT_PINMAP() \
        GP_WB_READ_U1(0x2f3, 3)

#define GP_WB_GET_IR_INPUT_PINMAP_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IR_INPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2f3, 3, (val)); \
        } while (0)

#define GP_WB_SET_IR_INPUT_PINMAP_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Sets the drive type for the output */
#define GP_WB_READ_IR_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x2f3, 4)

#define GP_WB_GET_IR_OUTPUT_DRIVE_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IR_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2f3, 4, (val)); \
        } while (0)

#define GP_WB_SET_IR_OUTPUT_DRIVE_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_IR_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x2f3, 5)

#define GP_WB_GET_IR_OUTPUT_INVERT_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IR_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2f3, 5, (val)); \
        } while (0)

#define GP_WB_SET_IR_OUTPUT_INVERT_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* inverts the input */
#define GP_WB_READ_IR_INPUT_INVERT() \
        GP_WB_READ_U1(0x2f3, 6)

#define GP_WB_GET_IR_INPUT_INVERT_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_IR_INPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x2f3, 6, (val)); \
        } while (0)

#define GP_WB_SET_IR_INPUT_INVERT_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/***************************
 * layout: ipc
 ***************************/

#define GP_WB_WRITE_IPC_INT2EXT_FLAG_INTERRUPTS_SETCLR(val) \
      GP_WB_WRITE_U8(0x300, (val))

/* Sets the inter processor communication interrupt(s) from internal 2 external */
#define GP_WB_WRITE_IPC_INT2EXT_FLAG_SET_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x300, (val)); \
        } while (0)

#define GP_WB_SET_IPC_INT2EXT_FLAG_SET_INTERRUPTS_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the internal to external interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_A_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x01)

#define GP_WB_SET_IPC_INT2EXT_FLAG_A_SET_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the internal to external interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_B_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x02)

#define GP_WB_SET_IPC_INT2EXT_FLAG_B_SET_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the internal to external interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_C_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x04)

#define GP_WB_SET_IPC_INT2EXT_FLAG_C_SET_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the internal to external interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_D_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x08)

#define GP_WB_SET_IPC_INT2EXT_FLAG_D_SET_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Clears the inter processor communication interrupt(s) from internal 2 external */
#define GP_WB_WRITE_IPC_INT2EXT_FLAG_CLR_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x300, (val) << 4); \
        } while (0)

#define GP_WB_SET_IPC_INT2EXT_FLAG_CLR_INTERRUPTS_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Clear the internal to external interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_A_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x10)

#define GP_WB_SET_IPC_INT2EXT_FLAG_A_CLR_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Clear the internal to external interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_B_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x20)

#define GP_WB_SET_IPC_INT2EXT_FLAG_B_CLR_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Clear the internal to external interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_C_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x40)

#define GP_WB_SET_IPC_INT2EXT_FLAG_C_CLR_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Clear the internal to external interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_INT2EXT_FLAG_D_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x300, 0x80)

#define GP_WB_SET_IPC_INT2EXT_FLAG_D_CLR_INTERRUPT_TO_INT2EXT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


#define GP_WB_WRITE_IPC_EXT2INT_FLAG_INTERRUPTS_SETCLR(val) \
      GP_WB_WRITE_U8(0x301, (val))

/* Sets the inter processor communication interrupt(s) from external 2 internal */
#define GP_WB_WRITE_IPC_EXT2INT_FLAG_SET_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x301, (val)); \
        } while (0)

#define GP_WB_SET_IPC_EXT2INT_FLAG_SET_INTERRUPTS_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the external to internal interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_A_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x01)

#define GP_WB_SET_IPC_EXT2INT_FLAG_A_SET_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the external to internal interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_B_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x02)

#define GP_WB_SET_IPC_EXT2INT_FLAG_B_SET_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the external to internal interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_C_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x04)

#define GP_WB_SET_IPC_EXT2INT_FLAG_C_SET_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the external to internal interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_D_SET_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x08)

#define GP_WB_SET_IPC_EXT2INT_FLAG_D_SET_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Clears the inter processor communication interrupt(s) from external 2 internal */
#define GP_WB_WRITE_IPC_EXT2INT_FLAG_CLR_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x301, (val) << 4); \
        } while (0)

#define GP_WB_SET_IPC_EXT2INT_FLAG_CLR_INTERRUPTS_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Clear the external to internal interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_A_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x10)

#define GP_WB_SET_IPC_EXT2INT_FLAG_A_CLR_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Clear the external to internal interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_B_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x20)

#define GP_WB_SET_IPC_EXT2INT_FLAG_B_CLR_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Clear the external to internal interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_C_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x40)

#define GP_WB_SET_IPC_EXT2INT_FLAG_C_CLR_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Clear the external to internal interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_EXT2INT_FLAG_D_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x301, 0x80)

#define GP_WB_SET_IPC_EXT2INT_FLAG_D_CLR_INTERRUPT_TO_EXT2INT_FLAG_INTERRUPTS_SETCLR(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(0x302)

/* Unmasked interrupt status of internal to external interrupts */
#define GP_WB_READ_IPC_UNMASKED_INT2EXT_FLAG_INTERRUPTS() \
        (GP_WB_READ_U8(0x302) & 0x0F)

#define GP_WB_GET_IPC_UNMASKED_INT2EXT_FLAG_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_READ_IPC_UNMASKED_INT2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x302, 0)

#define GP_WB_GET_IPC_UNMASKED_INT2EXT_FLAG_A_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x302, 1)

#define GP_WB_GET_IPC_UNMASKED_INT2EXT_FLAG_B_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x302, 2)

#define GP_WB_GET_IPC_UNMASKED_INT2EXT_FLAG_C_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x302, 3)

#define GP_WB_GET_IPC_UNMASKED_INT2EXT_FLAG_D_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Unmasked interrupt status of external to internal interrupts */
#define GP_WB_READ_IPC_UNMASKED_EXT2INT_FLAG_INTERRUPTS() \
        ((GP_WB_READ_U8(0x302) >> 4) & 0x0F)

#define GP_WB_GET_IPC_UNMASKED_EXT2INT_FLAG_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_READ_IPC_UNMASKED_EXT2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x302, 4)

#define GP_WB_GET_IPC_UNMASKED_EXT2INT_FLAG_A_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x302, 5)

#define GP_WB_GET_IPC_UNMASKED_EXT2INT_FLAG_B_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x302, 6)

#define GP_WB_GET_IPC_UNMASKED_EXT2INT_FLAG_C_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x302, 7)

#define GP_WB_GET_IPC_UNMASKED_EXT2INT_FLAG_D_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/***************************
 * layout: watchdog
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_CONTROL() \
        GP_WB_READ_U8(0x310)

#define GP_WB_WRITE_WATCHDOG_CONTROL(val) \
      GP_WB_WRITE_U8(0x310, (val))

/* Watchdog enabled when 0x1 - Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_ENABLE() \
        GP_WB_READ_U1(0x310, 0)

#define GP_WB_GET_WATCHDOG_ENABLE_FROM_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_WATCHDOG_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x310, 0, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_ENABLE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Function of watchdog, triggered when timer reaches zero - Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_WATCHDOG_FUNCTION() \
        ((GP_WB_READ_U8(0x310) >> 1) & 0x07)

#define GP_WB_GET_WATCHDOG_WATCHDOG_FUNCTION_FROM_CONTROL(tmp) \
        (((tmp) >> 1) & 0x07)

#define GP_WB_WRITE_WATCHDOG_WATCHDOG_FUNCTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x310, 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_WATCHDOG_WATCHDOG_FUNCTION_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Watchdog timeout value in 16 us -  Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_TIMEOUT() \
        GP_WB_READ_U16(0x312)

#define GP_WB_WRITE_WATCHDOG_TIMEOUT(val) do { \
          GP_WB_WRITE_U16(0x312, (val)); \
        } while (0)


/* Watchdog key register. Write 0xAA to reset the wachdog, Write 0x55 to initiate a control settings change sequence */
#define GP_WB_WRITE_WATCHDOG_KEY(val) do { \
          GP_WB_WRITE_U8(0x314, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_CONFIG() \
        GP_WB_READ_U8(0x315)

#define GP_WB_WRITE_WATCHDOG_CONFIG(val) \
      GP_WB_WRITE_U8(0x315, (val))

/* When set to 1, the watchdog timer will be frozen whan the internal uc goes to sleep */
#define GP_WB_READ_WATCHDOG_FREEZE_WHEN_UC_ASLEEP() \
        GP_WB_READ_U1(0x315, 0)

#define GP_WB_GET_WATCHDOG_FREEZE_WHEN_UC_ASLEEP_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_WATCHDOG_FREEZE_WHEN_UC_ASLEEP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x315, 0, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_FREEZE_WHEN_UC_ASLEEP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, the watchdog timer will be frozen whan the internal uc hits a break point in debug mode */
#define GP_WB_READ_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT() \
        GP_WB_READ_U1(0x315, 1)

#define GP_WB_GET_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x315, 1, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Clears the watchdog expired interrupt */
#define GP_WB_WATCHDOG_CLR_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_WRITE_U8(0x316, 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_STATUS() \
        GP_WB_READ_U8(0x317)

/* This status bit indicates that the window for changing watchdog control settings is open. Control settings can only be changed when this status bit is 1 */
#define GP_WB_READ_WATCHDOG_CONTROL_CHANGE_WINDOW_ONGOING() \
        GP_WB_READ_U1(0x317, 0)

#define GP_WB_GET_WATCHDOG_CONTROL_CHANGE_WINDOW_ONGOING_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Unmasked status of the timer expired interrupt */
#define GP_WB_READ_WATCHDOG_UNMASKED_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(0x317, 1)

#define GP_WB_GET_WATCHDOG_UNMASKED_TIMER_EXPIRED_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the timer has reached 0. This status is reset by a watchdog reset, or by a control settings change */
#define GP_WB_READ_WATCHDOG_TIMER_EXPIRED() \
        GP_WB_READ_U1(0x317, 2)

#define GP_WB_GET_WATCHDOG_TIMER_EXPIRED_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Watchdog current time (16 us multiples) */
#define GP_WB_READ_WATCHDOG_CURRENT_TIME() \
        GP_WB_READ_U16(0x318)

/***************************
 * layout: led
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_TIME_BASE() \
        GP_WB_READ_U8(0x320)

#define GP_WB_WRITE_LED_TIME_BASE(val) \
      GP_WB_WRITE_U8(0x320, (val))

/* Sets the divide factor for the prescaler. The prescaled frequecy is 4MHz/(2**prescale_div) */
#define GP_WB_READ_LED_PRESCALE_DIV() \
        (GP_WB_READ_U8(0x320) & 0x0F)

#define GP_WB_GET_LED_PRESCALE_DIV_FROM_TIME_BASE(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_LED_PRESCALE_DIV(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x320, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_LED_PRESCALE_DIV_TO_TIME_BASE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Used mainly for verification purposes. When set to 1, the time_slope is set in multiples of 16 us instead of 1024us multiples */
#define GP_WB_READ_LED_USE_SHORT_TIME_BASE() \
        GP_WB_READ_U1(0x320, 4)

#define GP_WB_GET_LED_USE_SHORT_TIME_BASE_FROM_TIME_BASE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_USE_SHORT_TIME_BASE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x320, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_USE_SHORT_TIME_BASE_TO_TIME_BASE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Sets the time in 128us multiples for a dutycycle unit increment during fade (when use_short_time_base is set, the time unit is expressed in 16 us units (T= (slope_time_unit+1) * 1024 us) */
#define GP_WB_READ_LED_SLOPE_TIME_UNIT() \
        GP_WB_READ_U8(0x321)

#define GP_WB_WRITE_LED_SLOPE_TIME_UNIT(val) do { \
          GP_WB_WRITE_U8(0x321, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_CONTROL() \
        GP_WB_READ_U8(0x322)

#define GP_WB_WRITE_LED_CONTROL(val) \
      GP_WB_WRITE_U8(0x322, (val))

/* Set to 1 to enable led 0 */
#define GP_WB_READ_LED_ENABLE_0() \
        GP_WB_READ_U1(0x322, 0)

#define GP_WB_GET_LED_ENABLE_0_FROM_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LED_ENABLE_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 0, (val)); \
        } while (0)

#define GP_WB_SET_LED_ENABLE_0_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LED_FADE_0() \
        GP_WB_READ_U1(0x322, 1)

#define GP_WB_GET_LED_FADE_0_FROM_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LED_FADE_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 1, (val)); \
        } while (0)

#define GP_WB_SET_LED_FADE_0_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set to 1 to enable led 0 */
#define GP_WB_READ_LED_ENABLE_1() \
        GP_WB_READ_U1(0x322, 2)

#define GP_WB_GET_LED_ENABLE_1_FROM_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LED_ENABLE_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 2, (val)); \
        } while (0)

#define GP_WB_SET_LED_ENABLE_1_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LED_FADE_1() \
        GP_WB_READ_U1(0x322, 3)

#define GP_WB_GET_LED_FADE_1_FROM_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LED_FADE_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 3, (val)); \
        } while (0)

#define GP_WB_SET_LED_FADE_1_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Set to 1 to enable led 0 */
#define GP_WB_READ_LED_ENABLE_2() \
        GP_WB_READ_U1(0x322, 4)

#define GP_WB_GET_LED_ENABLE_2_FROM_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_ENABLE_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_ENABLE_2_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LED_FADE_2() \
        GP_WB_READ_U1(0x322, 5)

#define GP_WB_GET_LED_FADE_2_FROM_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LED_FADE_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 5, (val)); \
        } while (0)

#define GP_WB_SET_LED_FADE_2_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Set to 1 to enable led 0 */
#define GP_WB_READ_LED_ENABLE_3() \
        GP_WB_READ_U1(0x322, 6)

#define GP_WB_GET_LED_ENABLE_3_FROM_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_LED_ENABLE_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 6, (val)); \
        } while (0)

#define GP_WB_SET_LED_ENABLE_3_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LED_FADE_3() \
        GP_WB_READ_U1(0x322, 7)

#define GP_WB_GET_LED_FADE_3_FROM_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_LED_FADE_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x322, 7, (val)); \
        } while (0)

#define GP_WB_SET_LED_FADE_3_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LED_THRESHOLD_0() \
        GP_WB_READ_U8(0x323)

#define GP_WB_WRITE_LED_THRESHOLD_0(val) do { \
          GP_WB_WRITE_U8(0x323, (val)); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LED_THRESHOLD_1() \
        GP_WB_READ_U8(0x324)

#define GP_WB_WRITE_LED_THRESHOLD_1(val) do { \
          GP_WB_WRITE_U8(0x324, (val)); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LED_THRESHOLD_2() \
        GP_WB_READ_U8(0x325)

#define GP_WB_WRITE_LED_THRESHOLD_2(val) do { \
          GP_WB_WRITE_U8(0x325, (val)); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LED_THRESHOLD_3() \
        GP_WB_READ_U8(0x326)

#define GP_WB_WRITE_LED_THRESHOLD_3(val) do { \
          GP_WB_WRITE_U8(0x326, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_IO_CONTROL_0() \
        GP_WB_READ_U8(0x327)

#define GP_WB_WRITE_LED_IO_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x327, (val))

/* Sets the pin map for the led output */
#define GP_WB_READ_LED_LED0_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x327) & 0x07)

#define GP_WB_GET_LED_LED0_OUTPUT_PINMAP_FROM_IO_CONTROL_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_LED_LED0_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x327, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED0_OUTPUT_PINMAP_TO_IO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the drive type for the output */
#define GP_WB_READ_LED_LED0_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x327, 3)

#define GP_WB_GET_LED_LED0_OUTPUT_DRIVE_FROM_IO_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LED_LED0_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x327, 3, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED0_OUTPUT_DRIVE_TO_IO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LED_LED0_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x327, 4)

#define GP_WB_GET_LED_LED0_OUTPUT_INVERT_FROM_IO_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_LED0_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x327, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED0_OUTPUT_INVERT_TO_IO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LED_LED0_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(0x327, 5)

#define GP_WB_GET_LED_LED0_ALLOW_GOTOSLEEP_WHEN_ON_FROM_IO_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LED_LED0_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x327, 5, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED0_ALLOW_GOTOSLEEP_WHEN_ON_TO_IO_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_IO_CONTROL_1() \
        GP_WB_READ_U8(0x328)

#define GP_WB_WRITE_LED_IO_CONTROL_1(val) \
      GP_WB_WRITE_U8(0x328, (val))

/* Sets the pin map for the led output */
#define GP_WB_READ_LED_LED1_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x328) & 0x07)

#define GP_WB_GET_LED_LED1_OUTPUT_PINMAP_FROM_IO_CONTROL_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_LED_LED1_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x328, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED1_OUTPUT_PINMAP_TO_IO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the drive type for the output */
#define GP_WB_READ_LED_LED1_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x328, 3)

#define GP_WB_GET_LED_LED1_OUTPUT_DRIVE_FROM_IO_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LED_LED1_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x328, 3, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED1_OUTPUT_DRIVE_TO_IO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Inverts output */
#define GP_WB_READ_LED_LED1_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x328, 4)

#define GP_WB_GET_LED_LED1_OUTPUT_INVERT_FROM_IO_CONTROL_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_LED1_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x328, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED1_OUTPUT_INVERT_TO_IO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LED_LED1_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(0x328, 5)

#define GP_WB_GET_LED_LED1_ALLOW_GOTOSLEEP_WHEN_ON_FROM_IO_CONTROL_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LED_LED1_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x328, 5, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED1_ALLOW_GOTOSLEEP_WHEN_ON_TO_IO_CONTROL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_IO_CONTROL_2() \
        GP_WB_READ_U8(0x329)

#define GP_WB_WRITE_LED_IO_CONTROL_2(val) \
      GP_WB_WRITE_U8(0x329, (val))

/* Sets the pin map for the led output */
#define GP_WB_READ_LED_LED2_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x329) & 0x07)

#define GP_WB_GET_LED_LED2_OUTPUT_PINMAP_FROM_IO_CONTROL_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_LED_LED2_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x329, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED2_OUTPUT_PINMAP_TO_IO_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the drive type for the output */
#define GP_WB_READ_LED_LED2_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x329, 3)

#define GP_WB_GET_LED_LED2_OUTPUT_DRIVE_FROM_IO_CONTROL_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LED_LED2_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x329, 3, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED2_OUTPUT_DRIVE_TO_IO_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LED_LED2_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x329, 4)

#define GP_WB_GET_LED_LED2_OUTPUT_INVERT_FROM_IO_CONTROL_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_LED2_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x329, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED2_OUTPUT_INVERT_TO_IO_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LED_LED2_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(0x329, 5)

#define GP_WB_GET_LED_LED2_ALLOW_GOTOSLEEP_WHEN_ON_FROM_IO_CONTROL_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LED_LED2_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x329, 5, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED2_ALLOW_GOTOSLEEP_WHEN_ON_TO_IO_CONTROL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_IO_CONTROL_3() \
        GP_WB_READ_U8(0x32a)

#define GP_WB_WRITE_LED_IO_CONTROL_3(val) \
      GP_WB_WRITE_U8(0x32a, (val))

/* Sets the pin map for the led output */
#define GP_WB_READ_LED_LED3_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x32a) & 0x07)

#define GP_WB_GET_LED_LED3_OUTPUT_PINMAP_FROM_IO_CONTROL_3(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_LED_LED3_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x32a, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED3_OUTPUT_PINMAP_TO_IO_CONTROL_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the drive type for the output */
#define GP_WB_READ_LED_LED3_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x32a, 3)

#define GP_WB_GET_LED_LED3_OUTPUT_DRIVE_FROM_IO_CONTROL_3(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LED_LED3_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x32a, 3, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED3_OUTPUT_DRIVE_TO_IO_CONTROL_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LED_LED3_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x32a, 4)

#define GP_WB_GET_LED_LED3_OUTPUT_INVERT_FROM_IO_CONTROL_3(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LED_LED3_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x32a, 4, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED3_OUTPUT_INVERT_TO_IO_CONTROL_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LED_LED3_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(0x32a, 5)

#define GP_WB_GET_LED_LED3_ALLOW_GOTOSLEEP_WHEN_ON_FROM_IO_CONTROL_3(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LED_LED3_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x32a, 5, (val)); \
        } while (0)

#define GP_WB_SET_LED_LED3_ALLOW_GOTOSLEEP_WHEN_ON_TO_IO_CONTROL_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* dummy - regmag gen thing ... */
#define GP_WB_READ_LED_DUMMY_STATUS() \
        GP_WB_READ_U1(0x32b, 0)

/***************************
 * layout: coex
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_ARBITER_CONFIG() \
        GP_WB_READ_U8(0x330)

#define GP_WB_WRITE_COEX_ARBITER_CONFIG(val) \
      GP_WB_WRITE_U8(0x330, (val))

/* master = 1 / slave = 0 */
#define GP_WB_READ_COEX_MASTER_NOT_SLAVE() \
        GP_WB_READ_U1(0x330, 0)

#define GP_WB_GET_COEX_MASTER_NOT_SLAVE_FROM_ARBITER_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_COEX_MASTER_NOT_SLAVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x330, 0, (val)); \
        } while (0)

#define GP_WB_SET_COEX_MASTER_NOT_SLAVE_TO_ARBITER_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_COEX_ABORT_ON_HIGHER_PRIO_REQ() \
        GP_WB_READ_U1(0x330, 1)

#define GP_WB_GET_COEX_ABORT_ON_HIGHER_PRIO_REQ_FROM_ARBITER_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_COEX_ABORT_ON_HIGHER_PRIO_REQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x330, 1, (val)); \
        } while (0)

#define GP_WB_SET_COEX_ABORT_ON_HIGHER_PRIO_REQ_TO_ARBITER_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* sub priorities, "00" => exta = 2, extb = 1, int=0; "01" => exta = 2, int=1, extb =0; others => int = 2, exta = 1, extb=0; */
#define GP_WB_READ_COEX_INT_SUB_PRIO() \
        ((GP_WB_READ_U8(0x330) >> 2) & 0x03)

#define GP_WB_GET_COEX_INT_SUB_PRIO_FROM_ARBITER_CONFIG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_COEX_INT_SUB_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x330, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_COEX_INT_SUB_PRIO_TO_ARBITER_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x13; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when set, the different pins shall be mapped on an alternate gpio location in order to fit QFN32 package type */
#define GP_WB_READ_COEX_USE_ALTERNATE_PINMAP() \
        GP_WB_READ_U1(0x330, 4)

#define GP_WB_GET_COEX_USE_ALTERNATE_PINMAP_FROM_ARBITER_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_COEX_USE_ALTERNATE_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x330, 4, (val)); \
        } while (0)

#define GP_WB_SET_COEX_USE_ALTERNATE_PINMAP_TO_ARBITER_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_PRIORITY_EXPANSION_CONFIG() \
        GP_WB_READ_U8(0x331)

#define GP_WB_WRITE_COEX_PRIORITY_EXPANSION_CONFIG(val) \
      GP_WB_WRITE_U8(0x331, (val))

/* exta_0_priority value 0 to 3 */
#define GP_WB_READ_COEX_EXTA_0_PRIO() \
        (GP_WB_READ_U8(0x331) & 0x03)

#define GP_WB_GET_COEX_EXTA_0_PRIO_FROM_PRIORITY_EXPANSION_CONFIG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_COEX_EXTA_0_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x331, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_0_PRIO_TO_PRIORITY_EXPANSION_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* etxa_1_priority value 0 to 3 */
#define GP_WB_READ_COEX_EXTA_1_PRIO() \
        ((GP_WB_READ_U8(0x331) >> 2) & 0x03)

#define GP_WB_GET_COEX_EXTA_1_PRIO_FROM_PRIORITY_EXPANSION_CONFIG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_COEX_EXTA_1_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x331, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_1_PRIO_TO_PRIORITY_EXPANSION_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* extb_0_priority value 0 to 3 */
#define GP_WB_READ_COEX_EXTB_0_PRIO() \
        ((GP_WB_READ_U8(0x331) >> 4) & 0x03)

#define GP_WB_GET_COEX_EXTB_0_PRIO_FROM_PRIORITY_EXPANSION_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_COEX_EXTB_0_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x331, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_0_PRIO_TO_PRIORITY_EXPANSION_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* extb_1_priority value 0 to 3 */
#define GP_WB_READ_COEX_EXTB_1_PRIO() \
        ((GP_WB_READ_U8(0x331) >> 6) & 0x03)

#define GP_WB_GET_COEX_EXTB_1_PRIO_FROM_PRIORITY_EXPANSION_CONFIG(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_COEX_EXTB_1_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x331, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_1_PRIO_TO_PRIORITY_EXPANSION_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_EXTA_IO_CONFIG() \
        GP_WB_READ_U8(0x332)

#define GP_WB_WRITE_COEX_EXTA_IO_CONFIG(val) \
      GP_WB_WRITE_U8(0x332, (val))

/* Inverse ext_a_request_in */
#define GP_WB_READ_COEX_EXTA_REQUEST_IN_INVERSE() \
        GP_WB_READ_U1(0x332, 0)

#define GP_WB_GET_COEX_EXTA_REQUEST_IN_INVERSE_FROM_EXTA_IO_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_REQUEST_IN_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 0, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_REQUEST_IN_INVERSE_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_EXTA_REQUEST_IN_MAPPING() \
        GP_WB_READ_U1(0x332, 1)

#define GP_WB_GET_COEX_EXTA_REQUEST_IN_MAPPING_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_REQUEST_IN_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 1, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_REQUEST_IN_MAPPING_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Inverse pin exta_prio_in */
#define GP_WB_READ_COEX_EXTA_PRIO_IN_INVERSE() \
        GP_WB_READ_U1(0x332, 2)

#define GP_WB_GET_COEX_EXTA_PRIO_IN_INVERSE_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_PRIO_IN_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 2, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_PRIO_IN_INVERSE_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped, when not mapped, it is treated as 0 */
#define GP_WB_READ_COEX_EXTA_PRIO_IN_MAPPING() \
        GP_WB_READ_U1(0x332, 3)

#define GP_WB_GET_COEX_EXTA_PRIO_IN_MAPPING_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_PRIO_IN_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 3, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_PRIO_IN_MAPPING_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 => push pull, 1 => open drain */
#define GP_WB_READ_COEX_EXTA_GRANTED_OUT_DRIVE_TYPE() \
        GP_WB_READ_U1(0x332, 4)

#define GP_WB_GET_COEX_EXTA_GRANTED_OUT_DRIVE_TYPE_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_GRANTED_OUT_DRIVE_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 4, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_GRANTED_OUT_DRIVE_TYPE_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Inverse pin exta_granted_out */
#define GP_WB_READ_COEX_EXTA_GRANTED_OUT_INVERSE() \
        GP_WB_READ_U1(0x332, 5)

#define GP_WB_GET_COEX_EXTA_GRANTED_OUT_INVERSE_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_GRANTED_OUT_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 5, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_GRANTED_OUT_INVERSE_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_EXTA_GRANTED_OUT_MAPPING() \
        GP_WB_READ_U1(0x332, 6)

#define GP_WB_GET_COEX_EXTA_GRANTED_OUT_MAPPING_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_GRANTED_OUT_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 6, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_GRANTED_OUT_MAPPING_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* enable event scheduler request OR with ext_a_req */
#define GP_WB_READ_COEX_EXTA_ES_REQ_OR_EN() \
        GP_WB_READ_U1(0x332, 7)

#define GP_WB_GET_COEX_EXTA_ES_REQ_OR_EN_FROM_EXTA_IO_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_COEX_EXTA_ES_REQ_OR_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x332, 7, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTA_ES_REQ_OR_EN_TO_EXTA_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_EXTB_IO_CONFIG() \
        GP_WB_READ_U8(0x333)

#define GP_WB_WRITE_COEX_EXTB_IO_CONFIG(val) \
      GP_WB_WRITE_U8(0x333, (val))

/* Inverse pin */
#define GP_WB_READ_COEX_EXTB_REQUEST_IN_INVERSE() \
        GP_WB_READ_U1(0x333, 0)

#define GP_WB_GET_COEX_EXTB_REQUEST_IN_INVERSE_FROM_EXTB_IO_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_REQUEST_IN_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 0, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_REQUEST_IN_INVERSE_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_EXTB_REQUEST_IN_MAPPING() \
        GP_WB_READ_U1(0x333, 1)

#define GP_WB_GET_COEX_EXTB_REQUEST_IN_MAPPING_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_REQUEST_IN_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 1, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_REQUEST_IN_MAPPING_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Inverse pin */
#define GP_WB_READ_COEX_EXTB_PRIO_IN_INVERSE() \
        GP_WB_READ_U1(0x333, 2)

#define GP_WB_GET_COEX_EXTB_PRIO_IN_INVERSE_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_PRIO_IN_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 2, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_PRIO_IN_INVERSE_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped, when not mapped, it is treated as 0 */
#define GP_WB_READ_COEX_EXTB_PRIO_IN_MAPPING() \
        GP_WB_READ_U1(0x333, 3)

#define GP_WB_GET_COEX_EXTB_PRIO_IN_MAPPING_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_PRIO_IN_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 3, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_PRIO_IN_MAPPING_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 => push pull, 1 => open drain */
#define GP_WB_READ_COEX_EXTB_GRANTED_OUT_DRIVE_TYPE() \
        GP_WB_READ_U1(0x333, 4)

#define GP_WB_GET_COEX_EXTB_GRANTED_OUT_DRIVE_TYPE_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_GRANTED_OUT_DRIVE_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 4, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_GRANTED_OUT_DRIVE_TYPE_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Inverse pin */
#define GP_WB_READ_COEX_EXTB_GRANTED_OUT_INVERSE() \
        GP_WB_READ_U1(0x333, 5)

#define GP_WB_GET_COEX_EXTB_GRANTED_OUT_INVERSE_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_GRANTED_OUT_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 5, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_GRANTED_OUT_INVERSE_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_EXTB_GRANTED_OUT_MAPPING() \
        GP_WB_READ_U1(0x333, 6)

#define GP_WB_GET_COEX_EXTB_GRANTED_OUT_MAPPING_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_GRANTED_OUT_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 6, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_GRANTED_OUT_MAPPING_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* enable event scheduler request OR with ext_b_req */
#define GP_WB_READ_COEX_EXTB_ES_REQ_OR_EN() \
        GP_WB_READ_U1(0x333, 7)

#define GP_WB_GET_COEX_EXTB_ES_REQ_OR_EN_FROM_EXTB_IO_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_COEX_EXTB_ES_REQ_OR_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x333, 7, (val)); \
        } while (0)

#define GP_WB_SET_COEX_EXTB_ES_REQ_OR_EN_TO_EXTB_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_INT_IO_CONFIG() \
        GP_WB_READ_U8(0x334)

#define GP_WB_WRITE_COEX_INT_IO_CONFIG(val) \
      GP_WB_WRITE_U8(0x334, (val))

/* >0 => push pull, 1 => open drain */
#define GP_WB_READ_COEX_INT_REQUEST_OUT_DRIVE_TYPE() \
        GP_WB_READ_U1(0x334, 0)

#define GP_WB_GET_COEX_INT_REQUEST_OUT_DRIVE_TYPE_FROM_INT_IO_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_COEX_INT_REQUEST_OUT_DRIVE_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 0, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_REQUEST_OUT_DRIVE_TYPE_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* >Inverse pin */
#define GP_WB_READ_COEX_INT_REQUEST_OUT_INVERSE() \
        GP_WB_READ_U1(0x334, 1)

#define GP_WB_GET_COEX_INT_REQUEST_OUT_INVERSE_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_COEX_INT_REQUEST_OUT_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 1, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_REQUEST_OUT_INVERSE_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* >Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_INT_REQUEST_OUT_MAPPING() \
        GP_WB_READ_U1(0x334, 2)

#define GP_WB_GET_COEX_INT_REQUEST_OUT_MAPPING_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_COEX_INT_REQUEST_OUT_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 2, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_REQUEST_OUT_MAPPING_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 => push pull, 1 => open drain */
#define GP_WB_READ_COEX_INT_PRIO_OUT_DRIVE_TYPE() \
        GP_WB_READ_U1(0x334, 3)

#define GP_WB_GET_COEX_INT_PRIO_OUT_DRIVE_TYPE_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_COEX_INT_PRIO_OUT_DRIVE_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 3, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_PRIO_OUT_DRIVE_TYPE_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Inverse pin */
#define GP_WB_READ_COEX_INT_PRIO_OUT_INVERSE() \
        GP_WB_READ_U1(0x334, 4)

#define GP_WB_GET_COEX_INT_PRIO_OUT_INVERSE_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_COEX_INT_PRIO_OUT_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 4, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_PRIO_OUT_INVERSE_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_INT_PRIO_OUT_MAPPING() \
        GP_WB_READ_U1(0x334, 5)

#define GP_WB_GET_COEX_INT_PRIO_OUT_MAPPING_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_COEX_INT_PRIO_OUT_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 5, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_PRIO_OUT_MAPPING_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* pin inverse */
#define GP_WB_READ_COEX_INT_GRANTED_IN_INVERSE() \
        GP_WB_READ_U1(0x334, 6)

#define GP_WB_GET_COEX_INT_GRANTED_IN_INVERSE_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_COEX_INT_GRANTED_IN_INVERSE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 6, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_GRANTED_IN_INVERSE_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Pin mapping, 0 = mapped, 1 = not mapped */
#define GP_WB_READ_COEX_INT_GRANTED_IN_MAPPING() \
        GP_WB_READ_U1(0x334, 7)

#define GP_WB_GET_COEX_INT_GRANTED_IN_MAPPING_FROM_INT_IO_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_COEX_INT_GRANTED_IN_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x334, 7, (val)); \
        } while (0)

#define GP_WB_SET_COEX_INT_GRANTED_IN_MAPPING_TO_INT_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_STATUS_0() \
        GP_WB_READ_U8(0x335)

/* internal request status */
#define GP_WB_READ_COEX_INT_REQ() \
        GP_WB_READ_U1(0x335, 0)

#define GP_WB_GET_COEX_INT_REQ_FROM_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* internal priority status */
#define GP_WB_READ_COEX_INT_PRIO() \
        ((GP_WB_READ_U8(0x335) >> 1) & 0x03)

#define GP_WB_GET_COEX_INT_PRIO_FROM_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x03)

/* internal granted status */
#define GP_WB_READ_COEX_INT_GRANTED() \
        GP_WB_READ_U1(0x335, 4)

#define GP_WB_GET_COEX_INT_GRANTED_FROM_STATUS_0(tmp) \
        (((tmp) >> 4) & 0x01)

/* ext A granted status */
#define GP_WB_READ_COEX_EXTA_GRANTED() \
        GP_WB_READ_U1(0x335, 5)

#define GP_WB_GET_COEX_EXTA_GRANTED_FROM_STATUS_0(tmp) \
        (((tmp) >> 5) & 0x01)

/* ext B granted status */
#define GP_WB_READ_COEX_EXTB_GRANTED() \
        GP_WB_READ_U1(0x335, 6)

#define GP_WB_GET_COEX_EXTB_GRANTED_FROM_STATUS_0(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_COEX_STATUS_1() \
        GP_WB_READ_U8(0x336)

/* ext A request status */
#define GP_WB_READ_COEX_EXTA_REQ() \
        GP_WB_READ_U1(0x336, 0)

#define GP_WB_GET_COEX_EXTA_REQ_FROM_STATUS_1(tmp) \
        ((tmp) & 0x01)

/* ext A priority status */
#define GP_WB_READ_COEX_EXTA_PRIO() \
        ((GP_WB_READ_U8(0x336) >> 1) & 0x03)

#define GP_WB_GET_COEX_EXTA_PRIO_FROM_STATUS_1(tmp) \
        (((tmp) >> 1) & 0x03)

/* ext A request status */
#define GP_WB_READ_COEX_EXTB_REQ() \
        GP_WB_READ_U1(0x336, 4)

#define GP_WB_GET_COEX_EXTB_REQ_FROM_STATUS_1(tmp) \
        (((tmp) >> 4) & 0x01)

/* ext B priority status */
#define GP_WB_READ_COEX_EXTB_PRIO() \
        ((GP_WB_READ_U8(0x336) >> 5) & 0x03)

#define GP_WB_GET_COEX_EXTB_PRIO_FROM_STATUS_1(tmp) \
        (((tmp) >> 5) & 0x03)

/***************************
 * layout: spi_sl
 ***************************/

/* spi_sl TX byte. FIFO is cleared upon slave de-selection. */
#define GP_WB_WRITE_SPI_SL_TX_DATA(val) do { \
          GP_WB_WRITE_U8(0x340, (val)); \
        } while (0)


/* Last received spi_sl RX byte. FIFO is cleared upon slave de-selection. */
#define GP_WB_READ_SPI_SL_RX_DATA() \
        GP_WB_READ_U8(0x341)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_SL_CONFIG() \
        GP_WB_READ_U8(0x342)

#define GP_WB_WRITE_SPI_SL_CONFIG(val) \
      GP_WB_WRITE_U8(0x342, (val))

/* Amount of dummy of bytes that shift out of the MISO after the slave is selected and before real data is transmitted. Number of dummy bytes = tx_latency + 1 */
#define GP_WB_READ_SPI_SL_TX_LATENCY() \
        (GP_WB_READ_U8(0x342) & 0x0F)

#define GP_WB_GET_SPI_SL_TX_LATENCY_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_SPI_SL_TX_LATENCY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x342, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_SPI_SL_TX_LATENCY_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Pin mapping for the complete spi slave interface. */
#define GP_WB_READ_SPI_SL_PINMAP() \
        GP_WB_READ_U1(0x342, 4)

#define GP_WB_GET_SPI_SL_PINMAP_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SPI_SL_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x342, 4, (val)); \
        } while (0)

#define GP_WB_SET_SPI_SL_PINMAP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_SL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(0x343)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_SPI_SL_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x343, 1)

#define GP_WB_GET_SPI_SL_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_SPI_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x343, 2)

#define GP_WB_GET_SPI_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status and unmasked interrupt flag for the occurrence of a tx data buffer underrun. Set when the tx data buffer is empty when master pulls data from slave. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_SL_UNMASKED_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x343, 3)

#define GP_WB_GET_SPI_SL_UNMASKED_TX_UNDERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status and unmasked interrupt flag for the occurrence of a rx data buffer overrun. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_SL_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x343, 4)

#define GP_WB_GET_SPI_SL_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_SPI_SL_CLEAR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(0x344, (val))

/* Clear the tx_underrun_interrupt. */
#define GP_WB_SPI_SL_CLEAR_TX_UNDERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x344, 0x01)

#define GP_WB_SET_SPI_SL_CLEAR_TX_UNDERRUN_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the rx_overrun_interrupt. */
#define GP_WB_SPI_SL_CLEAR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x344, 0x02)

#define GP_WB_SET_SPI_SL_CLEAR_RX_OVERRUN_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/***************************
 * layout: i2c_sl
 ***************************/

/* TX data FIFO. Data to be transmitted to the master. The FIFO is kept cleared between STOP and START condition. */
#define GP_WB_WRITE_I2C_SL_TX_DATA(val) do { \
          GP_WB_WRITE_U8(0x360, (val)); \
        } while (0)


/* RX data FIFO. Data received from the master. The FIFO is kept cleared between STOP and START condition. */
#define GP_WB_READ_I2C_SL_RX_DATA() \
        GP_WB_READ_U8(0x361)


/* I2C slave address */
#define GP_WB_READ_I2C_SL_SLAVE_ADDRESS() \
        GP_WB_READ_U16(0x362)

#define GP_WB_WRITE_I2C_SL_SLAVE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03FF); \
          GP_WB_WRITE_U16(0x362, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_SL_CONFIG() \
        GP_WB_READ_U8(0x364)

#define GP_WB_WRITE_I2C_SL_CONFIG(val) \
      GP_WB_WRITE_U8(0x364, (val))

/* Enable clock stretching by the slave. */
#define GP_WB_READ_I2C_SL_SCL_STRETCH_EN() \
        GP_WB_READ_U1(0x364, 0)

#define GP_WB_GET_I2C_SL_SCL_STRETCH_EN_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_I2C_SL_SCL_STRETCH_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x364, 0, (val)); \
        } while (0)

#define GP_WB_SET_I2C_SL_SCL_STRETCH_EN_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable slave selection via the general call address. */
#define GP_WB_READ_I2C_SL_ACCEPT_GENERAL_CALL() \
        GP_WB_READ_U1(0x364, 1)

#define GP_WB_GET_I2C_SL_ACCEPT_GENERAL_CALL_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_I2C_SL_ACCEPT_GENERAL_CALL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x364, 1, (val)); \
        } while (0)

#define GP_WB_SET_I2C_SL_ACCEPT_GENERAL_CALL_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Sets the pinmap for the sda pin - remark that only mappings a to b are valid mappings */
#define GP_WB_READ_I2C_SL_SDA_PINMAP() \
        ((GP_WB_READ_U8(0x364) >> 2) & 0x03)

#define GP_WB_GET_I2C_SL_SDA_PINMAP_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_I2C_SL_SDA_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x364, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_I2C_SL_SDA_PINMAP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x33; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Sets the pinmap for the sclk pin - remark that only mappings a to b are valid mappings */
#define GP_WB_READ_I2C_SL_SCLK_PINMAP() \
        ((GP_WB_READ_U8(0x364) >> 4) & 0x03)

#define GP_WB_GET_I2C_SL_SCLK_PINMAP_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_I2C_SL_SCLK_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x364, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_I2C_SL_SCLK_PINMAP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_SL_STATUS() \
        GP_WB_READ_U16(0x366)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is set when TX data is ready to accept new bytes. */
#define GP_WB_READ_I2C_SL_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x366, 0)

#define GP_WB_GET_I2C_SL_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_I2C_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x366, 1)

#define GP_WB_GET_I2C_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for SCL stretching ongoing. The interrupt is active when SCL is being stretched by the slave. SCL stretching occurs when scl_stretch_en = '1', the slave has been successfully addressed in read direction, and the tx_data FIFO is empty. This interrupt can be used to trigger writes to tx_data. */
#define GP_WB_READ_I2C_SL_UNMASKED_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(0x366, 2)

#define GP_WB_GET_I2C_SL_UNMASKED_TX_STRETCH_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a START condition on the I2C bus. Set when a START or a repeated START condition is detected. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_START_INTERRUPT() \
        GP_WB_READ_U1(0x366, 3)

#define GP_WB_GET_I2C_SL_UNMASKED_START_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a STOP condition on the I2C bus. Set when the STOP condition is detected. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_STOP_INTERRUPT() \
        GP_WB_READ_U1(0x366, 4)

#define GP_WB_GET_I2C_SL_UNMASKED_STOP_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a SLAD event (slave addressed). Set when this slave has been (re-)selected or upon a general call. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_SLAD_INTERRUPT() \
        GP_WB_READ_U1(0x366, 5)

#define GP_WB_GET_I2C_SL_UNMASKED_SLAD_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of the RnW bit of the last successful slave addressing. When 0, this indicated master-to-slave direction. When 0, this indicated slave-to-master direction. The flag is updated on each slad event. */
#define GP_WB_READ_I2C_SL_READ_FLAG() \
        GP_WB_READ_U1(0x366, 6)

#define GP_WB_GET_I2C_SL_READ_FLAG_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status of the address match of the last successful slave addressing . When 0, the slave was selected by its own address. When 1, the slave was selected by the general call address (= all 0).  The flag is updated on each slad event. */
#define GP_WB_READ_I2C_SL_GENERAL_CALL_FLAG() \
        GP_WB_READ_U1(0x366, 7)

#define GP_WB_GET_I2C_SL_GENERAL_CALL_FLAG_FROM_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)

/* When 1, an I2C transfer is busy  Set upon a START event, cleared upon a STOP event. */
#define GP_WB_READ_I2C_SL_BUSY() \
        GP_WB_READ_U1(0x367, 0)

#define GP_WB_GET_I2C_SL_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 8) & 0x01)

/* When 1, the slave is currently selected, an I2C transfer is busy.  Set upon a SLAD event, cleared upon a STOP event. */
#define GP_WB_READ_I2C_SL_BUSY_SLAD() \
        GP_WB_READ_U1(0x367, 1)

#define GP_WB_GET_I2C_SL_BUSY_SLAD_FROM_STATUS(tmp) \
        (((tmp) >> 9) & 0x01)


#define GP_WB_WRITE_I2C_SL_CLEAR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(0x368, (val))

/* Clear the START condition interrupt. */
#define GP_WB_I2C_SL_CLEAR_START_INTERRUPT() \
        GP_WB_WRITE_U8(0x368, 0x01)

#define GP_WB_SET_I2C_SL_CLEAR_START_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the STOP condition interrupt. */
#define GP_WB_I2C_SL_CLEAR_STOP_INTERRUPT() \
        GP_WB_WRITE_U8(0x368, 0x02)

#define GP_WB_SET_I2C_SL_CLEAR_STOP_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the SLAD condition interrupt. */
#define GP_WB_I2C_SL_CLEAR_SLAD_INTERRUPT() \
        GP_WB_WRITE_U8(0x368, 0x04)

#define GP_WB_SET_I2C_SL_CLEAR_SLAD_INTERRUPT_TO_CLEAR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: pwm
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_CONFIG() \
        GP_WB_READ_U16(0x380)

#define GP_WB_WRITE_PWM_CONFIG(val) \
      GP_WB_WRITE_U16(0x380, (val))

/* Enables the prescaler to count. Disabling the prescaler, allows to alter the overall configuration in a clean way. */
#define GP_WB_READ_PWM_PRESCALER_ENABLE() \
        GP_WB_READ_U1(0x380, 0)

#define GP_WB_GET_PWM_PRESCALER_ENABLE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PWM_PRESCALER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x380, 0, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PRESCALER_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x777E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When set to 1, the next threshold fifo works in 16-bit word mode. In this mode, writing the next_threshold property, pushes an entry in the FIFO. When set to 0, the next threshold fifo works in byte mode. In this mode, writing the next_threshold_0 property pushes an entry in the fifo. */
#define GP_WB_READ_PWM_NEXT_THRESHOLD_FIFO_SIZE() \
        GP_WB_READ_U1(0x380, 1)

#define GP_WB_GET_PWM_NEXT_THRESHOLD_FIFO_SIZE_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PWM_NEXT_THRESHOLD_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x380, 1, (val)); \
        } while (0)

#define GP_WB_SET_PWM_NEXT_THRESHOLD_FIFO_SIZE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x777D; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* When set to 0, the timestamps fifo works in 8-bit byte mode. In this mode, reading the timestamp_main_0 property, pops an entry from the FIFO. When set to 1, the timestamp fifo works in 16-bit word mode, reading timestamp_main pops the fifo entry. When set to 2, 24 bit word mode is used, reading timestamp pops the entry. */
#define GP_WB_READ_PWM_TIMESTAMP_FIFO_SIZE() \
        ((GP_WB_READ_U8(0x380) >> 2) & 0x03)

#define GP_WB_GET_PWM_TIMESTAMP_FIFO_SIZE_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PWM_TIMESTAMP_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x380, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PWM_TIMESTAMP_FIFO_SIZE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x7773; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Enables the up/down mode */
#define GP_WB_READ_PWM_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(0x380, 4)

#define GP_WB_GET_PWM_UP_DOWN_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PWM_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x380, 4, (val)); \
        } while (0)

#define GP_WB_SET_PWM_UP_DOWN_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x776F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Enables the timestamp functinality. */
#define GP_WB_READ_PWM_TIMESTAMP_ENABLE() \
        GP_WB_READ_U1(0x380, 5)

#define GP_WB_GET_PWM_TIMESTAMP_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PWM_TIMESTAMP_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x380, 5, (val)); \
        } while (0)

#define GP_WB_SET_PWM_TIMESTAMP_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x775F; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Automatically perform a logical shift on the 'threshold update on carrier counter wrap' value, on each carrier counter wrap. */
#define GP_WB_READ_PWM_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(0x380, 6)

#define GP_WB_GET_PWM_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PWM_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x380, 6, (val)); \
        } while (0)

#define GP_WB_SET_PWM_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x773F; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* The amount of timestamp input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp_stable_low_power)-1 */
#define GP_WB_READ_PWM_TIMESTAMP_STABLE_LOW_POWER() \
        (GP_WB_READ_U8(0x381) & 0x07)

#define GP_WB_GET_PWM_TIMESTAMP_STABLE_LOW_POWER_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_PWM_TIMESTAMP_STABLE_LOW_POWER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x381, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWM_TIMESTAMP_STABLE_LOW_POWER_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x707F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* The amount of timestamp input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp_stable_high_power)-1 */
#define GP_WB_READ_PWM_TIMESTAMP_STABLE_HIGH_POWER() \
        ((GP_WB_READ_U8(0x381) >> 4) & 0x07)

#define GP_WB_GET_PWM_TIMESTAMP_STABLE_HIGH_POWER_FROM_CONFIG(tmp) \
        (((tmp) >> 12) & 0x07)

#define GP_WB_WRITE_PWM_TIMESTAMP_STABLE_HIGH_POWER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x381, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWM_TIMESTAMP_STABLE_HIGH_POWER_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U8(0x382)

#define GP_WB_WRITE_PWM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) \
      GP_WB_WRITE_U8(0x382, (val))

/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm 0. */
#define GP_WB_READ_PWM_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(0x382, 0)

#define GP_WB_GET_PWM_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PWM_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x382, 0, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm 1. */
#define GP_WB_READ_PWM_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(0x382, 1)

#define GP_WB_GET_PWM_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PWM_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x382, 1, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm 2. */
#define GP_WB_READ_PWM_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(0x382, 2)

#define GP_WB_GET_PWM_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PWM_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x382, 2, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm 3. */
#define GP_WB_READ_PWM_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(0x382, 3)

#define GP_WB_GET_PWM_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PWM_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x382, 3, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_IO_CONFIG() \
        GP_WB_READ_U32(0x384)

#define GP_WB_WRITE_PWM_IO_CONFIG(val) \
      GP_WB_WRITE_U32(0x384, (val))

/* Sets the drive type for the output of pwm 0 */
#define GP_WB_READ_PWM_PWM0_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x384, 0)

#define GP_WB_GET_PWM_PWM0_OUTPUT_DRIVE_FROM_IO_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PWM_PWM0_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 0, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM0_OUTPUT_DRIVE_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777FE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Sets the drive type for the output of pwm 1 */
#define GP_WB_READ_PWM_PWM1_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x384, 1)

#define GP_WB_GET_PWM_PWM1_OUTPUT_DRIVE_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PWM_PWM1_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 1, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM1_OUTPUT_DRIVE_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777FD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Sets the drive type for the output of pwm 2 */
#define GP_WB_READ_PWM_PWM2_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x384, 2)

#define GP_WB_GET_PWM_PWM2_OUTPUT_DRIVE_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PWM_PWM2_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 2, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM2_OUTPUT_DRIVE_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777FB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Sets the drive type for the output of pwm 3 */
#define GP_WB_READ_PWM_PWM3_OUTPUT_DRIVE() \
        GP_WB_READ_U1(0x384, 3)

#define GP_WB_GET_PWM_PWM3_OUTPUT_DRIVE_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PWM_PWM3_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 3, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM3_OUTPUT_DRIVE_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777F7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Inverts the output of pwm 0 */
#define GP_WB_READ_PWM_PWM0_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x384, 4)

#define GP_WB_GET_PWM_PWM0_OUTPUT_INVERT_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PWM_PWM0_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 4, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM0_OUTPUT_INVERT_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777EF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Inverts the output  of pwm 1 */
#define GP_WB_READ_PWM_PWM1_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x384, 5)

#define GP_WB_GET_PWM_PWM1_OUTPUT_INVERT_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PWM_PWM1_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 5, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM1_OUTPUT_INVERT_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777DF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Inverts the output  of pwm 2 */
#define GP_WB_READ_PWM_PWM2_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x384, 6)

#define GP_WB_GET_PWM_PWM2_OUTPUT_INVERT_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PWM_PWM2_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 6, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM2_OUTPUT_INVERT_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x077777BF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Inverts the output  of pwm 3 */
#define GP_WB_READ_PWM_PWM3_OUTPUT_INVERT() \
        GP_WB_READ_U1(0x384, 7)

#define GP_WB_GET_PWM_PWM3_OUTPUT_INVERT_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PWM_PWM3_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x384, 7, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM3_OUTPUT_INVERT_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0777777F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Sets the pin map for the output of pwm 0 */
#define GP_WB_READ_PWM_PWM0_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x385) & 0x07)

#define GP_WB_GET_PWM_PWM0_OUTPUT_PINMAP_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_PWM_PWM0_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x385, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM0_OUTPUT_PINMAP_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x077770FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Sets the pin map for the output of pwm 1 */
#define GP_WB_READ_PWM_PWM1_OUTPUT_PINMAP() \
        ((GP_WB_READ_U8(0x385) >> 4) & 0x07)

#define GP_WB_GET_PWM_PWM1_OUTPUT_PINMAP_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 12) & 0x07)

#define GP_WB_WRITE_PWM_PWM1_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x385, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWM_PWM1_OUTPUT_PINMAP_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x077707FF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Sets the pin map for the output of pwm 2 */
#define GP_WB_READ_PWM_PWM2_OUTPUT_PINMAP() \
        (GP_WB_READ_U8(0x386) & 0x07)

#define GP_WB_GET_PWM_PWM2_OUTPUT_PINMAP_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 16) & 0x07)

#define GP_WB_WRITE_PWM_PWM2_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x386, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PWM2_OUTPUT_PINMAP_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x077077FF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Sets the pin map for the output of pwm 3 */
#define GP_WB_READ_PWM_PWM3_OUTPUT_PINMAP() \
        ((GP_WB_READ_U8(0x386) >> 4) & 0x07)

#define GP_WB_GET_PWM_PWM3_OUTPUT_PINMAP_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 20) & 0x07)

#define GP_WB_WRITE_PWM_PWM3_OUTPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x386, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWM_PWM3_OUTPUT_PINMAP_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x070777FF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Sets the pin map for the input of timestamp */
#define GP_WB_READ_PWM_TIMESTAMP_INPUT_PINMAP() \
        GP_WB_READ_U8(0x387)

#define GP_WB_GET_PWM_TIMESTAMP_INPUT_PINMAP_FROM_IO_CONFIG(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_PWM_TIMESTAMP_INPUT_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x387, (val)); \
        } while (0)

#define GP_WB_SET_PWM_TIMESTAMP_INPUT_PINMAP_TO_IO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x007777FF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* The main counter takes the value set in this register, when main_counter_update is triggered */
#define GP_WB_READ_PWM_NEXT_MAIN_COUNTER() \
        GP_WB_READ_U16(0x388)

#define GP_WB_WRITE_PWM_NEXT_MAIN_COUNTER(val) do { \
          GP_WB_WRITE_U16(0x388, (val)); \
        } while (0)


#define GP_WB_WRITE_PWM_NEXT_THRESHOLD_PB(val) \
      GP_WB_WRITE_U16(0x38a, (val))

/* The LSB of the next threshold */
#define GP_WB_WRITE_PWM_NEXT_THRESHOLD_0(val) do { \
          GP_WB_WRITE_U8(0x38a, (val)); \
        } while (0)

#define GP_WB_SET_PWM_NEXT_THRESHOLD_0_TO_NEXT_THRESHOLD_PB(tmp, val) do { \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* The next threshold */
#define GP_WB_WRITE_PWM_NEXT_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(0x38a, (val)); \
        } while (0)

#define GP_WB_SET_PWM_NEXT_THRESHOLD_TO_NEXT_THRESHOLD_PB(tmp, val) do { \
          (tmp) &= 0x0000; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_COUNTER_WRAP_POWER() \
        GP_WB_READ_U8(0x38c)

#define GP_WB_WRITE_PWM_COUNTER_WRAP_POWER(val) \
      GP_WB_WRITE_U8(0x38c, (val))

/* The maximal value the prescaler counter reaches before wrapping back to zero is (2**prescaler_counter_wrap_power)-1 */
#define GP_WB_READ_PWM_PRESCALER_COUNTER_WRAP_POWER() \
        (GP_WB_READ_U8(0x38c) & 0x07)

#define GP_WB_GET_PWM_PRESCALER_COUNTER_WRAP_POWER_FROM_COUNTER_WRAP_POWER(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWM_PRESCALER_COUNTER_WRAP_POWER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x38c, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWM_PRESCALER_COUNTER_WRAP_POWER_TO_COUNTER_WRAP_POWER(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The maximal value the carrier counter reaches before wrapping back to zero is (2**carrier_counter_wrap_power)-1 */
#define GP_WB_READ_PWM_CARRIER_COUNTER_WRAP_POWER() \
        ((GP_WB_READ_U8(0x38c) >> 4) & 0x07)

#define GP_WB_GET_PWM_CARRIER_COUNTER_WRAP_POWER_FROM_COUNTER_WRAP_POWER(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWM_CARRIER_COUNTER_WRAP_POWER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x38c, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWM_CARRIER_COUNTER_WRAP_POWER_TO_COUNTER_WRAP_POWER(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* The maximal value the carrier counter reaches before wrapping back to zero is main_counter_wrap_value */
#define GP_WB_READ_PWM_MAIN_COUNTER_WRAP_VALUE() \
        GP_WB_READ_U16(0x38e)

#define GP_WB_WRITE_PWM_MAIN_COUNTER_WRAP_VALUE(val) do { \
          GP_WB_WRITE_U16(0x38e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_UNMASKED_INTERRUPT() \
        GP_WB_READ_U16(0x390)

/* The unmasked interrupt status of the main counter wrap interrupt */
#define GP_WB_READ_PWM_UNMASKED_MAIN_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x390, 0)

#define GP_WB_GET_PWM_UNMASKED_MAIN_COUNTER_WRAP_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the carrier counter wrap interrupt */
#define GP_WB_READ_PWM_UNMASKED_CARRIER_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x390, 1)

#define GP_WB_GET_PWM_UNMASKED_CARRIER_COUNTER_WRAP_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the next threshold underrun interrupt */
#define GP_WB_READ_PWM_UNMASKED_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x390, 2)

#define GP_WB_GET_PWM_UNMASKED_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 2) & 0x01)

/* The unmasked interrupt status of the timestamp overrun interrupt */
#define GP_WB_READ_PWM_UNMASKED_TIMESTAMP_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x390, 3)

#define GP_WB_GET_PWM_UNMASKED_TIMESTAMP_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 3) & 0x01)

/* The unmasked interrupt status of the next threshold not full interrupt */
#define GP_WB_READ_PWM_UNMASKED_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x390, 4)

#define GP_WB_GET_PWM_UNMASKED_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 4) & 0x01)

/* The unmasked interrupt status of the timestamp not empty interrupt */
#define GP_WB_READ_PWM_UNMASKED_TIMESTAMP_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x390, 5)

#define GP_WB_GET_PWM_UNMASKED_TIMESTAMP_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 5) & 0x01)

/* The unmasked interrupt status of the threshold match interrupt of pwm 0 */
#define GP_WB_READ_PWM_UNMASKED_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x391, 0)

#define GP_WB_GET_PWM_UNMASKED_PWM0_THRESHOLD_MATCH_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 8) & 0x01)

/* The unmasked interrupt status of the threshold match interrupt of pwm 1 */
#define GP_WB_READ_PWM_UNMASKED_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x391, 1)

#define GP_WB_GET_PWM_UNMASKED_PWM1_THRESHOLD_MATCH_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 9) & 0x01)

/* The unmasked interrupt status of the threshold match interrupt of pwm 2 */
#define GP_WB_READ_PWM_UNMASKED_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x391, 2)

#define GP_WB_GET_PWM_UNMASKED_PWM2_THRESHOLD_MATCH_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 10) & 0x01)

/* The unmasked interrupt status of the threshold match interrupt of pwm 3 */
#define GP_WB_READ_PWM_UNMASKED_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x391, 3)

#define GP_WB_GET_PWM_UNMASKED_PWM3_THRESHOLD_MATCH_INTERRUPT_FROM_UNMASKED_INTERRUPT(tmp) \
        (((tmp) >> 11) & 0x01)


/* The current value of the prescaler counter */
#define GP_WB_READ_PWM_PRESCALER_COUNTER() \
        GP_WB_READ_U8(0x392)


/* The current value of the main counter */
#define GP_WB_READ_PWM_MAIN_COUNTER() \
        GP_WB_READ_U16(0x394)


/* The current value of the carrier counter */
#define GP_WB_READ_PWM_CARRIER_COUNTER() \
        GP_WB_READ_U8(0x396)


/* The current value of the threshold of pwm 0 */
#define GP_WB_READ_PWM_PWM0_THRESHOLD() \
        GP_WB_READ_U16(0x398)


/* The current value of the threshold of pwm 1 */
#define GP_WB_READ_PWM_PWM1_THRESHOLD() \
        GP_WB_READ_U16(0x39a)


/* The current value of the threshold of pwm 2 */
#define GP_WB_READ_PWM_PWM2_THRESHOLD() \
        GP_WB_READ_U16(0x39c)


/* The current value of the threshold of pwm 3 */
#define GP_WB_READ_PWM_PWM3_THRESHOLD() \
        GP_WB_READ_U16(0x39e)


/* The current value of the timestamp input */
#define GP_WB_READ_PWM_TIMESTAMP_INPUT() \
        GP_WB_READ_U1(0x3a0, 0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWM_TIMESTAMP() \
        GP_WB_READ_U24(0x3a2)

/* The LSB of the timestamp of the main counter */
#define GP_WB_READ_PWM_TIMESTAMP_MAIN_0() \
        GP_WB_READ_U8(0x3a2)

#define GP_WB_GET_PWM_TIMESTAMP_MAIN_0_FROM_TIMESTAMP(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp of the main counter */
#define GP_WB_READ_PWM_TIMESTAMP_MAIN() \
        GP_WB_READ_U16(0x3a2)

#define GP_WB_GET_PWM_TIMESTAMP_MAIN_FROM_TIMESTAMP(tmp) \
        ((tmp) & 0xFFFF)

/* The (24-bit) timestamp of main counter (bit 0 to 15) and carrier counter (bit 16 to 22), combined with the correspoding value of the input (bit 23). */
#define GP_WB_READ_PWM_TIMESTAMP() \
        GP_WB_READ_U24(0x3a2)

#define GP_WB_GET_PWM_TIMESTAMP_FROM_TIMESTAMP(tmp) \
        ((tmp) & 0xFFFFFF)

/* The timestamp of the carrier counter */
#define GP_WB_READ_PWM_TIMESTAMP_CARRIER() \
        (GP_WB_READ_U8(0x3a4) & 0x7F)

#define GP_WB_GET_PWM_TIMESTAMP_CARRIER_FROM_TIMESTAMP(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp is taken */
#define GP_WB_READ_PWM_TIMESTAMP_INPUT_ON_PREVIOUS_UPDATE() \
        GP_WB_READ_U1(0x3a4, 7)

#define GP_WB_GET_PWM_TIMESTAMP_INPUT_ON_PREVIOUS_UPDATE_FROM_TIMESTAMP(tmp) \
        (((tmp) >> 23) & 0x01)


#define GP_WB_WRITE_PWM_CONTROL(val) \
      GP_WB_WRITE_U8(0x3a5, (val))

/* Resets the prescaler counter to 0. */
#define GP_WB_PWM_PRESCALER_COUNTER_RESET() \
        GP_WB_WRITE_U8(0x3a5, 0x01)

#define GP_WB_SET_PWM_PRESCALER_COUNTER_RESET_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Updates the main counter with the next main counter */
#define GP_WB_PWM_MAIN_COUNTER_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x02)

#define GP_WB_SET_PWM_MAIN_COUNTER_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets the carrier counter to 0. */
#define GP_WB_PWM_CARRIER_COUNTER_RESET() \
        GP_WB_WRITE_U8(0x3a5, 0x04)

#define GP_WB_SET_PWM_CARRIER_COUNTER_RESET_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Updates the timestamp with the current value main counter */
#define GP_WB_PWM_TIMESTAMP_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x08)

#define GP_WB_SET_PWM_TIMESTAMP_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Updates the threshold with the next threshold of pwm 0 */
#define GP_WB_PWM_PWM0_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x10)

#define GP_WB_SET_PWM_PWM0_THRESHOLD_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Updates the threshold with the next threshold of pwm 1 */
#define GP_WB_PWM_PWM1_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x20)

#define GP_WB_SET_PWM_PWM1_THRESHOLD_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Updates the threshold with the next threshold of pwm 2 */
#define GP_WB_PWM_PWM2_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x40)

#define GP_WB_SET_PWM_PWM2_THRESHOLD_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Updates the threshold with the next threshold of pwm 3 */
#define GP_WB_PWM_PWM3_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(0x3a5, 0x80)

#define GP_WB_SET_PWM_PWM3_THRESHOLD_UPDATE_TO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


#define GP_WB_WRITE_PWM_CLR_INTERRUPT(val) \
      GP_WB_WRITE_U8(0x3a6, (val))

/* Clears the main counter wrap interrupt */
#define GP_WB_PWM_CLR_MAIN_COUNTER_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x01)

#define GP_WB_SET_PWM_CLR_MAIN_COUNTER_WRAP_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clears the carrier counter wrap interrupt */
#define GP_WB_PWM_CLR_CARRIER_COUNTER_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x02)

#define GP_WB_SET_PWM_CLR_CARRIER_COUNTER_WRAP_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clears the next threshold underrun interrupt */
#define GP_WB_PWM_CLR_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x04)

#define GP_WB_SET_PWM_CLR_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clears the timestamp overrun interrupt */
#define GP_WB_PWM_CLR_TIMESTAMP_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x08)

#define GP_WB_SET_PWM_CLR_TIMESTAMP_OVERRUN_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Clears the threshold match interrupt of pwm 0 */
#define GP_WB_PWM_CLR_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x10)

#define GP_WB_SET_PWM_CLR_PWM0_THRESHOLD_MATCH_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Clears the threshold match interrupt of pwm 1 */
#define GP_WB_PWM_CLR_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x20)

#define GP_WB_SET_PWM_CLR_PWM1_THRESHOLD_MATCH_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Clears the threshold match interrupt of pwm 2 */
#define GP_WB_PWM_CLR_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x40)

#define GP_WB_SET_PWM_CLR_PWM2_THRESHOLD_MATCH_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Clears the threshold match interrupt of pwm 3 */
#define GP_WB_PWM_CLR_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(0x3a6, 0x80)

#define GP_WB_SET_PWM_CLR_PWM3_THRESHOLD_MATCH_INTERRUPT_TO_CLR_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

/***************************
 * layout: dma
 ***************************/

/* Start address for the source buffer to be copied from. When using word mode this HAS to be an even address */
#define GP_WB_READ_DMA_SRC_START_ADDR() \
        GP_WB_READ_U24(0x3c0)

#define GP_WB_WRITE_DMA_SRC_START_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x3c0, (val)); \
        } while (0)


/* Start address for the destination buffer to be copied to. When using word mode this HAS to be an even address */
#define GP_WB_READ_DMA_DEST_START_ADDR() \
        GP_WB_READ_U24(0x3c4)

#define GP_WB_WRITE_DMA_DEST_START_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x3c4, (val)); \
        } while (0)


/* Size of the source buffer for (uses circular buffer approach by default), buffer_size=n_bytes-1 (if word_mode=1, buffer_size=n_bytes-2) */
#define GP_WB_READ_DMA_SRC_BUFFER_SIZE() \
        GP_WB_READ_U8(0x3c7)

#define GP_WB_WRITE_DMA_SRC_BUFFER_SIZE(val) do { \
          GP_WB_WRITE_U8(0x3c7, (val)); \
        } while (0)


/* Size of the  destination buffer for (uses circular buffer approach by default), buffer_size=n_bytes-1 (if word_mode=1, buffer_size=n_bytes-2) */
#define GP_WB_READ_DMA_DEST_BUFFER_SIZE() \
        GP_WB_READ_U8(0x3c8)

#define GP_WB_WRITE_DMA_DEST_BUFFER_SIZE(val) do { \
          GP_WB_WRITE_U8(0x3c8, (val)); \
        } while (0)


/* Threshold to be used for generating an almost empty interrupt on the source buffer */
#define GP_WB_READ_DMA_SRC_BUFFER_ALMOST_EMPTY_THRESHOLD() \
        GP_WB_READ_U8(0x3c9)

#define GP_WB_WRITE_DMA_SRC_BUFFER_ALMOST_EMPTY_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(0x3c9, (val)); \
        } while (0)


/* Threshold to be used for generating an almost full interrupt on the destination buffer */
#define GP_WB_READ_DMA_DEST_BUFFER_ALMOST_FULL_THRESHOLD() \
        GP_WB_READ_U8(0x3ca)

#define GP_WB_WRITE_DMA_DEST_BUFFER_ALMOST_FULL_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(0x3ca, (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMA_BUFFER_PTR_VALUE() \
        GP_WB_READ_U8(0x3cb)

#define GP_WB_WRITE_DMA_BUFFER_PTR_VALUE(val) do { \
          GP_WB_WRITE_U8(0x3cb, (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMA_BUFFER_PTR_WRAP_VALUE() \
        GP_WB_READ_U1(0x3cc, 0)

#define GP_WB_WRITE_DMA_BUFFER_PTR_WRAP_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x3cc, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMA_CONFIG() \
        GP_WB_READ_U8(0x3cd)

#define GP_WB_WRITE_DMA_CONFIG(val) \
      GP_WB_WRITE_U8(0x3cd, (val))

/* dma supports 8/16 bit mem access. 16bit mode (=word_mode) is selected when word_mode=true else 8bit mode (=byte_mode) is selected */
#define GP_WB_READ_DMA_WORD_MODE() \
        GP_WB_READ_U1(0x3cd, 0)

#define GP_WB_GET_DMA_WORD_MODE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_DMA_WORD_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x3cd, 0, (val)); \
        } while (0)

#define GP_WB_SET_DMA_WORD_MODE_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMA_CPY_TRIGGER_SRC_SELECT() \
        ((GP_WB_READ_U8(0x3cd) >> 1) & 0x0F)

#define GP_WB_GET_DMA_CPY_TRIGGER_SRC_SELECT_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_DMA_CPY_TRIGGER_SRC_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x3cd, 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMA_CPY_TRIGGER_SRC_SELECT_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x21; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* regmap cpy trigger overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMA_CPY_TRIGGER_BY_REGMAP() \
        GP_WB_READ_U1(0x3cd, 5)

#define GP_WB_GET_DMA_CPY_TRIGGER_BY_REGMAP_FROM_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_DMA_CPY_TRIGGER_BY_REGMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x3cd, 5, (val)); \
        } while (0)

#define GP_WB_SET_DMA_CPY_TRIGGER_BY_REGMAP_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


#define GP_WB_WRITE_DMA_BUFFER_PTR_CONTROL(val) \
      GP_WB_WRITE_U8(0x3ce, (val))

/* Sets the internal source buffer write pointer by buffer_ptr_value / wrap value.  Provides atomic way for updating src buffer write pointer */
#define GP_WB_DMA_SET_SRC_WRITE_PTR() \
        GP_WB_WRITE_U8(0x3ce, 0x01)

#define GP_WB_SET_DMA_SET_SRC_WRITE_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal source buffer read pointer by buffer_ptr_value / wrap value.  Provides atomic way to initialize the source read pointer */
#define GP_WB_DMA_SET_SRC_READ_PTR() \
        GP_WB_WRITE_U8(0x3ce, 0x02)

#define GP_WB_SET_DMA_SET_SRC_READ_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Sets the internal destination buffer write pointer by buffer_ptr_value / wrap value. Provides atomic way to initialize the dest buffer write pointer */
#define GP_WB_DMA_SET_DEST_WRITE_PTR() \
        GP_WB_WRITE_U8(0x3ce, 0x04)

#define GP_WB_SET_DMA_SET_DEST_WRITE_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Sets the internal destination buffer read pointer by buffer_ptr_value / wrap value. Provides atomic way for updating dest buffer read pointer */
#define GP_WB_DMA_SET_DEST_READ_PTR() \
        GP_WB_WRITE_U8(0x3ce, 0x08)

#define GP_WB_SET_DMA_SET_DEST_READ_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Resets all buffer pointers to 0 */
#define GP_WB_DMA_RESET_POINTERS() \
        GP_WB_WRITE_U8(0x3ce, 0x10)

#define GP_WB_SET_DMA_RESET_POINTERS_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMA_STATUS() \
        GP_WB_READ_U8(0x3cf)

/* Indicates a memory acces failed during dma operation. This STOPS the dma operation. Dma can only be unlocked by clearing this interrupt */
#define GP_WB_READ_DMA_UNMASKED_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(0x3cf, 0)

#define GP_WB_GET_DMA_UNMASKED_CPY_ERR_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that the source buffer was empty while trying to read from it */
#define GP_WB_READ_DMA_UNMASKED_SRC_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x3cf, 1)

#define GP_WB_GET_DMA_UNMASKED_SRC_UNDERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the dest buffer was full while trying to write to it */
#define GP_WB_READ_DMA_UNMASKED_DEST_OVERFLOW_INTERRUPT() \
        GP_WB_READ_U1(0x3cf, 2)

#define GP_WB_GET_DMA_UNMASKED_DEST_OVERFLOW_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that the src buffer filling level is below threshold */
#define GP_WB_READ_DMA_UNMASKED_SRC_ALMOST_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x3cf, 3)

#define GP_WB_GET_DMA_UNMASKED_SRC_ALMOST_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that the destination buffer filling level is above threshold */
#define GP_WB_READ_DMA_UNMASKED_DEST_ALMOST_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x3cf, 4)

#define GP_WB_GET_DMA_UNMASKED_DEST_ALMOST_FULL_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Toggle signal that is toggled each time the dma internal src_read_ptr wraps around (For underrun detection) */
#define GP_WB_READ_DMA_SRC_READ_PTR_WRAP() \
        GP_WB_READ_U1(0x3cf, 5)

#define GP_WB_GET_DMA_SRC_READ_PTR_WRAP_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Toggle signal that is toggled each time the dma internal dest_write_ptr wraps around (For overflow detection) */
#define GP_WB_READ_DMA_DEST_WRITE_PTR_WRAP() \
        GP_WB_READ_U1(0x3cf, 6)

#define GP_WB_GET_DMA_DEST_WRITE_PTR_WRAP_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)


#define GP_WB_WRITE_DMA_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(0x3d0, (val))

/* clears the copy err interrupt. This is really needed for the dma to continue when an err-or occurred */
#define GP_WB_DMA_CLR_CPY_ERR_INTERRUPT() \
        GP_WB_WRITE_U8(0x3d0, 0x01)

#define GP_WB_SET_DMA_CLR_CPY_ERR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* clears the copyunderrun interrupt */
#define GP_WB_DMA_CLR_SRC_UNDERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(0x3d0, 0x02)

#define GP_WB_SET_DMA_CLR_SRC_UNDERRUN_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* clears the overflow interrupt */
#define GP_WB_DMA_CLR_DEST_OVERFLOW_INTERRUPT() \
        GP_WB_WRITE_U8(0x3d0, 0x04)

#define GP_WB_SET_DMA_CLR_DEST_OVERFLOW_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Actual read offset ptr that is being used internally to access the source buffer */
#define GP_WB_READ_DMA_INTERNAL_SRC_READ_PTR() \
        GP_WB_READ_U8(0x3d1)


/* Actual write offset ptr that is being used internally to access the destination buffer */
#define GP_WB_READ_DMA_INTERNAL_DEST_WRITE_PTR() \
        GP_WB_READ_U8(0x3d2)

/***************************
 * layout: rib
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_PBM_PTR_CONTROL() \
        GP_WB_READ_U8(0x400)

#define GP_WB_WRITE_RIB_PBM_PTR_CONTROL(val) \
      GP_WB_WRITE_U8(0x400, (val))

#define GP_WB_READ_RIB_RX_PBM_PTR() \
        (GP_WB_READ_U8(0x400) & 0x07)

#define GP_WB_GET_RIB_RX_PBM_PTR_FROM_PBM_PTR_CONTROL(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_RIB_RX_PBM_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x400, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_PBM_PTR_TO_PBM_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x08; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_RX_PBM_PTR_VALID() \
        GP_WB_READ_U1(0x400, 3)

#define GP_WB_GET_RIB_RX_PBM_PTR_VALID_FROM_PBM_PTR_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_RX_PBM_PTR_VALID(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x400, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_PBM_PTR_VALID_TO_PBM_PTR_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Memory pointer, pointing to the first real data byte of the received frame. */
#define GP_WB_READ_RIB_RX_PBM_DATA_PTR() \
        GP_WB_READ_U16(0x402)


/* sets the time needed for the phy/radio to go from the off state to the TX state (=ready to transmit). Delay = (off2tx_delay+1)*16us */
#define GP_WB_READ_RIB_OFF2TX_DELAY() \
        GP_WB_READ_U8(0x404)

#define GP_WB_WRITE_RIB_OFF2TX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_WRITE_U8(0x404, (val)); \
        } while (0)


/* sets the time needed for the phy/radio to go from the off state to the RX state (=ready to receive). Delay = off2rx_delay*16us */
#define GP_WB_READ_RIB_OFF2RX_DELAY() \
        GP_WB_READ_U8(0x405)

#define GP_WB_WRITE_RIB_OFF2RX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_WRITE_U8(0x405, (val)); \
        } while (0)


/* Sets the time needed to perform a single channel calibration. This includes the time needed for the radio to switch to calibration mode. delay = (cal_delay+1) * 16 us */
#define GP_WB_READ_RIB_CAL_DELAY() \
        GP_WB_READ_U8(0x406)

#define GP_WB_WRITE_RIB_CAL_DELAY(val) do { \
          GP_WB_WRITE_U8(0x406, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_ACK_CONTROL() \
        GP_WB_READ_U8(0x407)

#define GP_WB_WRITE_RIB_ACK_CONTROL(val) \
      GP_WB_WRITE_U8(0x407, (val))

/* Sets the time between the packet rx and the start of the tx ack. delay = (ack_turnaround+1)*16us. According to the spec this value should be 12 (so setting 11), but the value should compensate for internal data delay and therefore the setting 7 is the correct value. It is important to make sure that this value is always bigger than the off2tx_delay, if not the actual delay will wrap ((ack_turnaround-off2tx_delay) mod 16). For tests purposes small turnarounds can be obtained by decreasing off2tx_delay and setting ack_turnaround equal to off2tx_delay. In order for the radio to still function correctly dont_disable_radio_for_rx_to_txack should be set to 1 */
#define GP_WB_READ_RIB_ACK_TURNAROUND() \
        (GP_WB_READ_U8(0x407) & 0x0F)

#define GP_WB_GET_RIB_ACK_TURNAROUND_FROM_ACK_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RIB_ACK_TURNAROUND(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x407, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TURNAROUND_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enables a power optimisation feature, where the device stops listening for the ack if it has not seen the start of a packet in time for a complete ack to be received */
#define GP_WB_READ_RIB_ACK_TIMEOUT_ON_START() \
        GP_WB_READ_U1(0x407, 4)

#define GP_WB_GET_RIB_ACK_TIMEOUT_ON_START_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_ACK_TIMEOUT_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x407, 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TIMEOUT_ON_START_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set to 1, the radio will not be shut off between the rx packet end and the ack tx start. Instead, the radio will go through a Rx to TX transition */
#define GP_WB_READ_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK() \
        GP_WB_READ_U1(0x407, 5)

#define GP_WB_GET_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x407, 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set to 1, the radio will not be shut off between the tx packet end and the ack rx start. Instead, the radio will go through a Tx to RX transition */
#define GP_WB_READ_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK() \
        GP_WB_READ_U1(0x407, 6)

#define GP_WB_GET_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x407, 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* Sets the duration of the ack listening window from the start of an incoming packet */
#define GP_WB_READ_RIB_ACK_TIMEOUT() \
        GP_WB_READ_U8(0x408)

#define GP_WB_WRITE_RIB_ACK_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x408, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_IFS_CONTROL() \
        GP_WB_READ_U8(0x409)

#define GP_WB_WRITE_RIB_IFS_CONTROL(val) \
      GP_WB_WRITE_U8(0x409, (val))

/* Sets the minimum inter frame spacing time (= time between 2 consecutive TX) time = ifs_length * 16us */
#define GP_WB_READ_RIB_IFS_LENGTH() \
        (GP_WB_READ_U8(0x409) & 0x3F)

#define GP_WB_GET_RIB_IFS_LENGTH_FROM_IFS_CONTROL(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_IFS_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_MWRITE_U8(0x409, 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_LENGTH_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, no minimum inter frame spacing is guaranteed for packet tx after packet tx */
#define GP_WB_READ_RIB_IFS_SKIP() \
        GP_WB_READ_U1(0x409, 6)

#define GP_WB_GET_RIB_IFS_SKIP_FROM_IFS_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_IFS_SKIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x409, 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_SKIP_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set to 1, no minimum inter frame spacing is guaranteed for packet tx after ack tx */
#define GP_WB_READ_RIB_IFS_AFTER_TX_ACK_SKIP() \
        GP_WB_READ_U1(0x409, 7)

#define GP_WB_GET_RIB_IFS_AFTER_TX_ACK_SKIP_FROM_IFS_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RIB_IFS_AFTER_TX_ACK_SKIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x409, 7, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_AFTER_TX_ACK_SKIP_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_GEN_OPTIONS_0() \
        GP_WB_READ_U8(0x40a)

#define GP_WB_WRITE_RIB_GEN_OPTIONS_0(val) \
      GP_WB_WRITE_U8(0x40a, (val))

#define GP_WB_READ_RIB_BYPASS_TX_DELAY() \
        GP_WB_READ_U1(0x40a, 0)

#define GP_WB_GET_RIB_BYPASS_TX_DELAY_FROM_GEN_OPTIONS_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_BYPASS_TX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40a, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_BYPASS_TX_DELAY_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* power optimisation feature, that will disable the radio because we can't receive anything anyway ( having no pbm is clearly not wanted behavior !) */
#define GP_WB_READ_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM() \
        GP_WB_READ_U1(0x40a, 1)

#define GP_WB_GET_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40a, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when enabled, a pip event will trigger a restart of the receiver */
#define GP_WB_READ_RIB_RESTART_PACKET_DET_WHEN_PIP() \
        GP_WB_READ_U1(0x40a, 2)

#define GP_WB_GET_RIB_RESTART_PACKET_DET_WHEN_PIP_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_RESTART_PACKET_DET_WHEN_PIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40a, 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RESTART_PACKET_DET_WHEN_PIP_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Disables the low level clockgating of the trc block */
#define GP_WB_READ_RIB_DISABLE_TRC_CLK_GATING() \
        GP_WB_READ_U1(0x40a, 3)

#define GP_WB_GET_RIB_DISABLE_TRC_CLK_GATING_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_DISABLE_TRC_CLK_GATING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40a, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DISABLE_TRC_CLK_GATING_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_RIB_GEN_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x40b, (val))

#define GP_WB_RIB_STOP_RX_WINDOW() \
        GP_WB_WRITE_U8(0x40b, 0x02)

#define GP_WB_SET_RIB_STOP_RX_WINDOW_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1C; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_RIB_RESTART_PACKET_DET() \
        GP_WB_WRITE_U8(0x40b, 0x04)

#define GP_WB_SET_RIB_RESTART_PACKET_DET_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1A; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* triggers a channel change (including the channel calibration), to the channel indicated by channel_nr on the multichannel slot indicated by channel_idx */
#define GP_WB_RIB_CHANNEL_CHANGE_REQUEST() \
        GP_WB_WRITE_U8(0x40b, 0x08)

#define GP_WB_SET_RIB_CHANNEL_CHANGE_REQUEST_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x16; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Use this to arm the drop reason latch. This clears th drop_reason_valid status */
#define GP_WB_RIB_CLR_DROP_REASON() \
        GP_WB_WRITE_U8(0x40b, 0x10)

#define GP_WB_SET_RIB_CLR_DROP_REASON_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_CHANNEL_CHANGE_CONTROL() \
        GP_WB_READ_U8(0x40c)

#define GP_WB_WRITE_RIB_CHANNEL_CHANGE_CONTROL(val) \
      GP_WB_WRITE_U8(0x40c, (val))

/* the channel that will be used for multichannel slot indicated by channel_idx, when requesting a channel change (0 ... 15) */
#define GP_WB_READ_RIB_CHANNEL_NR() \
        (GP_WB_READ_U8(0x40c) & 0x0F)

#define GP_WB_GET_RIB_CHANNEL_NR_FROM_CHANNEL_CHANGE_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RIB_CHANNEL_NR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x40c, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_CHANNEL_NR_TO_CHANNEL_CHANGE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* the multichannel slot that of which the channel will change, when requesting a channel change. Slots 0 to 5 are packet detection slots. Slot 6 is a TX only slot and should not be set throught the regmap channel change request interface (use tx pbm instead) */
#define GP_WB_READ_RIB_CHANNEL_IDX() \
        ((GP_WB_READ_U8(0x40c) >> 4) & 0x07)

#define GP_WB_GET_RIB_CHANNEL_IDX_FROM_CHANNEL_CHANGE_CONTROL(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_RIB_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x40c, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_RIB_CHANNEL_IDX_TO_CHANNEL_CHANGE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE() \
        GP_WB_READ_U8(0x40d)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE(val) \
      GP_WB_WRITE_U8(0x40d, (val))

/* enables listening for channel idx 0 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH0() \
        GP_WB_READ_U1(0x40d, 0)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH0_FROM_RX_ON_WHEN_IDLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH0_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enables listening for the selected channels */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH() \
        (GP_WB_READ_U8(0x40d) & 0x3F)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH_FROM_RX_ON_WHEN_IDLE(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_MWRITE_U8(0x40d, 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          (tmp) &= 0x00; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enables listening for channel idx 1 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH1() \
        GP_WB_READ_U1(0x40d, 1)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH1_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH1_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enables listening for channel idx 2 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH2() \
        GP_WB_READ_U1(0x40d, 2)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH2_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH2_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enables listening for channel idx 3 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH3() \
        GP_WB_READ_U1(0x40d, 3)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH3_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH3_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* enables listening for channel idx 4 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH4() \
        GP_WB_READ_U1(0x40d, 4)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH4_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH4_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* enables listening for channel idx 5 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH5() \
        GP_WB_READ_U1(0x40d, 5)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH5_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40d, 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH5_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_OPTIONS() \
        GP_WB_READ_U8(0x40e)

#define GP_WB_WRITE_RIB_RX_OPTIONS(val) \
      GP_WB_WRITE_U8(0x40e, (val))

#define GP_WB_READ_RIB_ACK_REQUEST_DISABLE() \
        GP_WB_READ_U1(0x40e, 0)

#define GP_WB_GET_RIB_ACK_REQUEST_DISABLE_FROM_RX_OPTIONS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_ACK_REQUEST_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40e, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_REQUEST_DISABLE_TO_RX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_EN_DATA_REQ_FOR_EVERY_FRAME() \
        GP_WB_READ_U1(0x40e, 1)

#define GP_WB_GET_RIB_EN_DATA_REQ_FOR_EVERY_FRAME_FROM_RX_OPTIONS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_EN_DATA_REQ_FOR_EVERY_FRAME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x40e, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_EN_DATA_REQ_FOR_EVERY_FRAME_TO_RX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* When this bit is set to '1', frames with a bad crc will not be received in the pbm, and will be ignored by the mac completely. When this bit is set to "0", frames with a bad crc still be received in the pbm. Note however that even in latter case, the mac will ignore them for the rest (will not trigger ack, ...) */
#define GP_WB_READ_RIB_RX_FCS_CHECK_ON() \
        GP_WB_READ_U1(0x40f, 0)

#define GP_WB_WRITE_RIB_RX_FCS_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x40f, (val)); \
        } while (0)


#define GP_WB_RIB_RX_PBM_PTR_CLR() \
        GP_WB_WRITE_U8(0x410, 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_ON_REASON() \
        GP_WB_READ_U8(0x411)

/* the receiver "could" be put on because the TRC has been granted a valid PBM entry. Only this bit set is not enough to conclude that the receiver is on. */
#define GP_WB_READ_RIB_ENABLE_RX_ON() \
        GP_WB_READ_U1(0x411, 0)

#define GP_WB_GET_RIB_ENABLE_RX_ON_FROM_RX_ON_REASON(tmp) \
        ((tmp) & 0x01)

/* the receiver is ON because of the rx_on_when_idle bit */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_SET() \
        GP_WB_READ_U1(0x411, 1)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_SET_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 1) & 0x01)

/* the receive is on because the PBM entry being processed contained a GP_RX_DURATION field not equal to zero */
#define GP_WB_READ_RIB_RX_ON_RUN() \
        GP_WB_READ_U1(0x411, 2)

#define GP_WB_GET_RIB_RX_ON_RUN_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 2) & 0x01)

/* the receive is on because the cca is in progress */
#define GP_WB_READ_RIB_CCA_RUN() \
        GP_WB_READ_U1(0x411, 3)

#define GP_WB_GET_RIB_CCA_RUN_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 3) & 0x01)

/* the receive is on because the RX_ON event 0 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_0() \
        GP_WB_READ_U1(0x411, 4)

#define GP_WB_GET_RIB_ES_RX_ON_0_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 4) & 0x01)

/* the receive is on because the RX_ON event 1 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_1() \
        GP_WB_READ_U1(0x411, 5)

#define GP_WB_GET_RIB_ES_RX_ON_1_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 5) & 0x01)

/* the receive is on because the RX_ON event 2 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_2() \
        GP_WB_READ_U1(0x411, 6)

#define GP_WB_GET_RIB_ES_RX_ON_2_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 6) & 0x01)

/* the receive is on because the RX_ON event 3 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_3() \
        GP_WB_READ_U1(0x411, 7)

#define GP_WB_GET_RIB_ES_RX_ON_3_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 7) & 0x01)


/* shows the status of the rx on counter. Only valid when rx_on_run = TRUE */
#define GP_WB_READ_RIB_RX_ON_CNT() \
        GP_WB_READ_U24(0x412)


#define GP_WB_READ_RIB_CSMA_FORCE_FAIL() \
        GP_WB_READ_U1(0x415, 0)

#define GP_WB_WRITE_RIB_CSMA_FORCE_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x415, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_UNMASKED_TRC_INT_0() \
        GP_WB_READ_U8(0x416)

#define GP_WB_READ_RIB_UNMASKED_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x416, 0)

#define GP_WB_GET_RIB_UNMASKED_PBM_FULL_INTERRUPT_FROM_UNMASKED_TRC_INT_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x416, 1)

#define GP_WB_GET_RIB_UNMASKED_TX_STARTED_INTERRUPT_FROM_UNMASKED_TRC_INT_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x416, 2)

#define GP_WB_GET_RIB_UNMASKED_TX_ACK_STARTED_INTERRUPT_FROM_UNMASKED_TRC_INT_0(tmp) \
        (((tmp) >> 2) & 0x01)

/* This interrupt indicates that the phy was not ready when the mac expected it to be (check your of2rx / off2tx delay settings) */
#define GP_WB_READ_RIB_UNMASKED_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x416, 3)

#define GP_WB_GET_RIB_UNMASKED_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_UNMASKED_TRC_INT_0(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_UNMASKED_TRC_INT_1() \
        GP_WB_READ_U8(0x417)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_READ_RIB_UNMASKED_GENERIC_0_INTERRUPT() \
        GP_WB_READ_U1(0x417, 0)

#define GP_WB_GET_RIB_UNMASKED_GENERIC_0_INTERRUPT_FROM_UNMASKED_TRC_INT_1(tmp) \
        ((tmp) & 0x01)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_READ_RIB_UNMASKED_GENERIC_1_INTERRUPT() \
        GP_WB_READ_U1(0x417, 1)

#define GP_WB_GET_RIB_UNMASKED_GENERIC_1_INTERRUPT_FROM_UNMASKED_TRC_INT_1(tmp) \
        (((tmp) >> 1) & 0x01)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_READ_RIB_UNMASKED_GENERIC_2_INTERRUPT() \
        GP_WB_READ_U1(0x417, 2)

#define GP_WB_GET_RIB_UNMASKED_GENERIC_2_INTERRUPT_FROM_UNMASKED_TRC_INT_1(tmp) \
        (((tmp) >> 2) & 0x01)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_READ_RIB_UNMASKED_GENERIC_3_INTERRUPT() \
        GP_WB_READ_U1(0x417, 3)

#define GP_WB_GET_RIB_UNMASKED_GENERIC_3_INTERRUPT_FROM_UNMASKED_TRC_INT_1(tmp) \
        (((tmp) >> 3) & 0x01)


#define GP_WB_WRITE_RIB_CLEAR_TRC_INT_0(val) \
      GP_WB_WRITE_U8(0x418, (val))

#define GP_WB_RIB_CLR_PBM_FULL_INTERRUPT() \
        GP_WB_WRITE_U8(0x418, 0x01)

#define GP_WB_SET_RIB_CLR_PBM_FULL_INTERRUPT_TO_CLEAR_TRC_INT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_RIB_CLR_TX_STARTED_INTERRUPT() \
        GP_WB_WRITE_U8(0x418, 0x02)

#define GP_WB_SET_RIB_CLR_TX_STARTED_INTERRUPT_TO_CLEAR_TRC_INT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_RIB_CLR_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_WRITE_U8(0x418, 0x04)

#define GP_WB_SET_RIB_CLR_TX_ACK_STARTED_INTERRUPT_TO_CLEAR_TRC_INT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_RIB_CLR_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(0x418, 0x08)

#define GP_WB_SET_RIB_CLR_PHY_TRANSITION_NOT_DONE_INTERRUPT_TO_CLEAR_TRC_INT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_RIB_SET_CLR_GENERIC_INTERRUPTS(val) \
      GP_WB_WRITE_U8(0x419, (val))

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_CLR_GENERIC_0_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x01)

#define GP_WB_SET_RIB_CLR_GENERIC_0_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_CLR_GENERIC_1_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x02)

#define GP_WB_SET_RIB_CLR_GENERIC_1_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_CLR_GENERIC_2_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x04)

#define GP_WB_SET_RIB_CLR_GENERIC_2_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_CLR_GENERIC_3_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x08)

#define GP_WB_SET_RIB_CLR_GENERIC_3_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_SET_GENERIC_0_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x10)

#define GP_WB_SET_RIB_SET_GENERIC_0_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_SET_GENERIC_1_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x20)

#define GP_WB_SET_RIB_SET_GENERIC_1_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_SET_GENERIC_2_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x40)

#define GP_WB_SET_RIB_SET_GENERIC_2_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* generic interrupt that can be triggered by the mac filter */
#define GP_WB_RIB_SET_GENERIC_3_INTERRUPT() \
        GP_WB_WRITE_U8(0x419, 0x80)

#define GP_WB_SET_RIB_SET_GENERIC_3_INTERRUPT_TO_SET_CLR_GENERIC_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TRC_STATE_PB() \
        GP_WB_READ_U8(0x41a)

/* reflects the state of the internal TRC statemachine. This state is a good indication for what phase the packet transmission / reception is in */
#define GP_WB_READ_RIB_TRC_STATE() \
        (GP_WB_READ_U8(0x41a) & 0x1F)

#define GP_WB_GET_RIB_TRC_STATE_FROM_TRC_STATE_PB(tmp) \
        ((tmp) & 0x1F)

/* Status indicating that a channel change request is ongoing - this is also set when request was triggered but not yet serviced */
#define GP_WB_READ_RIB_CHANNEL_CHANGE_BUSY() \
        GP_WB_READ_U1(0x41a, 5)

#define GP_WB_GET_RIB_CHANNEL_CHANGE_BUSY_FROM_TRC_STATE_PB(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_DROP_REASON_PB() \
        GP_WB_READ_U8(0x41b)

/* Drop Reason:\n0 : No Drop\n1 : Worng Frame Type\n2 : Wrong Version Type\n3 : Wrong SRC PAN ID\n4 : Wrong DST PAN ID\n5 : Wrong DST Address\n6 : Wrong Address\n7 : Wrong COmmand\n3 : Wrong CRC. */
#define GP_WB_READ_RIB_RX_DROP_REASON() \
        (GP_WB_READ_U8(0x41b) & 0x0F)

#define GP_WB_GET_RIB_RX_DROP_REASON_FROM_RX_DROP_REASON_PB(tmp) \
        ((tmp) & 0x0F)

/* Indicates that a rop reason was latched. The drop reason will no longer be updated until the drop reason was cleared */
#define GP_WB_READ_RIB_DROP_REASON_VALID() \
        GP_WB_READ_U1(0x41b, 4)

#define GP_WB_GET_RIB_DROP_REASON_VALID_FROM_RX_DROP_REASON_PB(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_COEX_REQ_ENABLE() \
        GP_WB_READ_U8(0x41c)

#define GP_WB_WRITE_RIB_COEX_REQ_ENABLE(val) \
      GP_WB_WRITE_U8(0x41c, (val))

#define GP_WB_READ_RIB_RX_ON_REQ_EN() \
        GP_WB_READ_U1(0x41c, 0)

#define GP_WB_GET_RIB_RX_ON_REQ_EN_FROM_COEX_REQ_ENABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_REQ_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41c, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_REQ_EN_TO_COEX_REQ_ENABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_PACKET_RX_REQ_EN() \
        GP_WB_READ_U1(0x41c, 1)

#define GP_WB_GET_RIB_PACKET_RX_REQ_EN_FROM_COEX_REQ_ENABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_PACKET_RX_REQ_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41c, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_PACKET_RX_REQ_EN_TO_COEX_REQ_ENABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RIB_ACK_TX_REQ_EN() \
        GP_WB_READ_U1(0x41c, 2)

#define GP_WB_GET_RIB_ACK_TX_REQ_EN_FROM_COEX_REQ_ENABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_ACK_TX_REQ_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41c, 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TX_REQ_EN_TO_COEX_REQ_ENABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RIB_ES_REQ_REQ_EN() \
        GP_WB_READ_U1(0x41c, 3)

#define GP_WB_GET_RIB_ES_REQ_REQ_EN_FROM_COEX_REQ_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_ES_REQ_REQ_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41c, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ES_REQ_REQ_EN_TO_COEX_REQ_ENABLE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_COEX_PRIORITY() \
        GP_WB_READ_U8(0x41d)

#define GP_WB_WRITE_RIB_COEX_PRIORITY(val) \
      GP_WB_WRITE_U8(0x41d, (val))

#define GP_WB_READ_RIB_RX_ON_PRIO() \
        (GP_WB_READ_U8(0x41d) & 0x03)

#define GP_WB_GET_RIB_RX_ON_PRIO_FROM_COEX_PRIORITY(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RIB_RX_ON_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x41d, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_PRIO_TO_COEX_PRIORITY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_PACKET_RX_PRIO() \
        ((GP_WB_READ_U8(0x41d) >> 2) & 0x03)

#define GP_WB_GET_RIB_PACKET_RX_PRIO_FROM_COEX_PRIORITY(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_RIB_PACKET_RX_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x41d, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RIB_PACKET_RX_PRIO_TO_COEX_PRIORITY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RIB_ACK_TX_PRIO() \
        ((GP_WB_READ_U8(0x41d) >> 4) & 0x03)

#define GP_WB_GET_RIB_ACK_TX_PRIO_FROM_COEX_PRIORITY(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_RIB_ACK_TX_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x41d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TX_PRIO_TO_COEX_PRIORITY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RIB_ES_REQ_PRIO() \
        ((GP_WB_READ_U8(0x41d) >> 6) & 0x03)

#define GP_WB_GET_RIB_ES_REQ_PRIO_FROM_COEX_PRIORITY(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_RIB_ES_REQ_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x41d, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_RIB_ES_REQ_PRIO_TO_COEX_PRIORITY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_COEX_GRANT_HANDLING() \
        GP_WB_READ_U8(0x41e)

#define GP_WB_WRITE_RIB_COEX_GRANT_HANDLING(val) \
      GP_WB_WRITE_U8(0x41e, (val))

#define GP_WB_READ_RIB_DELAYED_START() \
        GP_WB_READ_U1(0x41e, 0)

#define GP_WB_GET_RIB_DELAYED_START_FROM_COEX_GRANT_HANDLING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_DELAYED_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DELAYED_START_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_CSMA_CA_HOLD() \
        GP_WB_READ_U1(0x41e, 1)

#define GP_WB_GET_RIB_CSMA_CA_HOLD_FROM_COEX_GRANT_HANDLING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_CSMA_CA_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_CSMA_CA_HOLD_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RIB_TREAT_AS_CCA_FAIL() \
        GP_WB_READ_U1(0x41e, 2)

#define GP_WB_GET_RIB_TREAT_AS_CCA_FAIL_FROM_COEX_GRANT_HANDLING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_TREAT_AS_CCA_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TREAT_AS_CCA_FAIL_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RIB_PACKET_DISABLE_PA() \
        GP_WB_READ_U1(0x41e, 3)

#define GP_WB_GET_RIB_PACKET_DISABLE_PA_FROM_COEX_GRANT_HANDLING(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_PACKET_DISABLE_PA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_PACKET_DISABLE_PA_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_RIB_ACK_SKIP() \
        GP_WB_READ_U1(0x41e, 4)

#define GP_WB_GET_RIB_ACK_SKIP_FROM_COEX_GRANT_HANDLING(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_ACK_SKIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_SKIP_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RIB_ACK_DISABLE_PA() \
        GP_WB_READ_U1(0x41e, 5)

#define GP_WB_GET_RIB_ACK_DISABLE_PA_FROM_COEX_GRANT_HANDLING(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_ACK_DISABLE_PA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x41e, 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_DISABLE_PA_TO_COEX_GRANT_HANDLING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_COEX_STATUS() \
        GP_WB_READ_U8(0x41f)

#define GP_WB_READ_RIB_REQUEST() \
        GP_WB_READ_U1(0x41f, 0)

#define GP_WB_GET_RIB_REQUEST_FROM_COEX_STATUS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RIB_PRIORITY() \
        ((GP_WB_READ_U8(0x41f) >> 1) & 0x03)

#define GP_WB_GET_RIB_PRIORITY_FROM_COEX_STATUS(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_READ_RIB_GRANTED() \
        GP_WB_READ_U1(0x41f, 3)

#define GP_WB_GET_RIB_GRANTED_FROM_COEX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)


/* Read from address PBETE + offset to obtain the PBM index where the DPS confirm/indication is stored:\n\nOFFSET    SERVICE\n0         packet TX\n1         ED scan\n2         Passive scan\n3         Active scan\n4         Orphan scan\n5         packet RX\n6         CCM Frame description\n7         CCM frame encryption\n8         AES */
#define GP_WB_READ_RIB_PBETE_DATA_IND() \
        GP_WB_READ_U8(0x420)


#define GP_WB_READ_RIB_PBETE_DATA_CNF_0() \
        GP_WB_READ_U8(0x421)


#define GP_WB_READ_RIB_PBETE_DATA_CNF_1() \
        GP_WB_READ_U8(0x422)


#define GP_WB_READ_RIB_PBETE_DATA_CNF_2() \
        GP_WB_READ_U8(0x423)


#define GP_WB_READ_RIB_PBETE_DATA_CNF_3() \
        GP_WB_READ_U8(0x424)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_0() \
        GP_WB_READ_U8(0x425)

#define GP_WB_WRITE_RIB_ETOEX_DATA_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x425, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_1() \
        GP_WB_READ_U8(0x426)

#define GP_WB_WRITE_RIB_ETOEX_DATA_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x426, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_2() \
        GP_WB_READ_U8(0x427)

#define GP_WB_WRITE_RIB_ETOEX_DATA_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x427, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_3() \
        GP_WB_READ_U8(0x428)

#define GP_WB_WRITE_RIB_ETOEX_DATA_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x428, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_4() \
        GP_WB_READ_U8(0x429)

#define GP_WB_WRITE_RIB_ETOEX_DATA_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x429, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_5() \
        GP_WB_READ_U8(0x42a)

#define GP_WB_WRITE_RIB_ETOEX_DATA_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x42a, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_6() \
        GP_WB_READ_U8(0x42b)

#define GP_WB_WRITE_RIB_ETOEX_DATA_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x42b, (val)); \
        } while (0)


/* Entry to external queue data: bits [2:0] PBM index, bits [5:3] housekeeping data */
#define GP_WB_READ_RIB_ETOEX_DATA_7() \
        GP_WB_READ_U8(0x42c)

#define GP_WB_WRITE_RIB_ETOEX_DATA_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x42c, (val)); \
        } while (0)


/* Entry to external queue read pointer (bits 2:0) and read wrap flag */
#define GP_WB_READ_RIB_ETOEX_RPTR() \
        GP_WB_READ_U8(0x42d)

#define GP_WB_WRITE_RIB_ETOEX_RPTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x42d, (val)); \
        } while (0)


/* Entry to external queue write pointer (bits 2:0) and write wrap flag */
#define GP_WB_READ_RIB_ETOEX_WRTR() \
        GP_WB_READ_U8(0x42e)

#define GP_WB_WRITE_RIB_ETOEX_WRTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x42e, (val)); \
        } while (0)


/* Sets the default number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_READ_RIB_DEFAULT_TRIGGER_LEVEL() \
        GP_WB_READ_U8(0x42f)

#define GP_WB_WRITE_RIB_DEFAULT_TRIGGER_LEVEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x42f, (val)); \
        } while (0)


/* Sets a number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_READ_RIB_TRIGGER_LEVEL() \
        GP_WB_READ_U8(0x430)

#define GP_WB_WRITE_RIB_TRIGGER_LEVEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x430, (val)); \
        } while (0)


#define GP_WB_WRITE_RIB_TRIGGER_LEVEL_CONTROL(val) \
      GP_WB_WRITE_U8(0x431, (val))

/* Applies the trigger level defined by the trigger_level property */
#define GP_WB_RIB_APPLY_TRIGGER_LEVEL() \
        GP_WB_WRITE_U8(0x431, 0x01)

#define GP_WB_SET_RIB_APPLY_TRIGGER_LEVEL_TO_TRIGGER_LEVEL_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* CLears the level trigger interrupt */
#define GP_WB_RIB_CLR_LEVEL_TRIGGER_INT() \
        GP_WB_WRITE_U8(0x431, 0x02)

#define GP_WB_SET_RIB_CLR_LEVEL_TRIGGER_INT_TO_TRIGGER_LEVEL_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_FRAME_CHECK_CONTROL() \
        GP_WB_READ_U8(0x432)

#define GP_WB_WRITE_RIB_FRAME_CHECK_CONTROL(val) \
      GP_WB_WRITE_U8(0x432, (val))

/* Set this bit when the the received frame is a beacon frame - used by macfilter only */
#define GP_WB_READ_RIB_FRAME_IS_BEACON() \
        GP_WB_READ_U1(0x432, 0)

#define GP_WB_GET_RIB_FRAME_IS_BEACON_FROM_FRAME_CHECK_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_FRAME_IS_BEACON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x432, 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_FRAME_IS_BEACON_TO_FRAME_CHECK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set this bit when the the received frame is a data frame - used by macfilter only */
#define GP_WB_READ_RIB_FRAME_IS_DATA() \
        GP_WB_READ_U1(0x432, 1)

#define GP_WB_GET_RIB_FRAME_IS_DATA_FROM_FRAME_CHECK_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_FRAME_IS_DATA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x432, 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_FRAME_IS_DATA_TO_FRAME_CHECK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set this bit when the the received frame is an ack - used by macfilter only */
#define GP_WB_READ_RIB_FRAME_IS_ACK() \
        GP_WB_READ_U1(0x432, 2)

#define GP_WB_GET_RIB_FRAME_IS_ACK_FROM_FRAME_CHECK_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_FRAME_IS_ACK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x432, 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_FRAME_IS_ACK_TO_FRAME_CHECK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set this bit when the received frame is a data request - used by macfilter only */
#define GP_WB_READ_RIB_FRAME_IS_DATAREQ() \
        GP_WB_READ_U1(0x432, 3)

#define GP_WB_GET_RIB_FRAME_IS_DATAREQ_FROM_FRAME_CHECK_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_FRAME_IS_DATAREQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x432, 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_FRAME_IS_DATAREQ_TO_FRAME_CHECK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Set this bit when the the framepending bit in the received ack is set - used by macfilter only */
#define GP_WB_READ_RIB_ACK_FRAME_PENDING() \
        GP_WB_READ_U1(0x432, 4)

#define GP_WB_GET_RIB_ACK_FRAME_PENDING_FROM_FRAME_CHECK_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_ACK_FRAME_PENDING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x432, 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_FRAME_PENDING_TO_FRAME_CHECK_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_RIB_FRAME_ACTION_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x433, (val))

/* set if we find a matching sequence number */
#define GP_WB_RIB_SEQ_NR_MATCH() \
        GP_WB_WRITE_U8(0x433, 0x01)

#define GP_WB_SET_RIB_SEQ_NR_MATCH_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* set to trigger accepting the packet. This just means that enough of the packet has been processed to know if the packet is valid or not. */
#define GP_WB_RIB_ACCEPT_PACKET() \
        GP_WB_WRITE_U8(0x433, 0x02)

#define GP_WB_SET_RIB_ACCEPT_PACKET_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* set to trigger an ack on the packet */
#define GP_WB_RIB_ACK_REQUEST() \
        GP_WB_WRITE_U8(0x433, 0x04)

#define GP_WB_SET_RIB_ACK_REQUEST_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set to queue the rx pbm in which the packet was received in order to enable SW handling on it */
#define GP_WB_RIB_QUEUE_PBM() \
        GP_WB_WRITE_U8(0x433, 0x08)

#define GP_WB_SET_RIB_QUEUE_PBM_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* abort the reception of the packet - handle to drop packets if they fail a filter */
#define GP_WB_RIB_ABORT_PACKET() \
        GP_WB_WRITE_U8(0x433, 0x10)

#define GP_WB_SET_RIB_ABORT_PACKET_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* This is setting can be used by the sniffer functionality to pass packets with bad fcs, even if the fcs check is on */
#define GP_WB_RIB_IGNORE_FCS_RESULT_FOR_QUEUEING() \
        GP_WB_WRITE_U8(0x433, 0x20)

#define GP_WB_SET_RIB_IGNORE_FCS_RESULT_FOR_QUEUEING_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Indicates why the last aborted packet was aborted */
#define GP_WB_READ_RIB_ABORT_REASON() \
        GP_WB_READ_U8(0x434)

#define GP_WB_WRITE_RIB_ABORT_REASON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x434, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_META_DATA() \
        GP_WB_READ_U8(0x435)

/* Channel on which packet is being received */
#define GP_WB_READ_RIB_RX_CHANNEL() \
        (GP_WB_READ_U8(0x435) & 0x0F)

#define GP_WB_GET_RIB_RX_CHANNEL_FROM_RX_META_DATA(tmp) \
        ((tmp) & 0x0F)

/* Antenna on which packet is being received */
#define GP_WB_READ_RIB_RX_ANTENNA() \
        GP_WB_READ_U1(0x435, 4)

#define GP_WB_GET_RIB_RX_ANTENNA_FROM_RX_META_DATA(tmp) \
        (((tmp) >> 4) & 0x01)


/* Channel idx on which packet is being received */
#define GP_WB_READ_RIB_RX_CHANNEL_IDX() \
        GP_WB_READ_U8(0x436)


/* number of bytes that were received and written to memory */
#define GP_WB_READ_RIB_BYTES_RECEIVED() \
        GP_WB_READ_U8(0x437)


/* Size-1 of the pan_id/short address table in bytes (table contains coord, channel_idx, pan_id, short_addr) (0xFF means 256 bytes) (table itself is in the macfilt regmap) - this effectively enables multi-pan feature */
#define GP_WB_READ_RIB_DST_PAN_ID_TABLE_SIZE() \
        GP_WB_READ_U8(0x438)

#define GP_WB_WRITE_RIB_DST_PAN_ID_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(0x438, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_UNMASKED_INT() \
        GP_WB_READ_U8(0x439)

/* Unmasked confirm/indication interrupt (see PBETE description for bit position) */
#define GP_WB_READ_RIB_UNMASKED_INT_DATA_IND() \
        GP_WB_READ_U1(0x439, 0)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_IND_FROM_UNMASKED_INT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_INT_DATA_CNF_0() \
        GP_WB_READ_U1(0x439, 1)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_CNF_0_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_INT_DATA_CNF() \
        ((GP_WB_READ_U8(0x439) >> 1) & 0x0F)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_CNF_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_READ_RIB_UNMASKED_INT_DATA_CNF_1() \
        GP_WB_READ_U1(0x439, 2)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_CNF_1_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_INT_DATA_CNF_2() \
        GP_WB_READ_U1(0x439, 3)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_CNF_2_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_INT_DATA_CNF_3() \
        GP_WB_READ_U1(0x439, 4)

#define GP_WB_GET_RIB_UNMASKED_INT_DATA_CNF_3_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 4) & 0x01)

/* interrupt triggered when the number of bytes receive reaches the configured threshold */
#define GP_WB_READ_RIB_UNMASKED_LEVEL_TRIGGER_INT() \
        GP_WB_READ_U1(0x439, 5)

#define GP_WB_GET_RIB_UNMASKED_LEVEL_TRIGGER_INT_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 5) & 0x01)


/* Sequence number observation register for the sequence number of ongoing transmission */
#define GP_WB_READ_RIB_TX_SEQ_NUMBER() \
        GP_WB_READ_U8(0x43a)

/***************************
 * layout: qta
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_0() \
        GP_WB_READ_U8(0x480)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_0(val) \
      GP_WB_WRITE_U8(0x480, (val))

#define GP_WB_READ_QTA_PBM_PTR_0() \
        (GP_WB_READ_U8(0x480) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_0_FROM_QTA_TX_OPTIONS_0_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x480, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_0_TO_QTA_TX_OPTIONS_0_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_0() \
        ((GP_WB_READ_U8(0x480) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_0_FROM_QTA_TX_OPTIONS_0_0(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x480, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_0_TO_QTA_TX_OPTIONS_0_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_0() \
        GP_WB_READ_U1(0x480, 6)

#define GP_WB_GET_QTA_PERSISTANCE_0_FROM_QTA_TX_OPTIONS_0_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x480, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_0_TO_QTA_TX_OPTIONS_0_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_0() \
        GP_WB_READ_U1(0x480, 7)

#define GP_WB_GET_QTA_VALID_0_FROM_QTA_TX_OPTIONS_0_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x480, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_0_TO_QTA_TX_OPTIONS_0_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_1() \
        GP_WB_READ_U8(0x481)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_1(val) \
      GP_WB_WRITE_U8(0x481, (val))

#define GP_WB_READ_QTA_PBM_PTR_1() \
        (GP_WB_READ_U8(0x481) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_1_FROM_QTA_TX_OPTIONS_0_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x481, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_1_TO_QTA_TX_OPTIONS_0_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_1() \
        ((GP_WB_READ_U8(0x481) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_1_FROM_QTA_TX_OPTIONS_0_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x481, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_1_TO_QTA_TX_OPTIONS_0_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_1() \
        GP_WB_READ_U1(0x481, 6)

#define GP_WB_GET_QTA_PERSISTANCE_1_FROM_QTA_TX_OPTIONS_0_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x481, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_1_TO_QTA_TX_OPTIONS_0_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_1() \
        GP_WB_READ_U1(0x481, 7)

#define GP_WB_GET_QTA_VALID_1_FROM_QTA_TX_OPTIONS_0_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x481, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_1_TO_QTA_TX_OPTIONS_0_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_2() \
        GP_WB_READ_U8(0x482)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_2(val) \
      GP_WB_WRITE_U8(0x482, (val))

#define GP_WB_READ_QTA_PBM_PTR_2() \
        (GP_WB_READ_U8(0x482) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_2_FROM_QTA_TX_OPTIONS_0_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x482, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_2_TO_QTA_TX_OPTIONS_0_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_2() \
        ((GP_WB_READ_U8(0x482) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_2_FROM_QTA_TX_OPTIONS_0_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x482, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_2_TO_QTA_TX_OPTIONS_0_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_2() \
        GP_WB_READ_U1(0x482, 6)

#define GP_WB_GET_QTA_PERSISTANCE_2_FROM_QTA_TX_OPTIONS_0_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x482, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_2_TO_QTA_TX_OPTIONS_0_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_2() \
        GP_WB_READ_U1(0x482, 7)

#define GP_WB_GET_QTA_VALID_2_FROM_QTA_TX_OPTIONS_0_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x482, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_2_TO_QTA_TX_OPTIONS_0_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_3() \
        GP_WB_READ_U8(0x483)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_3(val) \
      GP_WB_WRITE_U8(0x483, (val))

#define GP_WB_READ_QTA_PBM_PTR_3() \
        (GP_WB_READ_U8(0x483) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_3_FROM_QTA_TX_OPTIONS_0_3(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x483, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_3_TO_QTA_TX_OPTIONS_0_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_3() \
        ((GP_WB_READ_U8(0x483) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_3_FROM_QTA_TX_OPTIONS_0_3(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x483, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_3_TO_QTA_TX_OPTIONS_0_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_3() \
        GP_WB_READ_U1(0x483, 6)

#define GP_WB_GET_QTA_PERSISTANCE_3_FROM_QTA_TX_OPTIONS_0_3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x483, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_3_TO_QTA_TX_OPTIONS_0_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_3() \
        GP_WB_READ_U1(0x483, 7)

#define GP_WB_GET_QTA_VALID_3_FROM_QTA_TX_OPTIONS_0_3(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x483, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_3_TO_QTA_TX_OPTIONS_0_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_4() \
        GP_WB_READ_U8(0x484)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_4(val) \
      GP_WB_WRITE_U8(0x484, (val))

#define GP_WB_READ_QTA_PBM_PTR_4() \
        (GP_WB_READ_U8(0x484) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_4_FROM_QTA_TX_OPTIONS_0_4(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x484, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_4_TO_QTA_TX_OPTIONS_0_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_4() \
        ((GP_WB_READ_U8(0x484) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_4_FROM_QTA_TX_OPTIONS_0_4(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x484, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_4_TO_QTA_TX_OPTIONS_0_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_4() \
        GP_WB_READ_U1(0x484, 6)

#define GP_WB_GET_QTA_PERSISTANCE_4_FROM_QTA_TX_OPTIONS_0_4(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x484, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_4_TO_QTA_TX_OPTIONS_0_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_4() \
        GP_WB_READ_U1(0x484, 7)

#define GP_WB_GET_QTA_VALID_4_FROM_QTA_TX_OPTIONS_0_4(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x484, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_4_TO_QTA_TX_OPTIONS_0_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_5() \
        GP_WB_READ_U8(0x485)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_5(val) \
      GP_WB_WRITE_U8(0x485, (val))

#define GP_WB_READ_QTA_PBM_PTR_5() \
        (GP_WB_READ_U8(0x485) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_5_FROM_QTA_TX_OPTIONS_0_5(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x485, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_5_TO_QTA_TX_OPTIONS_0_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_5() \
        ((GP_WB_READ_U8(0x485) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_5_FROM_QTA_TX_OPTIONS_0_5(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x485, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_5_TO_QTA_TX_OPTIONS_0_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_5() \
        GP_WB_READ_U1(0x485, 6)

#define GP_WB_GET_QTA_PERSISTANCE_5_FROM_QTA_TX_OPTIONS_0_5(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x485, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_5_TO_QTA_TX_OPTIONS_0_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_5() \
        GP_WB_READ_U1(0x485, 7)

#define GP_WB_GET_QTA_VALID_5_FROM_QTA_TX_OPTIONS_0_5(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x485, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_5_TO_QTA_TX_OPTIONS_0_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_6() \
        GP_WB_READ_U8(0x486)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_6(val) \
      GP_WB_WRITE_U8(0x486, (val))

#define GP_WB_READ_QTA_PBM_PTR_6() \
        (GP_WB_READ_U8(0x486) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_6_FROM_QTA_TX_OPTIONS_0_6(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x486, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_6_TO_QTA_TX_OPTIONS_0_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_6() \
        ((GP_WB_READ_U8(0x486) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_6_FROM_QTA_TX_OPTIONS_0_6(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x486, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_6_TO_QTA_TX_OPTIONS_0_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_6() \
        GP_WB_READ_U1(0x486, 6)

#define GP_WB_GET_QTA_PERSISTANCE_6_FROM_QTA_TX_OPTIONS_0_6(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x486, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_6_TO_QTA_TX_OPTIONS_0_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_6() \
        GP_WB_READ_U1(0x486, 7)

#define GP_WB_GET_QTA_VALID_6_FROM_QTA_TX_OPTIONS_0_6(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x486, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_6_TO_QTA_TX_OPTIONS_0_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_TX_OPTIONS_0_7() \
        GP_WB_READ_U8(0x487)

#define GP_WB_WRITE_QTA_QTA_TX_OPTIONS_0_7(val) \
      GP_WB_WRITE_U8(0x487, (val))

#define GP_WB_READ_QTA_PBM_PTR_7() \
        (GP_WB_READ_U8(0x487) & 0x07)

#define GP_WB_GET_QTA_PBM_PTR_7_FROM_QTA_TX_OPTIONS_0_7(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_QTA_PBM_PTR_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x487, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PBM_PTR_7_TO_QTA_TX_OPTIONS_0_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_STATUS_7() \
        ((GP_WB_READ_U8(0x487) >> 3) & 0x07)

#define GP_WB_GET_QTA_STATUS_7_FROM_QTA_TX_OPTIONS_0_7(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_QTA_STATUS_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x487, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_QTA_STATUS_7_TO_QTA_TX_OPTIONS_0_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_QTA_PERSISTANCE_7() \
        GP_WB_READ_U1(0x487, 6)

#define GP_WB_GET_QTA_PERSISTANCE_7_FROM_QTA_TX_OPTIONS_0_7(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_QTA_PERSISTANCE_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x487, 6, (val)); \
        } while (0)

#define GP_WB_SET_QTA_PERSISTANCE_7_TO_QTA_TX_OPTIONS_0_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_QTA_VALID_7() \
        GP_WB_READ_U1(0x487, 7)

#define GP_WB_GET_QTA_VALID_7_FROM_QTA_TX_OPTIONS_0_7(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_QTA_VALID_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x487, 7, (val)); \
        } while (0)

#define GP_WB_SET_QTA_VALID_7_TO_QTA_TX_OPTIONS_0_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


#define GP_WB_READ_QTA_VQ_0() \
        GP_WB_READ_U8(0x488)

#define GP_WB_WRITE_QTA_VQ_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x488, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_1() \
        GP_WB_READ_U8(0x489)

#define GP_WB_WRITE_QTA_VQ_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x489, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_2() \
        GP_WB_READ_U8(0x48a)

#define GP_WB_WRITE_QTA_VQ_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48a, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_3() \
        GP_WB_READ_U8(0x48b)

#define GP_WB_WRITE_QTA_VQ_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48b, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_4() \
        GP_WB_READ_U8(0x48c)

#define GP_WB_WRITE_QTA_VQ_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48c, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_5() \
        GP_WB_READ_U8(0x48d)

#define GP_WB_WRITE_QTA_VQ_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48d, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_6() \
        GP_WB_READ_U8(0x48e)

#define GP_WB_WRITE_QTA_VQ_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48e, (val)); \
        } while (0)


#define GP_WB_READ_QTA_VQ_7() \
        GP_WB_READ_U8(0x48f)

#define GP_WB_WRITE_QTA_VQ_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x48f, (val)); \
        } while (0)


#define GP_WB_READ_QTA_RETRY_CNT() \
        GP_WB_READ_U8(0x490)

#define GP_WB_WRITE_QTA_RETRY_CNT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x490, (val)); \
        } while (0)


#define GP_WB_WRITE_QTA_PBEFE_DATA_REQ(val) do { \
          GP_WB_WRITE_U8(0x491, (val)); \
        } while (0)


/* Purge trigger. There is a delay of maximum 16us between the purge_req and the purge_done field being valid. */
#define GP_WB_QTA_PURGE_REQ() \
        GP_WB_WRITE_U8(0x492, 0x01)


/* PBM entry purge request to RTMAC QTA */
#define GP_WB_READ_QTA_PURGE_NUMBER() \
        GP_WB_READ_U8(0x493)

#define GP_WB_WRITE_QTA_PURGE_NUMBER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x493, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_MISC_0() \
        GP_WB_READ_U8(0x494)

#define GP_WB_WRITE_QTA_MISC_0(val) \
      GP_WB_WRITE_U8(0x494, (val))

#define GP_WB_READ_QTA_TX_DISABLE() \
        GP_WB_READ_U1(0x494, 0)

#define GP_WB_GET_QTA_TX_DISABLE_FROM_MISC_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_QTA_TX_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x494, 0, (val)); \
        } while (0)

#define GP_WB_SET_QTA_TX_DISABLE_TO_MISC_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_SCH_TX_QTA_PURGE_EN() \
        GP_WB_READ_U1(0x494, 1)

#define GP_WB_GET_QTA_SCH_TX_QTA_PURGE_EN_FROM_MISC_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_QTA_SCH_TX_QTA_PURGE_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x494, 1, (val)); \
        } while (0)

#define GP_WB_SET_QTA_SCH_TX_QTA_PURGE_EN_TO_MISC_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_QTA_UNTIMED_VQ_DIS() \
        GP_WB_READ_U1(0x494, 2)

#define GP_WB_GET_QTA_UNTIMED_VQ_DIS_FROM_MISC_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_QTA_UNTIMED_VQ_DIS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x494, 2, (val)); \
        } while (0)

#define GP_WB_SET_QTA_UNTIMED_VQ_DIS_TO_MISC_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_MISC_STATUS() \
        GP_WB_READ_U8(0x495)

/* Purging action is done. There is a delay of maximum 16us between the purge_req and the purge_done field being valid. */
#define GP_WB_READ_QTA_PURGE_DONE() \
        GP_WB_READ_U1(0x495, 0)

#define GP_WB_GET_QTA_PURGE_DONE_FROM_MISC_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status of the last acknowledged PBM entry purge request. */
#define GP_WB_READ_QTA_PURGE_STATUS() \
        GP_WB_READ_U1(0x495, 1)

#define GP_WB_GET_QTA_PURGE_STATUS_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_QTA_TX_DISABLE_OK() \
        GP_WB_READ_U1(0x495, 2)

#define GP_WB_GET_QTA_TX_DISABLE_OK_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_UNMASKED_INT() \
        GP_WB_READ_U8(0x496)

#define GP_WB_READ_QTA_UNMASKED_QTA_SCH0_EMPTY() \
        GP_WB_READ_U1(0x496, 0)

#define GP_WB_GET_QTA_UNMASKED_QTA_SCH0_EMPTY_FROM_UNMASKED_INT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_QTA_SCH1_EMPTY() \
        GP_WB_READ_U1(0x496, 1)

#define GP_WB_GET_QTA_UNMASKED_QTA_SCH1_EMPTY_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_QTA_SCH2_EMPTY() \
        GP_WB_READ_U1(0x496, 2)

#define GP_WB_GET_QTA_UNMASKED_QTA_SCH2_EMPTY_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_QTA_SCH3_EMPTY() \
        GP_WB_READ_U1(0x496, 3)

#define GP_WB_GET_QTA_UNMASKED_QTA_SCH3_EMPTY_FROM_UNMASKED_INT(tmp) \
        (((tmp) >> 3) & 0x01)


#define GP_WB_WRITE_QTA_CLEAR_INT(val) \
      GP_WB_WRITE_U8(0x497, (val))

/* The clearing of this interrupt can take up to 16us. */
#define GP_WB_QTA_CLEAR_QTA_SCH0_EMPTY() \
        GP_WB_WRITE_U8(0x497, 0x01)

#define GP_WB_SET_QTA_CLEAR_QTA_SCH0_EMPTY_TO_CLEAR_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The clearing of this interrupt can take up to 16us. */
#define GP_WB_QTA_CLEAR_QTA_SCH1_EMPTY() \
        GP_WB_WRITE_U8(0x497, 0x02)

#define GP_WB_SET_QTA_CLEAR_QTA_SCH1_EMPTY_TO_CLEAR_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* The clearing of this interrupt can take up to 16us. */
#define GP_WB_QTA_CLEAR_QTA_SCH2_EMPTY() \
        GP_WB_WRITE_U8(0x497, 0x04)

#define GP_WB_SET_QTA_CLEAR_QTA_SCH2_EMPTY_TO_CLEAR_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* The clearing of this interrupt can take up to 16us. */
#define GP_WB_QTA_CLEAR_QTA_SCH3_EMPTY() \
        GP_WB_WRITE_U8(0x497, 0x08)

#define GP_WB_SET_QTA_CLEAR_QTA_SCH3_EMPTY_TO_CLEAR_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_RET_UNMASKED_INT() \
        GP_WB_READ_U8(0x498)

#define GP_WB_WRITE_QTA_RET_UNMASKED_INT(val) \
      GP_WB_WRITE_U8(0x498, (val))

#define GP_WB_READ_QTA_RET_UNMASKED_QTA_SCH0_EMPTY() \
        GP_WB_READ_U1(0x498, 0)

#define GP_WB_GET_QTA_RET_UNMASKED_QTA_SCH0_EMPTY_FROM_RET_UNMASKED_INT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_QTA_RET_UNMASKED_QTA_SCH0_EMPTY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x498, 0, (val)); \
        } while (0)

#define GP_WB_SET_QTA_RET_UNMASKED_QTA_SCH0_EMPTY_TO_RET_UNMASKED_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_QTA_RET_UNMASKED_QTA_SCH1_EMPTY() \
        GP_WB_READ_U1(0x498, 1)

#define GP_WB_GET_QTA_RET_UNMASKED_QTA_SCH1_EMPTY_FROM_RET_UNMASKED_INT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_QTA_RET_UNMASKED_QTA_SCH1_EMPTY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x498, 1, (val)); \
        } while (0)

#define GP_WB_SET_QTA_RET_UNMASKED_QTA_SCH1_EMPTY_TO_RET_UNMASKED_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_QTA_RET_UNMASKED_QTA_SCH2_EMPTY() \
        GP_WB_READ_U1(0x498, 2)

#define GP_WB_GET_QTA_RET_UNMASKED_QTA_SCH2_EMPTY_FROM_RET_UNMASKED_INT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_QTA_RET_UNMASKED_QTA_SCH2_EMPTY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x498, 2, (val)); \
        } while (0)

#define GP_WB_SET_QTA_RET_UNMASKED_QTA_SCH2_EMPTY_TO_RET_UNMASKED_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_QTA_RET_UNMASKED_QTA_SCH3_EMPTY() \
        GP_WB_READ_U1(0x498, 3)

#define GP_WB_GET_QTA_RET_UNMASKED_QTA_SCH3_EMPTY_FROM_RET_UNMASKED_INT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_QTA_RET_UNMASKED_QTA_SCH3_EMPTY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x498, 3, (val)); \
        } while (0)

#define GP_WB_SET_QTA_RET_UNMASKED_QTA_SCH3_EMPTY_TO_RET_UNMASKED_INT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/***************************
 * layout: prg
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PRG_PRG_SETTING() \
        GP_WB_READ_U8(0x4a0)

#define GP_WB_WRITE_PRG_PRG_SETTING(val) \
      GP_WB_WRITE_U8(0x4a0, (val))

/* Enable clk_prg by uC  when 0x1 */
#define GP_WB_READ_PRG_ENABLE_CLK_PRG_BY_UC() \
        GP_WB_READ_U1(0x4a0, 0)

#define GP_WB_GET_PRG_ENABLE_CLK_PRG_BY_UC_FROM_PRG_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_CLK_PRG_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x4a0, 0, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_CLK_PRG_BY_UC_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable pseudo random generation when 0x1 */
#define GP_WB_READ_PRG_ENABLE_RANDOM_SEED() \
        GP_WB_READ_U1(0x4a0, 1)

#define GP_WB_GET_PRG_ENABLE_RANDOM_SEED_FROM_PRG_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_RANDOM_SEED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x4a0, 1, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_RANDOM_SEED_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables the use of a real single bit random source coming from the rx_i signal. Receiver needs to be on for this to work, otherwise a Pseudo random number is generated. */
#define GP_WB_READ_PRG_ENABLE_RANDOM_SOURCE() \
        GP_WB_READ_U1(0x4a0, 2)

#define GP_WB_GET_PRG_ENABLE_RANDOM_SOURCE_FROM_PRG_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_RANDOM_SOURCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x4a0, 2, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_RANDOM_SOURCE_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Apply random seed */
#define GP_WB_PRG_APPLY_RANDOM_SEED() \
        GP_WB_WRITE_U8(0x4a1, 0x01)


/* Random seed */
#define GP_WB_READ_PRG_RANDOM_SEED() \
        GP_WB_READ_U16(0x4a2)

#define GP_WB_WRITE_PRG_RANDOM_SEED(val) do { \
          GP_WB_WRITE_U16(0x4a2, (val)); \
        } while (0)


/* Random value */
#define GP_WB_READ_PRG_RANDOM_VALUE() \
        GP_WB_READ_U8(0x4a4)

/***************************
 * layout: msi
 ***************************/

/* Semaphore 0 */
#define GP_WB_READ_MSI_SEMAPHORE_0() \
        GP_WB_READ_U1(0x500, 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x500, (val)); \
        } while (0)


/* Semaphore 1 */
#define GP_WB_READ_MSI_SEMAPHORE_1() \
        GP_WB_READ_U1(0x501, 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x501, (val)); \
        } while (0)


/* Semaphore 2 */
#define GP_WB_READ_MSI_SEMAPHORE_2() \
        GP_WB_READ_U1(0x502, 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x502, (val)); \
        } while (0)


/* Semaphore 3 */
#define GP_WB_READ_MSI_SEMAPHORE_3() \
        GP_WB_READ_U1(0x503, 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x503, (val)); \
        } while (0)


/* see enum definition */
#define GP_WB_READ_MSI_SERIAL_ITF_SELECT() \
        GP_WB_READ_U8(0x504)

#define GP_WB_WRITE_MSI_SERIAL_ITF_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x504, (val)); \
        } while (0)

/***************************
 * layout: int_ctrl
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U24(0x540)

/* unmasked ES external interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_ES_INTERRUPT() \
        GP_WB_READ_U1(0x540, 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_ES_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* unmasked trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_TRC_INTERRUPT() \
        GP_WB_READ_U1(0x540, 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_TRC_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_QTA_INTERRUPT() \
        GP_WB_READ_U1(0x540, 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_QTA_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* unmasked mac filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x540, 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_MACFILT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* unmasked standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_UNMASKED_STBC_INTERRUPT() \
        GP_WB_READ_U1(0x540, 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_STBC_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* unmasked mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_UNMASKED_MRI_INTERRUPT() \
        GP_WB_READ_U1(0x540, 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_MRI_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* unmasked gpio external interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPIO_INTERRUPT() \
        GP_WB_READ_U1(0x540, 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPIO_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* unmasked TWI master interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_TWIMS_INTERRUPT() \
        GP_WB_READ_U1(0x540, 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_TWIMS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* unmasked security processor interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SSP_INTERRUPT() \
        GP_WB_READ_U1(0x541, 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_SSP_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* unmasked Phy interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_PHY_INTERRUPT() \
        GP_WB_READ_U1(0x541, 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_PHY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* unmasked RCI interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_RCI_INTERRUPT() \
        GP_WB_READ_U1(0x541, 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_RCI_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* unmasked UART interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_UART_INTERRUPT() \
        GP_WB_READ_U1(0x541, 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_UART_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* unmasked KeyPad Scan interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_KPS_INTERRUPT() \
        GP_WB_READ_U1(0x541, 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_KPS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* unmasked SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SPIM_INTERRUPT() \
        GP_WB_READ_U1(0x541, 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_SPIM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* unmasked ir driver interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_IR_INTERRUPT() \
        GP_WB_READ_U1(0x541, 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_IR_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* unmasked watchdog interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(0x541, 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_WATCHDOG_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* unmasked inter process communication interrupt (internal to external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCINT2EXT_INTERRUPT() \
        GP_WB_READ_U1(0x542, 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCINT2EXT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* unmasked inter process communication interrupt (external to internal) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCEXT2INT_INTERRUPT() \
        GP_WB_READ_U1(0x542, 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCEXT2INT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* unmasked pwm interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_PWM_INTERRUPT() \
        GP_WB_READ_U1(0x542, 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_PWM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* unmasked dma interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_DMA_INTERRUPT() \
        GP_WB_READ_U1(0x542, 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_DMA_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

/* unmasked SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SPISL_INTERRUPT() \
        GP_WB_READ_U1(0x542, 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_SPISL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

/* unmasked I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(0x542, 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_I2CSL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* unmasked adc interface interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(0x542, 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_ADCIF_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_INTERRUPTS() \
        GP_WB_READ_U24(0x544)

/* masked external ES interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_ES_INTERRUPT() \
        GP_WB_READ_U1(0x544, 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_ES_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked external trc interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_TRC_INTERRUPT() \
        GP_WB_READ_U1(0x544, 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_TRC_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked external qta interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_QTA_INTERRUPT() \
        GP_WB_READ_U1(0x544, 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_QTA_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked external MAC filter interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x544, 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_MACFILT_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked external standby controller interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_STBC_INTERRUPT() \
        GP_WB_READ_U1(0x544, 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_STBC_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked external MRI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_MRI_INTERRUPT() \
        GP_WB_READ_U1(0x544, 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_MRI_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Masked GPIO external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(0x544, 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_GPIO_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Masked twi master external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_TWIMS_INTERRUPT() \
        GP_WB_READ_U1(0x544, 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_TWIMS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* Masked SSP external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SSP_INTERRUPT() \
        GP_WB_READ_U1(0x545, 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SSP_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* Masked phy external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PHY_INTERRUPT() \
        GP_WB_READ_U1(0x545, 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PHY_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* masked external RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_RCI_INTERRUPT() \
        GP_WB_READ_U1(0x545, 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_RCI_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* masked external UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_UART_INTERRUPT() \
        GP_WB_READ_U1(0x545, 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_UART_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* masked external KayPad Scan interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_KPS_INTERRUPT() \
        GP_WB_READ_U1(0x545, 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_KPS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* masked external SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(0x545, 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SPIM_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* masked external ir driver interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IR_INTERRUPT() \
        GP_WB_READ_U1(0x545, 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IR_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* Masked watchdog external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(0x545, 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_WATCHDOG_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* Masked inter process communication interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IPCINT2EXT_INTERRUPT() \
        GP_WB_READ_U1(0x546, 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IPCINT2EXT_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* Masked pwm interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PWM_INTERRUPT() \
        GP_WB_READ_U1(0x546, 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PWM_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* Masked dma interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_DMA_INTERRUPT() \
        GP_WB_READ_U1(0x546, 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_DMA_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* Masked adcif interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(0x546, 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_ADCIF_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_EXT_INTERRUPTS() \
        GP_WB_READ_U24(0x548)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_INTERRUPTS(val) \
      GP_WB_WRITE_U24(0x548, (val))

/* Mask external ES interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_ES_INTERRUPT() \
        GP_WB_READ_U1(0x548, 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_ES_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_ES_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_TRC_INTERRUPT() \
        GP_WB_READ_U1(0x548, 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_TRC_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_TRC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_TRC_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_QTA_INTERRUPT() \
        GP_WB_READ_U1(0x548, 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_QTA_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_QTA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_QTA_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Mask external MAC filter interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x548, 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_MACFILT_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_MACFILT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_MACFILT_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Mask external standby controller interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_STBC_INTERRUPT() \
        GP_WB_READ_U1(0x548, 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_STBC_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_STBC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_STBC_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Mask external MRI interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_MRI_INTERRUPT() \
        GP_WB_READ_U1(0x548, 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_MRI_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_MRI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_MRI_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Mask the GPIO external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(0x548, 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_GPIO_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_GPIO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_GPIO_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Mask the twi master external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_TWIMS_INTERRUPT() \
        GP_WB_READ_U1(0x548, 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_TWIMS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_TWIMS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x548, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_TWIMS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Mask the ssp external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SSP_INTERRUPT() \
        GP_WB_READ_U1(0x549, 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SSP_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SSP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SSP_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Mask the phy external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_PHY_INTERRUPT() \
        GP_WB_READ_U1(0x549, 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PHY_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PHY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PHY_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Mask the RCI external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_RCI_INTERRUPT() \
        GP_WB_READ_U1(0x549, 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_RCI_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_RCI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_RCI_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Mask the UART external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_UART_INTERRUPT() \
        GP_WB_READ_U1(0x549, 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_UART_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_UART_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_UART_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Mask the KeyPad Scan external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_KPS_INTERRUPT() \
        GP_WB_READ_U1(0x549, 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_KPS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_KPS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_KPS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Mask the SPI Master external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(0x549, 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SPIM_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SPIM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SPIM_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Mask the IR driver external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_IR_INTERRUPT() \
        GP_WB_READ_U1(0x549, 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IR_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IR_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Mask the watchdog external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(0x549, 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x549, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_IPCINT2EXT_INTERRUPT() \
        GP_WB_READ_U1(0x54a, 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IPCINT2EXT_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IPCINT2EXT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x54a, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IPCINT2EXT_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0EFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_PWM_INTERRUPT() \
        GP_WB_READ_U1(0x54a, 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PWM_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PWM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x54a, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PWM_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0DFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_DMA_INTERRUPT() \
        GP_WB_READ_U1(0x54a, 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_DMA_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_DMA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x54a, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_DMA_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0BFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(0x54a, 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x54a, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_INT_INTERRUPTS() \
        GP_WB_READ_U24(0x54c)

/* masked internal ES interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_ES_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_ES_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_INT_TRC_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_TRC_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_INT_QTA_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_QTA_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked internal MAC interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_MACFILT_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked internal standby controller interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_STBC_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_STBC_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked internal MRI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_MRI_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_MRI_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Masked GPIO internal interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_GPIO_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Masked twi master internal interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_TWIMS_INTERRUPT() \
        GP_WB_READ_U1(0x54c, 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_TWIMS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* Masked SSP internal interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SSP_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SSP_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* Masked phy internal interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PHY_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PHY_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* masked internal RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_RCI_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_RCI_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* masked internal UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_UART_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_UART_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* masked internal KeyPad Scan interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_KPS_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_KPS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* masked internal SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SPIM_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* masked internal IR driver interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IR_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IR_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* Masked watchdog internal interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(0x54d, 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_WATCHDOG_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* masked internal inter processor communication interrupt (ext 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IPCEXT2INT_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IPCEXT2INT_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* masked pwm interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PWM_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PWM_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* masked dma interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_DMA_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_DMA_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* masked internal SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SPISL_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

/* masked internal I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_I2CSL_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

/* masked internal adcif interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(0x54e, 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_ADCIF_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_INT_INTERRUPTS() \
        GP_WB_READ_U24(0x550)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_INTERRUPTS(val) \
      GP_WB_WRITE_U24(0x550, (val))

/* Mask internal ES interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_ES_INTERRUPT() \
        GP_WB_READ_U1(0x550, 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_ES_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_ES_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_INT_TRC_INTERRUPT() \
        GP_WB_READ_U1(0x550, 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_TRC_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_TRC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_TRC_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_INT_QTA_INTERRUPT() \
        GP_WB_READ_U1(0x550, 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_QTA_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_QTA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_QTA_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Mask internal MAC filter interrupts */
#define GP_WB_READ_INT_CTRL_MASK_INT_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x550, 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_MACFILT_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_MACFILT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_MACFILT_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Mask internal standby controller interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_STBC_INTERRUPT() \
        GP_WB_READ_U1(0x550, 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_STBC_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_STBC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_STBC_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Mask internal MRI interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_MRI_INTERRUPT() \
        GP_WB_READ_U1(0x550, 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_MRI_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_MRI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_MRI_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Mask the GPIO internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(0x550, 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_GPIO_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_GPIO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_GPIO_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Mask the twi master internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_TWIMS_INTERRUPT() \
        GP_WB_READ_U1(0x550, 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_TWIMS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_TWIMS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x550, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_TWIMS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Mask the ssp internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SSP_INTERRUPT() \
        GP_WB_READ_U1(0x551, 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_SSP_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SSP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SSP_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Mask the phy internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_PHY_INTERRUPT() \
        GP_WB_READ_U1(0x551, 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_PHY_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PHY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PHY_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Mask the RCI internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_RCI_INTERRUPT() \
        GP_WB_READ_U1(0x551, 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_RCI_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_RCI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_RCI_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Mask the UART internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_UART_INTERRUPT() \
        GP_WB_READ_U1(0x551, 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_UART_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_UART_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_UART_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Mask the KeyPad Scan internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_KPS_INTERRUPT() \
        GP_WB_READ_U1(0x551, 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_KPS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_KPS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_KPS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Mask the spimaster internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(0x551, 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_SPIM_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SPIM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SPIM_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Mask the ir driver internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_IR_INTERRUPT() \
        GP_WB_READ_U1(0x551, 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_IR_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IR_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Mask the watchdog internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(0x551, 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x551, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Mask the internal inter processor communication interrupt (ext 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_INT_IPCEXT2INT_INTERRUPT() \
        GP_WB_READ_U1(0x552, 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_IPCEXT2INT_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IPCEXT2INT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IPCEXT2INT_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3EFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Mask the pwm interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_PWM_INTERRUPT() \
        GP_WB_READ_U1(0x552, 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_PWM_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PWM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PWM_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3DFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Mask the dma interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_DMA_INTERRUPT() \
        GP_WB_READ_U1(0x552, 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_DMA_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_DMA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_DMA_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3BFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Mask the spi slave internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(0x552, 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_SPISL_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SPISL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SPISL_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Mask the I2C slave internal interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(0x552, 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_I2CSL_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_I2CSL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_I2CSL_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2FFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_INT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(0x552, 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_ADCIF_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_ADCIF_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x552, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_ADCIF_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* Masked mac filter interrupt for sequencer */
#define GP_WB_READ_INT_CTRL_MASKED_SEQ_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x553, 0)


/* Mask mac interrupt for sequencer */
#define GP_WB_READ_INT_CTRL_MASK_SEQ_MACFILT_INTERRUPT() \
        GP_WB_READ_U1(0x554, 0)

#define GP_WB_WRITE_INT_CTRL_MASK_SEQ_MACFILT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x554, (val)); \
        } while (0)


/* Mask Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASK_ES_EVENT_INTERRUPT() \
        GP_WB_READ_U16(0x556)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_EVENT_INTERRUPT(val) do { \
          GP_WB_WRITE_U16(0x556, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_0() \
        GP_WB_READ_U8(0x558)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_0(val) \
      GP_WB_WRITE_U8(0x558, (val))

/* Mask es symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(0x558, 0)

#define GP_WB_GET_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x558, 1)

#define GP_WB_GET_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x558, 2)

#define GP_WB_GET_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMA_SRC_ALMOST_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x558, 3)

#define GP_WB_GET_INT_CTRL_MASK_DMA_SRC_ALMOST_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMA_SRC_ALMOST_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMA_SRC_ALMOST_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMA_DEST_ALMOST_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x558, 4)

#define GP_WB_GET_INT_CTRL_MASK_DMA_DEST_ALMOST_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMA_DEST_ALMOST_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMA_DEST_ALMOST_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMA_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(0x558, 5)

#define GP_WB_GET_INT_CTRL_MASK_DMA_CPY_ERR_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMA_CPY_ERR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMA_CPY_ERR_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMA_SRC_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x558, 6)

#define GP_WB_GET_INT_CTRL_MASK_DMA_SRC_UNDERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMA_SRC_UNDERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMA_SRC_UNDERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMA_DEST_OVERFLOW_INTERRUPT() \
        GP_WB_READ_U1(0x558, 7)

#define GP_WB_GET_INT_CTRL_MASK_DMA_DEST_OVERFLOW_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMA_DEST_OVERFLOW_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x558, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMA_DEST_OVERFLOW_INTERRUPT_TO_MASK_SRC_INTERRUPTS_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_1() \
        GP_WB_READ_U8(0x559)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_1(val) \
      GP_WB_WRITE_U8(0x559, (val))

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x559, 0)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x559, 1)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x559, 2)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x559, 3)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASK_TRC_GENERIC_0_INTERRUPT() \
        GP_WB_READ_U1(0x559, 4)

#define GP_WB_GET_INT_CTRL_MASK_TRC_GENERIC_0_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_GENERIC_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_GENERIC_0_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASK_TRC_GENERIC_1_INTERRUPT() \
        GP_WB_READ_U1(0x559, 5)

#define GP_WB_GET_INT_CTRL_MASK_TRC_GENERIC_1_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_GENERIC_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_GENERIC_1_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASK_TRC_GENERIC_2_INTERRUPT() \
        GP_WB_READ_U1(0x559, 6)

#define GP_WB_GET_INT_CTRL_MASK_TRC_GENERIC_2_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_GENERIC_2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_GENERIC_2_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASK_TRC_GENERIC_3_INTERRUPT() \
        GP_WB_READ_U1(0x559, 7)

#define GP_WB_GET_INT_CTRL_MASK_TRC_GENERIC_3_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_GENERIC_3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x559, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_GENERIC_3_INTERRUPT_TO_MASK_SRC_INTERRUPTS_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_2() \
        GP_WB_READ_U8(0x55a)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_2(val) \
      GP_WB_WRITE_U8(0x55a, (val))

#define GP_WB_READ_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x55a, 0)

#define GP_WB_GET_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55a, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x55a, 1)

#define GP_WB_GET_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55a, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT_TO_MASK_SRC_INTERRUPTS_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x55a, 2)

#define GP_WB_GET_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55a, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT_TO_MASK_SRC_INTERRUPTS_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55a, 3)

#define GP_WB_GET_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55a, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* mask for triggering in anterrupt when n bytes were received */
#define GP_WB_READ_INT_CTRL_MASK_MACFILT_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(0x55a, 4)

#define GP_WB_GET_INT_CTRL_MASK_MACFILT_LEVEL_TRIGGER_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_MACFILT_LEVEL_TRIGGER_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55a, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_MACFILT_LEVEL_TRIGGER_INTERRUPT_TO_MASK_SRC_INTERRUPTS_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_3() \
        GP_WB_READ_U8(0x55b)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_3(val) \
      GP_WB_WRITE_U8(0x55b, (val))

/* >mask the standby controller event power on reset detected interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_PORD_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 0)

#define GP_WB_GET_INT_CTRL_MASK_STBC_PORD_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_PORD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_PORD_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* >mask the standby controller Active state interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 1)

#define GP_WB_GET_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* mask the standby controller iso_tx brownout */
#define GP_WB_READ_INT_CTRL_MASK_STBC_ISO_TX_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 2)

#define GP_WB_GET_INT_CTRL_MASK_STBC_ISO_TX_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_ISO_TX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_ISO_TX_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* mask the standby controller vrr(=VCC1) brownout */
#define GP_WB_READ_INT_CTRL_MASK_STBC_VRR_BROWNOUT_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 3)

#define GP_WB_GET_INT_CTRL_MASK_STBC_VRR_BROWNOUT_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_VRR_BROWNOUT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_VRR_BROWNOUT_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* mask the standby controller vlt_status interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 4)

#define GP_WB_GET_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* mask for the mri write interrupt */
#define GP_WB_READ_INT_CTRL_MASK_MRI_WRITE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 5)

#define GP_WB_GET_INT_CTRL_MASK_MRI_WRITE_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_MRI_WRITE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_MRI_WRITE_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Mask the ssp done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SSP_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55b, 6)

#define GP_WB_GET_INT_CTRL_MASK_SSP_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SSP_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55b, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SSP_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_4() \
        GP_WB_READ_U8(0x55c)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_4(val) \
      GP_WB_WRITE_U8(0x55c, (val))

/* Mask the twi master done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_TWIMS_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 0)

#define GP_WB_GET_INT_CTRL_MASK_TWIMS_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TWIMS_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TWIMS_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the twi master arbitration lost interrupt */
#define GP_WB_READ_INT_CTRL_MASK_TWIMS_ARB_LOST_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 1)

#define GP_WB_GET_INT_CTRL_MASK_TWIMS_ARB_LOST_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TWIMS_ARB_LOST_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TWIMS_ARB_LOST_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the twi master clock synchronization slave wait interrupt */
#define GP_WB_READ_INT_CTRL_MASK_TWIMS_CLK_SYNC_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 2)

#define GP_WB_GET_INT_CTRL_MASK_TWIMS_CLK_SYNC_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TWIMS_CLK_SYNC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TWIMS_CLK_SYNC_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the interrupt for a fll vco measure done event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 3)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the interrupt for the fll out of lock event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 4)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_OUT_OF_LOCK_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_OUT_OF_LOCK_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_OUT_OF_LOCK_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the interrupt for the fll cp out of range event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 5)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Mask the KeyPad Scan interrupt */
#define GP_WB_READ_INT_CTRL_MASK_KPS_INT_INTERRUPT() \
        GP_WB_READ_U1(0x55c, 6)

#define GP_WB_GET_INT_CTRL_MASK_KPS_INT_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_KPS_INT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55c, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_KPS_INT_INTERRUPT_TO_MASK_SRC_INTERRUPTS_4(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_5() \
        GP_WB_READ_U8(0x55d)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_5(val) \
      GP_WB_WRITE_U8(0x55d, (val))

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 0)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 1)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 2)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 3)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 4)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Mask the watchdog timer expiredinterrupt */
#define GP_WB_READ_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(0x55d, 5)

#define GP_WB_GET_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55d, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT_TO_MASK_SRC_INTERRUPTS_5(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_6() \
        GP_WB_READ_U8(0x55e)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_6(val) \
      GP_WB_WRITE_U8(0x55e, (val))

/* Mask the IR sequence start interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(0x55e, 0)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_6(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55e, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT_TO_MASK_SRC_INTERRUPTS_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the IR sequence repeat interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(0x55e, 1)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55e, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT_TO_MASK_SRC_INTERRUPTS_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the IR sequence done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x55e, 2)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55e, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Mask the IR index match interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x55e, 3)

#define GP_WB_GET_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55e, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_6(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_7() \
        GP_WB_READ_U8(0x55f)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_7(val) \
      GP_WB_WRITE_U8(0x55f, (val))

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2EXT_FLAG_INTERRUPT() \
        (GP_WB_READ_U8(0x55f) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2EXT_FLAG_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2EXT_FLAG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x55f, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2EXT_FLAG_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2EXT_FLAG_A_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2EXT_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2EXT_FLAG_A_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2EXT_FLAG_B_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2EXT_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2EXT_FLAG_B_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2EXT_FLAG_C_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2EXT_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2EXT_FLAG_C_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2EXT_FLAG_D_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2EXT_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2EXT_FLAG_D_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2INT_FLAG_INTERRUPT() \
        ((GP_WB_READ_U8(0x55f) >> 4) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2INT_FLAG_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2INT_FLAG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x55f, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2INT_FLAG_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 4)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2INT_FLAG_A_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2INT_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2INT_FLAG_A_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 5)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2INT_FLAG_B_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2INT_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2INT_FLAG_B_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 6)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2INT_FLAG_C_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2INT_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2INT_FLAG_C_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x55f, 7)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2INT_FLAG_D_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2INT_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x55f, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2INT_FLAG_D_INTERRUPT_TO_MASK_SRC_INTERRUPTS_7(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_8() \
        GP_WB_READ_U8(0x560)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_8(val) \
      GP_WB_WRITE_U8(0x560, (val))

/* mask for gpio interrupts for exti 0 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(0x560, 0)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* mask for gpio interrupts for exti 1 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(0x560, 1)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* mask for gpio interrupts for exti 2 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(0x560, 2)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* mask for gpio interrupts for exti 3 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(0x560, 3)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* mask for gpio interrupts for exti 4 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(0x560, 4)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* mask for gpio interrupts for exti 5 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(0x560, 5)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* mask for gpio interrupts for exti 6 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(0x560, 6)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* mask for gpio interrupts for exti 7 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(0x560, 7)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x560, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT_TO_MASK_SRC_INTERRUPTS_8(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_9() \
        GP_WB_READ_U8(0x561)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_9(val) \
      GP_WB_WRITE_U8(0x561, (val))

/* mask for SPI master transfer not busy interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x561, 0)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* mask for SPI master TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x561, 1)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* mask for SPI master RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x561, 2)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* mask for SPI master RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x561, 3)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* mask for SPI slave TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x561, 4)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* mask for SPI slave RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x561, 5)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* mask for SPI slave TX buffer underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x561, 6)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* mask for SPI slave RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x561, 7)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x561, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_9(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_10() \
        GP_WB_READ_U8(0x562)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_10(val) \
      GP_WB_WRITE_U8(0x562, (val))

/* Mask the PWM main_counter_wrap interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_MAIN_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x562, 0)

#define GP_WB_GET_INT_CTRL_MASK_PWM_MAIN_COUNTER_WRAP_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_MAIN_COUNTER_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_MAIN_COUNTER_WRAP_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the PWM carrier_counter_wrap interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_CARRIER_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x562, 1)

#define GP_WB_GET_INT_CTRL_MASK_PWM_CARRIER_COUNTER_WRAP_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_CARRIER_COUNTER_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_CARRIER_COUNTER_WRAP_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the PWM next threshold underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x562, 2)

#define GP_WB_GET_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Mask the PWM next threshold not full interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x562, 3)

#define GP_WB_GET_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Mask the PWM threshold_match interrupt of pwm 0 */
#define GP_WB_READ_INT_CTRL_MASK_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x562, 4)

#define GP_WB_GET_INT_CTRL_MASK_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Mask the PWM threshold_match interrupt of pwm 1 */
#define GP_WB_READ_INT_CTRL_MASK_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x562, 5)

#define GP_WB_GET_INT_CTRL_MASK_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Mask the PWM threshold_match interrupt of pwm 2 */
#define GP_WB_READ_INT_CTRL_MASK_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x562, 6)

#define GP_WB_GET_INT_CTRL_MASK_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Mask the PWM threshold_match interrupt of pwm 3 */
#define GP_WB_READ_INT_CTRL_MASK_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x562, 7)

#define GP_WB_GET_INT_CTRL_MASK_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x562, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_10(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_11() \
        GP_WB_READ_U8(0x563)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_11(val) \
      GP_WB_WRITE_U8(0x563, (val))

/* Mask the PWM timestamp overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_TIMESTAMP_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x563, 0)

#define GP_WB_GET_INT_CTRL_MASK_PWM_TIMESTAMP_OVERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_TIMESTAMP_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_TIMESTAMP_OVERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the PWM timestamp not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x563, 1)

#define GP_WB_GET_INT_CTRL_MASK_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the TX buffer not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x563, 2)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Mask the RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x563, 3)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Mask the TX stretch interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(0x563, 4)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Mask the I2C START event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_START_INTERRUPT() \
        GP_WB_READ_U1(0x563, 5)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_START_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_START_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Mask the I2C STOP event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT() \
        GP_WB_READ_U1(0x563, 6)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Mask the I2C SLAD event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT() \
        GP_WB_READ_U1(0x563, 7)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x563, 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT_TO_MASK_SRC_INTERRUPTS_11(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_12() \
        GP_WB_READ_U8(0x564)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_12(val) \
      GP_WB_WRITE_U8(0x564, (val))

/* Mask the buffer a updated interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x564, 0)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the buffer b updated interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x564, 1)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the fifo not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x564, 2)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Mask the fifo overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x564, 3)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Mask the cycle done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x564, 4)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Mask the fifo overvoltage interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(0x564, 5)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x564, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT_TO_MASK_SRC_INTERRUPTS_12(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SRC_INTERRUPTS_13() \
        GP_WB_READ_U8(0x565)

#define GP_WB_WRITE_INT_CTRL_MASK_SRC_INTERRUPTS_13(val) \
      GP_WB_WRITE_U8(0x565, (val))

/* Mask the TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x565, 0)

#define GP_WB_GET_INT_CTRL_MASK_UART_TX_NOT_BUSY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_TX_NOT_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_TX_NOT_BUSY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mask the TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x565, 1)

#define GP_WB_GET_INT_CTRL_MASK_UART_TX_NOT_FULL_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_TX_NOT_FULL_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Mask the RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x565, 2)

#define GP_WB_GET_INT_CTRL_MASK_UART_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Mask the RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x565, 3)

#define GP_WB_GET_INT_CTRL_MASK_UART_RX_OVERRUN_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_RX_OVERRUN_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Mask the RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x565, 4)

#define GP_WB_GET_INT_CTRL_MASK_UART_RX_PARITY_ERROR_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_RX_PARITY_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_RX_PARITY_ERROR_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Mask the RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x565, 5)

#define GP_WB_GET_INT_CTRL_MASK_UART_RX_FRAMING_ERROR_INTERRUPT_FROM_MASK_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_RX_FRAMING_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x565, 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_RX_FRAMING_ERROR_INTERRUPT_TO_MASK_SRC_INTERRUPTS_13(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Masked ES Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASKED_ES_EVENT_INTERRUPT() \
        GP_WB_READ_U16(0x566)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_0() \
        GP_WB_READ_U8(0x568)

/* Masked symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(0x568, 0)

#define GP_WB_GET_INT_CTRL_MASKED_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        ((tmp) & 0x01)

/* Masked es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x568, 1)

#define GP_WB_GET_INT_CTRL_MASKED_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 1) & 0x01)

/* Masked es External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x568, 2)

#define GP_WB_GET_INT_CTRL_MASKED_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMA_SRC_ALMOST_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x568, 3)

#define GP_WB_GET_INT_CTRL_MASKED_DMA_SRC_ALMOST_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMA_DEST_ALMOST_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x568, 4)

#define GP_WB_GET_INT_CTRL_MASKED_DMA_DEST_ALMOST_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMA_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(0x568, 5)

#define GP_WB_GET_INT_CTRL_MASKED_DMA_CPY_ERR_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMA_SRC_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x568, 6)

#define GP_WB_GET_INT_CTRL_MASKED_DMA_SRC_UNDERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMA_DEST_OVERFLOW_INTERRUPT() \
        GP_WB_READ_U1(0x568, 7)

#define GP_WB_GET_INT_CTRL_MASKED_DMA_DEST_OVERFLOW_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_0(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_1() \
        GP_WB_READ_U8(0x569)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH0_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x569, 0)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH0_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH1_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x569, 1)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH1_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH2_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x569, 2)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH2_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH3_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x569, 3)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH3_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 3) & 0x01)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASKED_TRC_GENERIC_0_INTERRUPT() \
        GP_WB_READ_U1(0x569, 4)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_GENERIC_0_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 4) & 0x01)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASKED_TRC_GENERIC_1_INTERRUPT() \
        GP_WB_READ_U1(0x569, 5)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_GENERIC_1_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 5) & 0x01)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASKED_TRC_GENERIC_2_INTERRUPT() \
        GP_WB_READ_U1(0x569, 6)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_GENERIC_2_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 6) & 0x01)

/* Generic interrupt to be set by the mac filter */
#define GP_WB_READ_INT_CTRL_MASKED_TRC_GENERIC_3_INTERRUPT() \
        GP_WB_READ_U1(0x569, 7)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_GENERIC_3_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_1(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_2() \
        GP_WB_READ_U8(0x56a)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x56a, 0)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_PBM_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x56a, 1)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_TX_STARTED_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(0x56a, 2)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56a, 3)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_MACFILT_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(0x56a, 4)

#define GP_WB_GET_INT_CTRL_MASKED_MACFILT_LEVEL_TRIGGER_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_2(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_3() \
        GP_WB_READ_U8(0x56b)

/* >masked version of the standby controller event power on reset detected interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_PORD_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 0)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_PORD_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        ((tmp) & 0x01)

/* >masked version of the standby controller Active state interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 1)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_ACTIVE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked version of the standby controller iso_tx brownout */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_ISO_TX_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 2)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_ISO_TX_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked version of the standby controller vrr(=VCC1) brownout */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_VRR_BROWNOUT_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 3)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_VRR_BROWNOUT_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked version of the vlt_status interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 4)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_VLT_STATUS_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked for the mri write interrupt status */
#define GP_WB_READ_INT_CTRL_MASKED_MRI_WRITE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 5)

#define GP_WB_GET_INT_CTRL_MASKED_MRI_WRITE_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of masked ssp done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SSP_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56b, 6)

#define GP_WB_GET_INT_CTRL_MASKED_SSP_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_3(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_4() \
        GP_WB_READ_U8(0x56c)

/* Status of masked twi master done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_TWIMS_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 0)

#define GP_WB_GET_INT_CTRL_MASKED_TWIMS_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        ((tmp) & 0x01)

/* Status of masked twi master arbitration lost interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_TWIMS_ARB_LOST_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 1)

#define GP_WB_GET_INT_CTRL_MASKED_TWIMS_ARB_LOST_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of masked twi master clock synchronization slave wait interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_TWIMS_CLK_SYNC_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 2)

#define GP_WB_GET_INT_CTRL_MASKED_TWIMS_CLK_SYNC_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked interrupt status for a fll vco measure done event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 3)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_VCO_MEASURE_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked interrupt status for a fll out of lock event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 4)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_OUT_OF_LOCK_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked interrupt status for a fll CP out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 5)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_CP_OUT_OF_RANGE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of masked KeyPad Scan interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_KPS_INT_INTERRUPT() \
        GP_WB_READ_U1(0x56c, 6)

#define GP_WB_GET_INT_CTRL_MASKED_KPS_INT_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_4(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_5() \
        GP_WB_READ_U8(0x56d)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 0)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_IND_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_0_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 1)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_0_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_1_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 2)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_1_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_2_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 3)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_2_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_3_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 4)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_3_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status of masked timer expired interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_WATCHDOG_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(0x56d, 5)

#define GP_WB_GET_INT_CTRL_MASKED_WATCHDOG_TIMER_EXPIRED_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_5(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_6() \
        GP_WB_READ_U8(0x56e)

/* Status of masked IR sequence start interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(0x56e, 0)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_START_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_6(tmp) \
        ((tmp) & 0x01)

/* Status of masked IR sequence repeat interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(0x56e, 1)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_REPEAT_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of masked IR sequence done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x56e, 2)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status of masked IR index match interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IR_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x56e, 3)

#define GP_WB_GET_INT_CTRL_MASKED_IR_INDEX_MATCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_6(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_7() \
        GP_WB_READ_U8(0x56f)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2EXT_FLAG_INTERRUPT() \
        (GP_WB_READ_U8(0x56f) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2EXT_FLAG_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        ((tmp) & 0x0F)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2EXT_FLAG_A_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2EXT_FLAG_B_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2EXT_FLAG_C_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2EXT_FLAG_D_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2INT_FLAG_INTERRUPT() \
        ((GP_WB_READ_U8(0x56f) >> 4) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2INT_FLAG_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 4) & 0x0F)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 4)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2INT_FLAG_A_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 5)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2INT_FLAG_B_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 6)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2INT_FLAG_C_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked inter processor communication source interrupt status (int 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(0x56f, 7)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2INT_FLAG_D_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_7(tmp) \
        (((tmp) >> 7) & 0x01)


/* This bit enables the external interrupts */
#define GP_WB_READ_INT_CTRL_GLOBAL_INTERRUPTS_ENABLE() \
        GP_WB_READ_U1(0x570, 0)

#define GP_WB_WRITE_INT_CTRL_GLOBAL_INTERRUPTS_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x570, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_8() \
        GP_WB_READ_U8(0x571)

/* gpio interrupts masked status for exti 0 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(0x571, 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI0_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        ((tmp) & 0x01)

/* gpio interrupts masked status for exti 1 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(0x571, 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI1_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 1) & 0x01)

/* gpio interrupts masked status for exti 2 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(0x571, 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI2_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 2) & 0x01)

/* gpio interrupts masked status for exti 3 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(0x571, 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI3_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 3) & 0x01)

/* gpio interrupts masked status for exti 4 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(0x571, 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI4_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 4) & 0x01)

/* gpio interrupts masked status for exti 5 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(0x571, 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI5_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 5) & 0x01)

/* gpio interrupts masked status for exti 6 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(0x571, 6)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI6_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 6) & 0x01)

/* gpio interrupts masked status for exti 7 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(0x571, 7)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI7_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_8(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_9() \
        GP_WB_READ_U8(0x572)

/* masked status for SPI master transfer not busy interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x572, 0)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_NOT_BUSY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        ((tmp) & 0x01)

/* masked status for SPI master TX buffer not full interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x572, 1)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked status for SPI master RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x572, 2)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked status for SPI master RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x572, 3)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_RX_OVERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked status for SPI slave TX buffer not full interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x572, 4)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked status for SPI slave RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x572, 5)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked status for SPI slave TX buffer underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x572, 6)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_TX_UNDERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked status for SPI slave RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x572, 7)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_RX_OVERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_9(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_10() \
        GP_WB_READ_U8(0x573)

/* Status of masked PWM main_counter_wrap interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_MAIN_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x573, 0)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_MAIN_COUNTER_WRAP_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        ((tmp) & 0x01)

/* Status of masked PWM carrier_counter_wrap interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_CARRIER_COUNTER_WRAP_INTERRUPT() \
        GP_WB_READ_U1(0x573, 1)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_CARRIER_COUNTER_WRAP_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of masked PWM next threshold underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x573, 2)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status of masked PWM next threshold not full interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x573, 3)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status of masked PWM threshold_match interrupt of pwm 0 */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x573, 4)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_PWM0_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status of masked PWM threshold_match interrupt of pwm 1 */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x573, 5)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_PWM1_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of masked PWM threshold_match interrupt of pwm 2 */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x573, 6)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_PWM2_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status of masked PWM threshold_match interrupt of pwm 3 */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(0x573, 7)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_PWM3_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_10(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_11() \
        GP_WB_READ_U8(0x574)

/* Status of masked PWM timestamp overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_TIMESTAMP_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x574, 0)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_TIMESTAMP_OVERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        ((tmp) & 0x01)

/* Status of masked PWM timestamp not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x574, 1)

#define GP_WB_GET_INT_CTRL_MASKED_PWM_TIMESTAMP_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of masked TX buffer not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x574, 2)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status of masked RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x574, 3)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status of masked TX stretch interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(0x574, 4)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_TX_STRETCH_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status of masked I2C START event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_START_INTERRUPT() \
        GP_WB_READ_U1(0x574, 5)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_START_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of masked I2C STOP event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_STOP_INTERRUPT() \
        GP_WB_READ_U1(0x574, 6)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_STOP_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status of masked I2C SLAD event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_SLAD_INTERRUPT() \
        GP_WB_READ_U1(0x574, 7)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_SLAD_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_11(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_12() \
        GP_WB_READ_U8(0x575)

/* Masked status of the buffer a updated interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x575, 0)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_BUFFER_A_UPDATED_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        ((tmp) & 0x01)

/* Masked status of the buffer b updated interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(0x575, 1)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_BUFFER_B_UPDATED_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 1) & 0x01)

/* Masked status of the fifo not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x575, 2)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 2) & 0x01)

/* Masked status of the fifo overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x575, 3)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_FIFO_OVERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 3) & 0x01)

/* Masked status of the cycle done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x575, 4)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_CYCLE_DONE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 4) & 0x01)

/* Masked status of the fifo overvoltage interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(0x575, 5)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_OVERVOLTAGE_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_12(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SRC_INTERRUPTS_13() \
        GP_WB_READ_U8(0x576)

/* Masked status the TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(0x576, 0)

#define GP_WB_GET_INT_CTRL_MASKED_UART_TX_NOT_BUSY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        ((tmp) & 0x01)

/* Masked status the TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(0x576, 1)

#define GP_WB_GET_INT_CTRL_MASKED_UART_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 1) & 0x01)

/* Masked status the RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(0x576, 2)

#define GP_WB_GET_INT_CTRL_MASKED_UART_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 2) & 0x01)

/* Masked status the RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(0x576, 3)

#define GP_WB_GET_INT_CTRL_MASKED_UART_RX_OVERRUN_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 3) & 0x01)

/* Masked status the RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x576, 4)

#define GP_WB_GET_INT_CTRL_MASKED_UART_RX_PARITY_ERROR_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 4) & 0x01)

/* Masked status the RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(0x576, 5)

#define GP_WB_GET_INT_CTRL_MASKED_UART_RX_FRAMING_ERROR_INTERRUPT_FROM_MASKED_SRC_INTERRUPTS_13(tmp) \
        (((tmp) >> 5) & 0x01)

/***************************
 * layout: es
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_SETTING() \
        GP_WB_READ_U8(0x580)

#define GP_WB_WRITE_ES_TIME_REFERENCE_SETTING(val) \
      GP_WB_WRITE_U8(0x580, (val))

/* Enable Oscillator Benchmark */
#define GP_WB_READ_ES_ENABLE_OSCILLATOR_BENCHMARK() \
        GP_WB_READ_U1(0x580, 0)

#define GP_WB_GET_ES_ENABLE_OSCILLATOR_BENCHMARK_FROM_TIME_REFERENCE_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_OSCILLATOR_BENCHMARK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_OSCILLATOR_BENCHMARK_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Force Init Time Reference Done */
#define GP_WB_READ_ES_FORCE_INIT_TIME_REFERENCE_DONE() \
        GP_WB_READ_U1(0x580, 1)

#define GP_WB_GET_ES_FORCE_INIT_TIME_REFERENCE_DONE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_FORCE_INIT_TIME_REFERENCE_DONE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_FORCE_INIT_TIME_REFERENCE_DONE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Select on which edge of standby clock the gray counter is stable */
#define GP_WB_READ_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE() \
        GP_WB_READ_U1(0x580, 2)

#define GP_WB_GET_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Disable Automatic Reference Point Update */
#define GP_WB_READ_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE() \
        GP_WB_READ_U1(0x580, 3)

#define GP_WB_GET_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 3, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Reconversion on updates */
#define GP_WB_READ_ES_RECONVERSION_ON_UPDATES() \
        GP_WB_READ_U1(0x580, 4)

#define GP_WB_GET_ES_RECONVERSION_ON_UPDATES_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ES_RECONVERSION_ON_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 4, (val)); \
        } while (0)

#define GP_WB_SET_ES_RECONVERSION_ON_UPDATES_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Disable Extrapolation */
#define GP_WB_READ_ES_DISABLE_EXTRAPOLATION() \
        GP_WB_READ_U1(0x580, 5)

#define GP_WB_GET_ES_DISABLE_EXTRAPOLATION_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_EXTRAPOLATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 5, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_EXTRAPOLATION_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Disable Conversion */
#define GP_WB_READ_ES_DISABLE_CONVERSION() \
        GP_WB_READ_U1(0x580, 6)

#define GP_WB_GET_ES_DISABLE_CONVERSION_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_CONVERSION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x580, 6, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_CONVERSION_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_SETTING2() \
        GP_WB_READ_U8(0x581)

#define GP_WB_WRITE_ES_TIME_REFERENCE_SETTING2(val) \
      GP_WB_WRITE_U8(0x581, (val))

/* Fast Sync On Start */
#define GP_WB_READ_ES_FAST_SYNC_ON_START() \
        GP_WB_READ_U1(0x581, 0)

#define GP_WB_GET_ES_FAST_SYNC_ON_START_FROM_TIME_REFERENCE_SETTING2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_FAST_SYNC_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x581, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_FAST_SYNC_ON_START_TO_TIME_REFERENCE_SETTING2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable Sample Conversion By GPIO Extern */
#define GP_WB_READ_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN() \
        GP_WB_READ_U1(0x581, 1)

#define GP_WB_GET_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN_FROM_TIME_REFERENCE_SETTING2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x581, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN_TO_TIME_REFERENCE_SETTING2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


#define GP_WB_WRITE_ES_TIME_REFERENCE_CONTROL(val) \
      GP_WB_WRITE_U8(0x582, (val))

/* Apply Simple Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION() \
        GP_WB_WRITE_U8(0x582, 0x01)

#define GP_WB_SET_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Apply Advanced Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION() \
        GP_WB_WRITE_U8(0x582, 0x02)

#define GP_WB_SET_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Apply Zero Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_ZERO_CALIBRATION() \
        GP_WB_WRITE_U8(0x582, 0x04)

#define GP_WB_SET_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Sample Calibration */
#define GP_WB_ES_SAMPLE_CALIBRATION() \
        GP_WB_WRITE_U8(0x582, 0x08)

#define GP_WB_SET_ES_SAMPLE_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Sample Conversion */
#define GP_WB_ES_SAMPLE_CONVERSION() \
        GP_WB_WRITE_U8(0x582, 0x10)

#define GP_WB_SET_ES_SAMPLE_CONVERSION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Trigger Fast Sync */
#define GP_WB_ES_TRIGGER_FAST_SYNC() \
        GP_WB_WRITE_U8(0x582, 0x20)

#define GP_WB_SET_ES_TRIGGER_FAST_SYNC_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Trigger Oscillator Benchmark */
#define GP_WB_ES_TRIGGER_OSCILLATOR_BENCHMARK() \
        GP_WB_WRITE_U8(0x582, 0x40)

#define GP_WB_SET_ES_TRIGGER_OSCILLATOR_BENCHMARK_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Apply Startup Symbol Time */
#define GP_WB_ES_APPLY_STARTUP_SYMBOL_TIME() \
        GP_WB_WRITE_U8(0x582, 0x80)

#define GP_WB_SET_ES_APPLY_STARTUP_SYMBOL_TIME_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_STATE() \
        GP_WB_READ_U8(0x583)

/* Apply Simple Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_BUSY() \
        GP_WB_READ_U1(0x583, 0)

#define GP_WB_GET_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        ((tmp) & 0x01)

/* Apply Advanced Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_BUSY() \
        GP_WB_READ_U1(0x583, 1)

#define GP_WB_GET_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 1) & 0x01)

/* Apply Zero Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_BUSY() \
        GP_WB_READ_U1(0x583, 2)

#define GP_WB_GET_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 2) & 0x01)

/* Symbol Counter Updated Since Last Calibration */
#define GP_WB_READ_ES_SYMBOL_COUNTER_UPDATED_SINCE_LAST_CALIBRATION() \
        GP_WB_READ_U1(0x583, 3)

#define GP_WB_GET_ES_SYMBOL_COUNTER_UPDATED_SINCE_LAST_CALIBRATION_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 3) & 0x01)

/* Reconversion busy */
#define GP_WB_READ_ES_RECONVERSION_BUSY() \
        GP_WB_READ_U1(0x583, 4)

#define GP_WB_GET_ES_RECONVERSION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 4) & 0x01)

/* Init Event Scheduler Busy */
#define GP_WB_READ_ES_INIT_TIME_REFERENCE_BUSY() \
        GP_WB_READ_U1(0x583, 5)

#define GP_WB_GET_ES_INIT_TIME_REFERENCE_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 5) & 0x01)

/* Fast Sync Busy */
#define GP_WB_READ_ES_FAST_SYNC_BUSY() \
        GP_WB_READ_U1(0x583, 6)

#define GP_WB_GET_ES_FAST_SYNC_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_STATE2() \
        GP_WB_READ_U8(0x584)

/* First edge seen on sleep counter clock, oscillator_benchmark_counter starts incrementing on the system clock */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_FIRST_EDGE_SEEN() \
        GP_WB_READ_U1(0x584, 0)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_FIRST_EDGE_SEEN_FROM_TIME_REFERENCE_STATE2(tmp) \
        ((tmp) & 0x01)

/* Second edge seen on sleep counter clock, oscillator_benchmark_counter can be read out safely */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SECOND_EDGE_SEEN() \
        GP_WB_READ_U1(0x584, 1)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_SECOND_EDGE_SEEN_FROM_TIME_REFERENCE_STATE2(tmp) \
        (((tmp) >> 1) & 0x01)


/* Auto Sample Symbol Counter */
#define GP_WB_READ_ES_AUTO_SAMPLED_SYMBOL_COUNTER() \
        GP_WB_READ_U32(0x586)


/* Binary gray counter */
#define GP_WB_READ_ES_BINARY_GRAY_COUNTER() \
        GP_WB_READ_U32(0x58a)

#define GP_WB_WRITE_ES_BINARY_GRAY_COUNTER(val) do { \
          GP_WB_WRITE_U32(0x58a, (val)); \
        } while (0)


/* Symbol counter */
#define GP_WB_READ_ES_SYMBOL_COUNTER() \
        GP_WB_READ_U32(0x58e)

#define GP_WB_WRITE_ES_SYMBOL_COUNTER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_WRITE_U32(0x58e, (val)); \
        } while (0)


/* Oscillator benchmark */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_COUNTER() \
        GP_WB_READ_U24(0x592)


/* Startup symbol time */
#define GP_WB_READ_ES_STARTUP_SYMBOL_TIME() \
        GP_WB_READ_U32(0x596)

#define GP_WB_WRITE_ES_STARTUP_SYMBOL_TIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_WRITE_U32(0x596, (val)); \
        } while (0)


/* Startup long symbol time */
#define GP_WB_READ_ES_LONG_STARTUP_SYMBOL_TIME() \
        GP_WB_READ_U32(0x59a)

#define GP_WB_WRITE_ES_LONG_STARTUP_SYMBOL_TIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_WRITE_U32(0x59a, (val)); \
        } while (0)


/* Binary gray counter reference */
#define GP_WB_READ_ES_BINARY_GRAY_COUNTER_REFERENCE() \
        GP_WB_READ_U32(0x59e)

#define GP_WB_WRITE_ES_BINARY_GRAY_COUNTER_REFERENCE(val) do { \
          GP_WB_WRITE_U32(0x59e, (val)); \
        } while (0)


/* Symbol counter reference */
#define GP_WB_READ_ES_SYMBOL_COUNTER_REFERENCE() \
        GP_WB_READ_U32(0x5a2)

#define GP_WB_WRITE_ES_SYMBOL_COUNTER_REFERENCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_WRITE_U32(0x5a2, (val)); \
        } while (0)


/* Calibration factor */
#define GP_WB_READ_ES_CALIBRATION_FACTOR() \
        GP_WB_READ_U32(0x5a6)

#define GP_WB_WRITE_ES_CALIBRATION_FACTOR(val) do { \
          GP_WB_WRITE_U32(0x5a6, (val)); \
        } while (0)


/* Phase compensation */
#define GP_WB_READ_ES_PHASE_COMPENSATION() \
        GP_WB_READ_U32(0x5aa)

#define GP_WB_WRITE_ES_PHASE_COMPENSATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_WRITE_U32(0x5aa, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_ENABLE_CLK_BY_UC() \
        GP_WB_READ_U8(0x5ae)

#define GP_WB_WRITE_ES_TIME_REFERENCE_ENABLE_CLK_BY_UC(val) \
      GP_WB_WRITE_U8(0x5ae, (val))

/* Enable clk time reference base a by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC() \
        GP_WB_READ_U1(0x5ae, 0)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5ae, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable clk time reference base b by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC() \
        GP_WB_READ_U1(0x5ae, 1)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5ae, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable clk time reference io by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC() \
        GP_WB_READ_U1(0x5ae, 2)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5ae, 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Enable clk time reference oscillator benchmark by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC() \
        GP_WB_READ_U1(0x5ae, 3)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5ae, 3, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Valid Events */
#define GP_WB_READ_ES_VALID_EVENTS() \
        GP_WB_READ_U16(0x5b0)

#define GP_WB_WRITE_ES_VALID_EVENTS(val) do { \
          GP_WB_WRITE_U16(0x5b0, (val)); \
        } while (0)


/* Buffer time */
#define GP_WB_READ_ES_BUFFER_TIME() \
        GP_WB_READ_U16(0x5b2)

#define GP_WB_WRITE_ES_BUFFER_TIME(val) do { \
          GP_WB_WRITE_U16(0x5b2, (val)); \
        } while (0)


/* Priotiry time */
#define GP_WB_READ_ES_PRIORITY_TIME() \
        GP_WB_READ_U16(0x5b4)

#define GP_WB_WRITE_ES_PRIORITY_TIME(val) do { \
          GP_WB_WRITE_U16(0x5b4, (val)); \
        } while (0)


/* Guard Time Selector */
#define GP_WB_READ_ES_GUARD_TIME_SEL() \
        GP_WB_READ_U8(0x5b6)

#define GP_WB_WRITE_ES_GUARD_TIME_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1F); \
          GP_WB_WRITE_U8(0x5b6, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_SETTING() \
        GP_WB_READ_U8(0x5b7)

#define GP_WB_WRITE_ES_EVENT_HANDLER_SETTING(val) \
      GP_WB_WRITE_U8(0x5b7, (val))

/* Overwrite execution time on final execution */
#define GP_WB_READ_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION() \
        GP_WB_READ_U1(0x5b7, 0)

#define GP_WB_GET_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION_FROM_EVENT_HANDLER_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5b7, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Freeze relative event countdown */
#define GP_WB_READ_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN() \
        GP_WB_READ_U1(0x5b7, 1)

#define GP_WB_GET_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN_FROM_EVENT_HANDLER_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5b7, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* External event valid */
#define GP_WB_READ_ES_EXTERNAL_EVENT_VALID() \
        GP_WB_READ_U1(0x5b7, 2)

#define GP_WB_GET_ES_EXTERNAL_EVENT_VALID_FROM_EVENT_HANDLER_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_VALID(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5b7, 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_EXTERNAL_EVENT_VALID_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* External event type */
#define GP_WB_READ_ES_EXTERNAL_EVENT_TYPE_TO_BE_EXECUTED() \
        GP_WB_READ_U8(0x5b8)

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_TYPE_TO_BE_EXECUTED(val) do { \
          GP_WB_WRITE_U8(0x5b8, (val)); \
        } while (0)


/* Custom data of external event */
#define GP_WB_READ_ES_EXTERNAL_EVENT_CUSTOM_DATA() \
        GP_WB_READ_U16(0x5ba)

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_CUSTOM_DATA(val) do { \
          GP_WB_WRITE_U16(0x5ba, (val)); \
        } while (0)


#define GP_WB_WRITE_ES_EVENT_HANDLER_CONTROL(val) \
      GP_WB_WRITE_U8(0x5bc, (val))

/* Reevaluate events */
#define GP_WB_ES_REEVALUATE_EVENTS() \
        GP_WB_WRITE_U8(0x5bc, 0x01)

#define GP_WB_SET_ES_REEVALUATE_EVENTS_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Execute Event Immediately */
#define GP_WB_ES_RELATIVE_EVENT_EXECUTE() \
        GP_WB_WRITE_U8(0x5bc, 0x02)

#define GP_WB_SET_ES_RELATIVE_EVENT_EXECUTE_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Cancel relative event */
#define GP_WB_ES_RELATIVE_EVENT_CANCEL() \
        GP_WB_WRITE_U8(0x5bc, 0x04)

#define GP_WB_SET_ES_RELATIVE_EVENT_CANCEL_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Relative event type */
#define GP_WB_READ_ES_RELATIVE_EVENT_TYPE_TO_BE_EXECUTED() \
        GP_WB_READ_U8(0x5bd)

#define GP_WB_WRITE_ES_RELATIVE_EVENT_TYPE_TO_BE_EXECUTED(val) do { \
          GP_WB_WRITE_U8(0x5bd, (val)); \
        } while (0)


/* Custom data of relative event */
#define GP_WB_READ_ES_RELATIVE_EVENT_CUSTOM_DATA() \
        GP_WB_READ_U16(0x5be)

#define GP_WB_WRITE_ES_RELATIVE_EVENT_CUSTOM_DATA(val) do { \
          GP_WB_WRITE_U16(0x5be, (val)); \
        } while (0)


/* Relative event time delay */
#define GP_WB_READ_ES_RELATIVE_EVENT_TIME_DELAY() \
        GP_WB_READ_U8(0x5c0)

#define GP_WB_WRITE_ES_RELATIVE_EVENT_TIME_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x5c0, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_RELATIVE_EVENT_STATUS() \
        GP_WB_READ_U8(0x5c1)

/* Relative event count down */
#define GP_WB_READ_ES_RELATIVE_EVENT_COUNTDOWN() \
        (GP_WB_READ_U8(0x5c1) & 0x7F)

#define GP_WB_GET_ES_RELATIVE_EVENT_COUNTDOWN_FROM_RELATIVE_EVENT_STATUS(tmp) \
        ((tmp) & 0x7F)

/* Relative event pending */
#define GP_WB_READ_ES_RELATIVE_EVENT_PENDING() \
        GP_WB_READ_U1(0x5c1, 7)

#define GP_WB_GET_ES_RELATIVE_EVENT_PENDING_FROM_RELATIVE_EVENT_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)


/* Dither seed */
#define GP_WB_READ_ES_DITHER_SEED() \
        GP_WB_READ_U16(0x5c2)

#define GP_WB_WRITE_ES_DITHER_SEED(val) do { \
          GP_WB_WRITE_U16(0x5c2, (val)); \
        } while (0)


/* Dither backoff exponent mask */
#define GP_WB_READ_ES_DITHER_BACKOFF_EXPONENT_MASK() \
        GP_WB_READ_U8(0x5c4)

#define GP_WB_WRITE_ES_DITHER_BACKOFF_EXPONENT_MASK(val) do { \
          GP_WB_WRITE_U8(0x5c4, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_STATE() \
        GP_WB_READ_U8(0x5c5)

/* Current Event Number */
#define GP_WB_READ_ES_CURRENT_EVENT_NUMBER() \
        (GP_WB_READ_U8(0x5c5) & 0x0F)

#define GP_WB_GET_ES_CURRENT_EVENT_NUMBER_FROM_EVENT_HANDLER_STATE(tmp) \
        ((tmp) & 0x0F)

/* Current Event Pending */
#define GP_WB_READ_ES_CURRENT_EVENT_PENDING() \
        GP_WB_READ_U1(0x5c5, 4)

#define GP_WB_GET_ES_CURRENT_EVENT_PENDING_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 4) & 0x01)

/* Current Event Being Executed */
#define GP_WB_READ_ES_CURRENT_EVENT_BEING_EXECUTED() \
        GP_WB_READ_U1(0x5c5, 5)

#define GP_WB_GET_ES_CURRENT_EVENT_BEING_EXECUTED_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 5) & 0x01)

/* Next Event Search Busy */
#define GP_WB_READ_ES_NEXT_EVENT_SEARCH_BUSY() \
        GP_WB_READ_U1(0x5c5, 6)

#define GP_WB_GET_ES_NEXT_EVENT_SEARCH_BUSY_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_ENABLE_CLK_BY_UC() \
        GP_WB_READ_U8(0x5c6)

#define GP_WB_WRITE_ES_EVENT_HANDLER_ENABLE_CLK_BY_UC(val) \
      GP_WB_WRITE_U8(0x5c6, (val))

/* Enable clk event handler base a by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC() \
        GP_WB_READ_U1(0x5c6, 0)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5c6, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable clk event handler base b by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC() \
        GP_WB_READ_U1(0x5c6, 1)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5c6, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable clk event handler external event by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC() \
        GP_WB_READ_U1(0x5c6, 2)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5c6, 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


#define GP_WB_READ_ES_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(0x5c7, 0)


/* Clear symbol counter interrupt */
#define GP_WB_ES_CLR_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_WRITE_U8(0x5c8, 0x01)


/* Unmasked Event Interrupts */
#define GP_WB_READ_ES_UNMASKED_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(0x5ca)


/* Clear Event Interrupts */
#define GP_WB_WRITE_ES_CLR_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(0x5cc, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U8(0x5ce)

/* Unmasked Relative Event Interrupt */
#define GP_WB_READ_ES_UNMASKED_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x5ce, 0)

#define GP_WB_GET_ES_UNMASKED_RELATIVE_EVENT_INTERRUPT_FROM_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp) \
        ((tmp) & 0x01)

/* Unmasked External Event Interrupt */
#define GP_WB_READ_ES_UNMASKED_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x5ce, 1)

#define GP_WB_GET_ES_UNMASKED_EXTERNAL_EVENT_INTERRUPT_FROM_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp) \
        (((tmp) >> 1) & 0x01)


#define GP_WB_WRITE_ES_CLR_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(val) \
      GP_WB_WRITE_U8(0x5cf, (val))

/* Clear Relative Event Interrupt */
#define GP_WB_ES_CLR_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_WRITE_U8(0x5cf, 0x01)

#define GP_WB_SET_ES_CLR_RELATIVE_EVENT_INTERRUPT_TO_CLR_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear External Event Interrupt */
#define GP_WB_ES_CLR_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_WRITE_U8(0x5cf, 0x02)

#define GP_WB_SET_ES_CLR_EXTERNAL_EVENT_INTERRUPT_TO_CLR_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Retention unmasked symbol counter interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(0x5d0, 0)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x5d0, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U8(0x5d1)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(val) \
      GP_WB_WRITE_U8(0x5d1, (val))

/* Retention unmasked Relative Event Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x5d1, 0)

#define GP_WB_GET_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT_FROM_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5d1, 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT_TO_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Retention unmasked External Event Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(0x5d1, 1)

#define GP_WB_GET_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT_FROM_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x5d1, 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT_TO_RETENTION_UNMASKED_RELATIVE_AND_EXTERNAL_EVENT_INTERRUPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Retention unmasked event Interrupts */
#define GP_WB_READ_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(0x5d2)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(0x5d2, (val)); \
        } while (0)

/***************************
 * layout: pmud
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_STANDBY_SETTINGS() \
        GP_WB_READ_U8(0x600)

#define GP_WB_WRITE_PMUD_STANDBY_SETTINGS(val) \
      GP_WB_WRITE_U8(0x600, (val))

/* Standby mode selection: 0x00 = Standby 0 (RC / 8 kHz osc.), 0x01 = Standby 1 (32 kHz osc.), 0x02 = Standby 2 (16 MHz) */
#define GP_WB_READ_PMUD_STBY_MODE() \
        (GP_WB_READ_U8(0x600) & 0x03)

#define GP_WB_GET_PMUD_STBY_MODE_FROM_STANDBY_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_STBY_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x600, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_STBY_MODE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Make XOSC ready high for XOSC test used both in analog domain as locally in the pmud */
#define GP_WB_READ_PMUD_XOSC_RDY_OVERRIDE() \
        GP_WB_READ_U1(0x600, 2)

#define GP_WB_GET_PMUD_XOSC_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_XOSC_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_XOSC_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of vdddig_rdy, used locally in pmud */
#define GP_WB_READ_PMUD_VDDDIG_RDY_OVERRIDE() \
        GP_WB_READ_U1(0x600, 3)

#define GP_WB_GET_PMUD_VDDDIG_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_VDDDIG_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VDDDIG_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* This is a debug bit allowing to bypass the vmt_st check (which is used a a wakup gating condition) */
#define GP_WB_READ_PMUD_DISABLE_VMT_ST() \
        GP_WB_READ_U1(0x600, 4)

#define GP_WB_GET_PMUD_DISABLE_VMT_ST_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_VMT_ST(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_VMT_ST_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* This is a debug bit allowing to bypass the vddb_cutoff result, which gates the power_up of the digital */
#define GP_WB_READ_PMUD_DISABLE_VDDB_CUTOFF() \
        GP_WB_READ_U1(0x600, 5)

#define GP_WB_GET_PMUD_DISABLE_VDDB_CUTOFF_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_VDDB_CUTOFF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_VDDB_CUTOFF_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* when set, the pmua will stop vmt measurements. Not really a good idea to do that as it will kill vddret regulation too. */
#define GP_WB_READ_PMUD_VMT_DIS() \
        GP_WB_READ_U1(0x600, 6)

#define GP_WB_GET_PMUD_VMT_DIS_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_VMT_DIS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VMT_DIS_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* when set, vmt duty cycled measuerement is enabled (for power saving) */
#define GP_WB_READ_PMUD_VMT_THROTTLE() \
        GP_WB_READ_U1(0x600, 7)

#define GP_WB_GET_PMUD_VMT_THROTTLE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_VMT_THROTTLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x600, 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VMT_THROTTLE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* selection of the digital voltage used for vddram[3:0]; vdddig or vddram */
#define GP_WB_READ_PMUD_VDDRAM_SEL() \
        GP_WB_READ_U8(0x601)

#define GP_WB_WRITE_PMUD_VDDRAM_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x601, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_RAM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U8(0x602)

#define GP_WB_WRITE_PMUD_RAM_BLOCK_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U8(0x602, (val))

/* Does the logical to physical mapping of the first 4 kB of logical ram addresses */
#define GP_WB_READ_PMUD_RAM_BLOCK_REMAP_ENTRY_0() \
        (GP_WB_READ_U8(0x602) & 0x03)

#define GP_WB_GET_PMUD_RAM_BLOCK_REMAP_ENTRY_0_FROM_RAM_BLOCK_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_RAM_BLOCK_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x602, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_RAM_BLOCK_REMAP_ENTRY_0_TO_RAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Does the logical to physical mapping of the second 4 kB of logical ram addresses */
#define GP_WB_READ_PMUD_RAM_BLOCK_REMAP_ENTRY_1() \
        ((GP_WB_READ_U8(0x602) >> 2) & 0x03)

#define GP_WB_GET_PMUD_RAM_BLOCK_REMAP_ENTRY_1_FROM_RAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_RAM_BLOCK_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x602, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_RAM_BLOCK_REMAP_ENTRY_1_TO_RAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Does the logical to physical mapping of the third 4 kB of logical ram addresses */
#define GP_WB_READ_PMUD_RAM_BLOCK_REMAP_ENTRY_2() \
        ((GP_WB_READ_U8(0x602) >> 4) & 0x03)

#define GP_WB_GET_PMUD_RAM_BLOCK_REMAP_ENTRY_2_FROM_RAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_RAM_BLOCK_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x602, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_RAM_BLOCK_REMAP_ENTRY_2_TO_RAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Does the logical to physical mapping of the fourth 4 kB of logical ram addresses */
#define GP_WB_READ_PMUD_RAM_BLOCK_REMAP_ENTRY_3() \
        ((GP_WB_READ_U8(0x602) >> 6) & 0x03)

#define GP_WB_GET_PMUD_RAM_BLOCK_REMAP_ENTRY_3_FROM_RAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_RAM_BLOCK_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x602, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_RAM_BLOCK_REMAP_ENTRY_3_TO_RAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* Locks the ram block remapping */
#define GP_WB_READ_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U1(0x603, 0)

#define GP_WB_WRITE_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x603, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_GPIO_CONTROL() \
        GP_WB_READ_U16(0x604)

#define GP_WB_WRITE_PMUD_GPIO_CONTROL(val) \
      GP_WB_WRITE_U16(0x604, (val))

/* When set to 1, the different gpio sources have access to the ioring. When set to 0, the ioring is in a off state, where all gpio macros are switched to input mode */
#define GP_WB_READ_PMUD_GPIO_FUNCTION_ENABLE() \
        GP_WB_READ_U1(0x604, 0)

#define GP_WB_GET_PMUD_GPIO_FUNCTION_ENABLE_FROM_GPIO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_FUNCTION_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x604, 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_FUNCTION_ENABLE_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When set to 1 a gpio wakeup event will be latched even if vmt status indicates that VDDB is too low. Actual wakeup occurs when the vddb is above vmt threshold */
#define GP_WB_READ_PMUD_GPIO_EV_DELAY() \
        GP_WB_READ_U1(0x604, 1)

#define GP_WB_GET_PMUD_GPIO_EV_DELAY_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_EV_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x604, 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_EV_DELAY_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Determines the repetition periode of the pull-up enable / strong drive pulse during sleep. This enables a duty cycled pull up or strong drive for those io cells that have the duvty cycled pull up or strong drive enabled. The period is 2**gpio_pulse_period * standby_clk_period (which is around 30 us, but depends on the chosen sleep mode). When set to 0, to pulse is generated */
#define GP_WB_READ_PMUD_GPIO_PULSE_PERIOD() \
        ((GP_WB_READ_U8(0x604) >> 2) & 0x0F)

#define GP_WB_GET_PMUD_GPIO_PULSE_PERIOD_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_PMUD_GPIO_PULSE_PERIOD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x604, 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_PULSE_PERIOD_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x01C3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* When set, the gpio 4 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_4_USE_LATCHED_DI() \
        GP_WB_READ_U1(0x604, 6)

#define GP_WB_GET_PMUD_GPIO_4_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_4_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x604, 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_4_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* When set, the gpio 7 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_7_USE_LATCHED_DI() \
        GP_WB_READ_U1(0x604, 7)

#define GP_WB_GET_PMUD_GPIO_7_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_7_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x604, 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_7_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* When set, the gpio 10 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_10_USE_LATCHED_DI() \
        GP_WB_READ_U1(0x605, 0)

#define GP_WB_GET_PMUD_GPIO_10_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_10_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x605, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_10_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_WAKEUP_PIN_SETTINGS() \
        GP_WB_READ_U24(0x606)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_SETTINGS(val) \
      GP_WB_WRITE_U24(0x606, (val))

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_0() \
        (GP_WB_READ_U8(0x606) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_0_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x606, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_0_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFC; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_1() \
        ((GP_WB_READ_U8(0x606) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_1_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x606, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_1_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFF3; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_2() \
        ((GP_WB_READ_U8(0x606) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_2_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x606, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_2_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFCF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_3() \
        ((GP_WB_READ_U8(0x606) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_3_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x606, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_3_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFF3F; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_4() \
        (GP_WB_READ_U8(0x607) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_4_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x607, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_4_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFCFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_5() \
        ((GP_WB_READ_U8(0x607) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_5_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x607, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_5_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFF3FF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_6() \
        ((GP_WB_READ_U8(0x607) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_6_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x607, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_6_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFCFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_7() \
        ((GP_WB_READ_U8(0x607) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_7_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x607, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_7_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFF3FFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_8() \
        (GP_WB_READ_U8(0x608) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_8_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_8(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x608, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_8_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFCFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_9() \
        ((GP_WB_READ_U8(0x608) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_9_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_9(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x608, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_9_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3FFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_10() \
        ((GP_WB_READ_U8(0x608) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_10_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 20) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_10(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x608, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_10_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_11() \
        ((GP_WB_READ_U8(0x608) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_11_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_11(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x608, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_11_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_SOFT_POR_TRIGGERS() \
        GP_WB_READ_U8(0x609)

#define GP_WB_WRITE_PMUD_SOFT_POR_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x609, (val))

/* Power on reset trigger - generic one to be used by main SW in active mode */
#define GP_WB_READ_PMUD_SOFT_POR() \
        GP_WB_READ_U1(0x609, 0)

#define GP_WB_GET_PMUD_SOFT_POR_FROM_SOFT_POR_TRIGGERS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x609, 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Power on reset trigger - to be used to trigger a soft por when ram mw was invalid at startup */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_RAM_MW() \
        GP_WB_READ_U1(0x609, 1)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_RAM_MW_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_RAM_MW(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x609, 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_RAM_MW_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Power on reset trigger - to be used to trigger a soft por when ram crc was invalid at startup */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_RAM_CRC() \
        GP_WB_READ_U1(0x609, 2)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_RAM_CRC_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_RAM_CRC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x609, 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_RAM_CRC_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Power on reset trigger - Used to trigger a soft por when there is a flash bootloader crc failure */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC() \
        GP_WB_READ_U1(0x609, 3)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x609, 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Power on reset trigger - Used to trigger a generic soft por from bootloader */
#define GP_WB_READ_PMUD_SOFT_POR_BOOTLOADER() \
        GP_WB_READ_U1(0x609, 4)

#define GP_WB_GET_PMUD_SOFT_POR_BOOTLOADER_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_BOOTLOADER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x609, 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_BOOTLOADER_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_ANALOG_TUNING_0() \
        GP_WB_READ_U8(0x60a)

#define GP_WB_WRITE_PMUD_ANALOG_TUNING_0(val) \
      GP_WB_WRITE_U8(0x60a, (val))

/* Tune bandgap voltage (Typical 0.6V) */
#define GP_WB_READ_PMUD_BG_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(0x60a) & 0x0F), 4))

#define GP_WB_GET_PMUD_BG_TUNE_FROM_ANALOG_TUNING_0(tmp) \
        (GP_WB_S8(((tmp) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_BG_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(0x60a, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_BG_TUNE_TO_ANALOG_TUNING_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          (tmp) &= 0xF0; \
          (tmp) |= (((Int8)(val)) & 0x0F); \
        } while (0)

/* Voltage tuning of the digital retention ldo */
#define GP_WB_READ_PMUD_VDDRET_TUNE() \
        (GP_WB_S8(((GP_WB_READ_U8(0x60a) >> 4) & 0x0F), 4))

#define GP_WB_GET_PMUD_VDDRET_TUNE_FROM_ANALOG_TUNING_0(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_VDDRET_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(0x60a, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_VDDRET_TUNE_TO_ANALOG_TUNING_0(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          (tmp) &= 0x0F; \
          (tmp) |= ((((Int8)(val)) << 4) & 0xF0); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_ANALOG_TUNING_1() \
        GP_WB_READ_U8(0x60b)

#define GP_WB_WRITE_PMUD_ANALOG_TUNING_1(val) \
      GP_WB_WRITE_U8(0x60b, (val))

/* Tuning of the main digital ldo */
#define GP_WB_READ_PMUD_VDDDIG_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(0x60b) & 0x1F), 5))

#define GP_WB_GET_PMUD_VDDDIG_TUNE_FROM_ANALOG_TUNING_1(tmp) \
        (GP_WB_S8(((tmp) & 0x1F), 5))

#define GP_WB_WRITE_PMUD_VDDDIG_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_MWRITE_U8(0x60b, 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VDDDIG_TUNE_TO_ANALOG_TUNING_1(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          (tmp) &= 0xE0; \
          (tmp) |= (((Int8)(val)) & 0x1F); \
        } while (0)

/* Enables a 10 k resistor in parallel to the vdddig_ldo */
#define GP_WB_READ_PMUD_VDDDIG_BLEED_ENA() \
        GP_WB_READ_U1(0x60b, 5)

#define GP_WB_GET_PMUD_VDDDIG_BLEED_ENA_FROM_ANALOG_TUNING_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_VDDDIG_BLEED_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60b, 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VDDDIG_BLEED_ENA_TO_ANALOG_TUNING_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* XOSC AGC level setting */
#define GP_WB_READ_PMUD_XOSC_LEVEL() \
        (GP_WB_S8(((GP_WB_READ_U8(0x60b) >> 6) & 0x03), 2))

#define GP_WB_GET_PMUD_XOSC_LEVEL_FROM_ANALOG_TUNING_1(tmp) \
        (GP_WB_S8((((tmp) >> 6) & 0x03), 2))

#define GP_WB_WRITE_PMUD_XOSC_LEVEL(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          GP_WB_MWRITE_U8(0x60b, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_XOSC_LEVEL_TO_ANALOG_TUNING_1(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2, 1); \
          (tmp) &= 0x3F; \
          (tmp) |= ((((Int8)(val)) << 6) & 0xC0); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_ANALOG_TUNING_2() \
        GP_WB_READ_U8(0x60c)

#define GP_WB_WRITE_PMUD_ANALOG_TUNING_2(val) \
      GP_WB_WRITE_U8(0x60c, (val))

/* Current tuning reference REFAMP: this tracks HR Res : not calibrated */
#define GP_WB_READ_PMUD_REFAMP1_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(0x60c) & 0x07), 3))

#define GP_WB_GET_PMUD_REFAMP1_TUNE_FROM_ANALOG_TUNING_2(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

#define GP_WB_WRITE_PMUD_REFAMP1_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x60c, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_REFAMP1_TUNE_TO_ANALOG_TUNING_2(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x38; \
          (tmp) |= (((Int8)(val)) & 0x07); \
        } while (0)

/* Current tuning bias REFAMP */
#define GP_WB_READ_PMUD_REFAMP2_TUNE() \
        (GP_WB_S8(((GP_WB_READ_U8(0x60c) >> 3) & 0x07), 3))

#define GP_WB_GET_PMUD_REFAMP2_TUNE_FROM_ANALOG_TUNING_2(tmp) \
        (GP_WB_S8((((tmp) >> 3) & 0x07), 3))

#define GP_WB_WRITE_PMUD_REFAMP2_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(0x60c, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PMUD_REFAMP2_TUNE_TO_ANALOG_TUNING_2(tmp, val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x07; \
          (tmp) |= ((((Int8)(val)) << 3) & 0x38); \
        } while (0)


/* defines the threshold for the vmt_st measurement */
#define GP_WB_READ_PMUD_VMT() \
        GP_WB_READ_U8(0x60d)

#define GP_WB_WRITE_PMUD_VMT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x60d, (val)); \
        } while (0)


/* debug feature for tuning 8kHz osc. For normal operation the osc does not need tuning */
#define GP_WB_READ_PMUD_RC8K_TUNE() \
        (GP_WB_S8(GP_WB_READ_U8(0x60e), 5))

#define GP_WB_WRITE_PMUD_RC8K_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_WRITE_U8(0x60e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_ANALOG_TEST_CONTROL_0() \
        GP_WB_READ_U8(0x60f)

#define GP_WB_WRITE_PMUD_ANALOG_TEST_CONTROL_0(val) \
      GP_WB_WRITE_U8(0x60f, (val))

/* Select test in selected block to measure */
#define GP_WB_READ_PMUD_TEST_SEL() \
        (GP_WB_READ_U8(0x60f) & 0x07)

#define GP_WB_GET_PMUD_TEST_SEL_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PMUD_TEST_SEL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x60f, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_SEL_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Connect test bus unbuffered to IO pads */
#define GP_WB_READ_PMUD_TEST_NOT_BUF_ENA() \
        GP_WB_READ_U1(0x60f, 3)

#define GP_WB_GET_PMUD_TEST_NOT_BUF_ENA_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_NOT_BUF_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60f, 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_NOT_BUF_ENA_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Power up the two test buffers for buffered measurements */
#define GP_WB_READ_PMUD_TEST_BUF_PUP() \
        GP_WB_READ_U1(0x60f, 4)

#define GP_WB_GET_PMUD_TEST_BUF_PUP_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60f, 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BUF_PUP_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Test-mode : turn AGC off */
#define GP_WB_READ_PMUD_XOSC_AGC_OFF() \
        GP_WB_READ_U1(0x60f, 5)

#define GP_WB_GET_PMUD_XOSC_AGC_OFF_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_XOSC_AGC_OFF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60f, 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_XOSC_AGC_OFF_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Delta current measurement XOSC, cuts clock: reset needed */
#define GP_WB_READ_PMUD_XOSC_DISABLE_PUP() \
        GP_WB_READ_U1(0x60f, 6)

#define GP_WB_GET_PMUD_XOSC_DISABLE_PUP_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_XOSC_DISABLE_PUP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60f, 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_XOSC_DISABLE_PUP_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enables the ringoscillator for process measurement - only works when pmud is in active mode (and hence vdddig is enabled and ready) */
#define GP_WB_READ_PMUD_RINGOSC_ENA() \
        GP_WB_READ_U1(0x60f, 7)

#define GP_WB_GET_PMUD_RINGOSC_ENA_FROM_ANALOG_TEST_CONTROL_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_RINGOSC_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x60f, 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_RINGOSC_ENA_TO_ANALOG_TEST_CONTROL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_DEBUG() \
        GP_WB_READ_U8(0x610)

#define GP_WB_WRITE_PMUD_DEBUG(val) \
      GP_WB_WRITE_U8(0x610, (val))

/* register to disable 2 lpr modes */
#define GP_WB_READ_PMUD_LPR_DEBUG() \
        (GP_WB_READ_U8(0x610) & 0x03)

#define GP_WB_GET_PMUD_LPR_DEBUG_FROM_DEBUG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_LPR_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x610, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPR_DEBUG_TO_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x04; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Determines if the LL or HS oscillator is used */
#define GP_WB_READ_PMUD_RINGOSC_HS() \
        GP_WB_READ_U1(0x610, 2)

#define GP_WB_GET_PMUD_RINGOSC_HS_FROM_DEBUG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_RINGOSC_HS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x610, 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_RINGOSC_HS_TO_DEBUG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_TEST_BLOCK_ENA() \
        GP_WB_READ_U16(0x612)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_ENA(val) \
      GP_WB_WRITE_U16(0x612, (val))

/* Select bias lna block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_LNA_ENA() \
        (GP_WB_READ_U8(0x612) & 0x03)

#define GP_WB_GET_PMUD_TEST_BLOCK_LNA_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_LNA_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x612, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_LNA_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Select bpf block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_BPF_ENA() \
        ((GP_WB_READ_U8(0x612) >> 2) & 0x03)

#define GP_WB_GET_PMUD_TEST_BLOCK_BPF_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_BPF_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x612, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_BPF_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFF3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Select bias limiter block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_LIMITER_ENA() \
        ((GP_WB_READ_U8(0x612) >> 4) & 0x03)

#define GP_WB_GET_PMUD_TEST_BLOCK_LIMITER_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_LIMITER_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x612, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_LIMITER_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFCF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Select block fll_top block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_FLL_TOP_ENA() \
        ((GP_WB_READ_U8(0x612) >> 6) & 0x03)

#define GP_WB_GET_PMUD_TEST_BLOCK_FLL_TOP_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_FLL_TOP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x612, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_FLL_TOP_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFF3F; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Select block txmod to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_TXMOD_ENA() \
        (GP_WB_READ_U8(0x613) & 0x03)

#define GP_WB_GET_PMUD_TEST_BLOCK_TXMOD_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_TXMOD_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x613, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_TXMOD_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFCFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Select bias top block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_BIAS_TOP_ENA() \
        GP_WB_READ_U1(0x613, 2)

#define GP_WB_GET_PMUD_TEST_BLOCK_BIAS_TOP_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_BIAS_TOP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_BIAS_TOP_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Select process monitor block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_PROCESS_MONITOR_ENA() \
        GP_WB_READ_U1(0x613, 3)

#define GP_WB_GET_PMUD_TEST_BLOCK_PROCESS_MONITOR_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_PROCESS_MONITOR_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_PROCESS_MONITOR_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* Select pa top block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_PA_TOP_ENA() \
        GP_WB_READ_U1(0x613, 4)

#define GP_WB_GET_PMUD_TEST_BLOCK_PA_TOP_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_PA_TOP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_PA_TOP_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Select pa top block to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_ADC_ENA() \
        GP_WB_READ_U1(0x613, 5)

#define GP_WB_GET_PMUD_TEST_BLOCK_ADC_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_ADC_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_ADC_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

/* Select pmuablock to measure */
#define GP_WB_READ_PMUD_TEST_BLOCK_PMUA_ENA() \
        GP_WB_READ_U1(0x613, 6)

#define GP_WB_GET_PMUD_TEST_BLOCK_PMUA_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_PMUA_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_PMUA_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

/* Reserved for future use */
#define GP_WB_READ_PMUD_TEST_BLOCK_RESERVED_ENA() \
        GP_WB_READ_U1(0x613, 7)

#define GP_WB_GET_PMUD_TEST_BLOCK_RESERVED_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_PMUD_TEST_BLOCK_RESERVED_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x613, 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_TEST_BLOCK_RESERVED_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* Spare signals connected to LVL-UP blocks for 3.3V signals */
#define GP_WB_READ_PMUD_SPARE_LVLUP() \
        GP_WB_READ_U8(0x614)

#define GP_WB_WRITE_PMUD_SPARE_LVLUP(val) do { \
          GP_WB_WRITE_U8(0x614, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_MISC_STATUS() \
        GP_WB_READ_U8(0x615)

/* general purpose ana to dig signals (resynced) */
#define GP_WB_READ_PMUD_POR_REASON() \
        (GP_WB_READ_U8(0x615) & 0x0F)

#define GP_WB_GET_PMUD_POR_REASON_FROM_MISC_STATUS(tmp) \
        ((tmp) & 0x0F)

/* vdddig_ldo_rdy signal straight from analog */
#define GP_WB_READ_PMUD_VDDDIG_LDO_RDY() \
        GP_WB_READ_U1(0x615, 4)

#define GP_WB_GET_PMUD_VDDDIG_LDO_RDY_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* 32MHz xtal rdy signal straight from analog */
#define GP_WB_READ_PMUD_CLK_32M_RDY() \
        GP_WB_READ_U1(0x615, 5)

#define GP_WB_GET_PMUD_CLK_32M_RDY_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/***************************
 * layout: iob
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL() \
        GP_WB_READ_U8(0x640)

#define GP_WB_WRITE_IOB_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(val) \
      GP_WB_WRITE_U8(0x640, (val))

/* selects the uc slave support intout */
#define GP_WB_READ_IOB_MCU_INTOUTN_PINMAP() \
        GP_WB_READ_U1(0x640, 0)

#define GP_WB_GET_IOB_MCU_INTOUTN_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_MCU_INTOUTN_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_MCU_INTOUTN_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* selects the uc slave support mcu clock out */
#define GP_WB_READ_IOB_MCU_CLK_PINMAP() \
        GP_WB_READ_U1(0x640, 1)

#define GP_WB_GET_IOB_MCU_CLK_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_MCU_CLK_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_MCU_CLK_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* selects the uc slave support mcu reset out */
#define GP_WB_READ_IOB_MCU_RSTN_PINMAP() \
        GP_WB_READ_U1(0x640, 2)

#define GP_WB_GET_IOB_MCU_RSTN_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_MCU_RSTN_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_MCU_RSTN_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* selects the process monitor ringoscillator input and puts it on a gpio */
#define GP_WB_READ_IOB_FRING_PINMAP() \
        GP_WB_READ_U1(0x640, 3)

#define GP_WB_GET_IOB_FRING_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IOB_FRING_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_FRING_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* selects the digital testbus outout from analog and puts it on a gpio */
#define GP_WB_READ_IOB_DIGITAL_TEST_BUS_FROM_ANA_PINMAP() \
        GP_WB_READ_U1(0x640, 4)

#define GP_WB_GET_IOB_DIGITAL_TEST_BUS_FROM_ANA_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IOB_DIGITAL_TEST_BUS_FROM_ANA_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_DIGITAL_TEST_BUS_FROM_ANA_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Selects the unresampled adc eoc  and adc_result signal from analog */
#define GP_WB_READ_IOB_ADC_DEBUG_PINMAP() \
        GP_WB_READ_U1(0x640, 5)

#define GP_WB_GET_IOB_ADC_DEBUG_PINMAP_FROM_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_ADC_DEBUG_PINMAP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x640, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_ADC_DEBUG_PINMAP_TO_UC_SLAVE_AND_ANA_DEBUG_SUPPORT_SEL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* selects internal signal to see on dbg0 */
#define GP_WB_READ_IOB_DBG0_SEL() \
        GP_WB_READ_U8(0x641)

#define GP_WB_WRITE_IOB_DBG0_SEL(val) do { \
          GP_WB_WRITE_U8(0x641, (val)); \
        } while (0)


/* selects internal signal to see on dbg1 */
#define GP_WB_READ_IOB_DBG1_SEL() \
        GP_WB_READ_U8(0x642)

#define GP_WB_WRITE_IOB_DBG1_SEL(val) do { \
          GP_WB_WRITE_U8(0x642, (val)); \
        } while (0)


/* selects internal signal to see on dbg2 */
#define GP_WB_READ_IOB_DBG2_SEL() \
        GP_WB_READ_U8(0x643)

#define GP_WB_WRITE_IOB_DBG2_SEL(val) do { \
          GP_WB_WRITE_U8(0x643, (val)); \
        } while (0)


/* selects internal signal to see on dbg3 */
#define GP_WB_READ_IOB_DBG3_SEL() \
        GP_WB_READ_U8(0x644)

#define GP_WB_WRITE_IOB_DBG3_SEL(val) do { \
          GP_WB_WRITE_U8(0x644, (val)); \
        } while (0)


/* selects internal signal to see on dbg4 */
#define GP_WB_READ_IOB_DBG4_SEL() \
        GP_WB_READ_U8(0x645)

#define GP_WB_WRITE_IOB_DBG4_SEL(val) do { \
          GP_WB_WRITE_U8(0x645, (val)); \
        } while (0)


/* selects internal signal to see on dbg5 */
#define GP_WB_READ_IOB_DBG5_SEL() \
        GP_WB_READ_U8(0x646)

#define GP_WB_WRITE_IOB_DBG5_SEL(val) do { \
          GP_WB_WRITE_U8(0x646, (val)); \
        } while (0)


/* gpio pins are driven by dbg bus */
#define GP_WB_READ_IOB_GPIO_DBG_EN() \
        GP_WB_READ_U8(0x647)

#define GP_WB_WRITE_IOB_GPIO_DBG_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x647, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_A() \
        GP_WB_READ_U64(0x648)

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_A(val) \
      GP_WB_WRITE_U64(0x648, (val))

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_0_CFG() \
        (GP_WB_READ_U8(0x648) & 0x03)

#define GP_WB_GET_IOB_GPIO_0_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_0_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x648, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFFFFC; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_1_CFG() \
        ((GP_WB_READ_U8(0x648) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_1_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_1_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x648, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFFFF3; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_2_CFG() \
        ((GP_WB_READ_U8(0x648) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_2_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_2_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x648, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFFFCF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_3_CFG() \
        ((GP_WB_READ_U8(0x648) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_3_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_3_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x648, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFFF3F; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_4_CFG() \
        (GP_WB_READ_U8(0x649) & 0x03)

#define GP_WB_GET_IOB_GPIO_4_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_4_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x649, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFFCFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_5_CFG() \
        ((GP_WB_READ_U8(0x649) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_5_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_5_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x649, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFF3FF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_6_CFG() \
        ((GP_WB_READ_U8(0x649) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_6_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_6_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x649, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFFCFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_7_CFG() \
        ((GP_WB_READ_U8(0x649) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_7_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_7_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x649, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_8_CFG() \
        (GP_WB_READ_U8(0x64a) & 0x03)

#define GP_WB_GET_IOB_GPIO_8_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_8_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64a, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFFCFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_9_CFG() \
        ((GP_WB_READ_U8(0x64a) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_9_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_9_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64a, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFF3FFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_10_CFG() \
        ((GP_WB_READ_U8(0x64a) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_10_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 20) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_10_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64a, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFFCFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_11_CFG() \
        ((GP_WB_READ_U8(0x64a) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_11_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_11_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64a, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFF3FFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_12_CFG() \
        (GP_WB_READ_U8(0x64b) & 0x03)

#define GP_WB_GET_IOB_GPIO_12_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 24) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_12_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64b, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFFCFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_13_CFG() \
        ((GP_WB_READ_U8(0x64b) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_13_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 26) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_13_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64b, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_13_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFF3FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_14_CFG() \
        ((GP_WB_READ_U8(0x64b) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_14_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 28) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_14_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64b, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_14_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFFCFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_15_CFG() \
        ((GP_WB_READ_U8(0x64b) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_15_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 30) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_15_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64b, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_15_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFF3FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_16_CFG() \
        (GP_WB_READ_U8(0x64c) & 0x03)

#define GP_WB_GET_IOB_GPIO_16_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 32) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_16_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64c, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFFCFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_17_CFG() \
        ((GP_WB_READ_U8(0x64c) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_17_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 34) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_17_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64c, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFF3FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_18_CFG() \
        ((GP_WB_READ_U8(0x64c) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_18_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 36) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_18_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64c, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFFCFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_19_CFG() \
        ((GP_WB_READ_U8(0x64c) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_19_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 38) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_19_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64c, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_19_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFF3FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_20_CFG() \
        (GP_WB_READ_U8(0x64d) & 0x03)

#define GP_WB_GET_IOB_GPIO_20_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 40) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_20_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64d, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFFCFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_21_CFG() \
        ((GP_WB_READ_U8(0x64d) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_21_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 42) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_21_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64d, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFF3FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 42); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_22_CFG() \
        ((GP_WB_READ_U8(0x64d) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_22_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 44) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_22_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFFCFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_23_CFG() \
        ((GP_WB_READ_U8(0x64d) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_23_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 46) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_23_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64d, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_23_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFF3FFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 46); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_24_CFG() \
        (GP_WB_READ_U8(0x64e) & 0x03)

#define GP_WB_GET_IOB_GPIO_24_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 48) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_24_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64e, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_24_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FFCFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_25_CFG() \
        ((GP_WB_READ_U8(0x64e) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_25_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 50) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_25_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64e, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_25_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FF3FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 50); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_26_CFG() \
        ((GP_WB_READ_U8(0x64e) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_26_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 52) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_26_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64e, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_26_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0FCFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 52); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_27_CFG() \
        ((GP_WB_READ_U8(0x64e) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_27_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 54) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_27_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64e, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_27_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0F3FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 54); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_28_CFG() \
        (GP_WB_READ_U8(0x64f) & 0x03)

#define GP_WB_GET_IOB_GPIO_28_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 56) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_28_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64f, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_28_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x0CFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)

/* 00 = pull up disabled pull down disabled 01 = pulldown enabled, 10  = pullup enabled, 11 = buskeeper enabled */
#define GP_WB_READ_IOB_GPIO_29_CFG() \
        ((GP_WB_READ_U8(0x64f) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_29_CFG_FROM_GPIO_PIN_CONFIG_A(tmp) \
        (((tmp) >> 58) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_29_CFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x64f, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_29_CFG_TO_GPIO_PIN_CONFIG_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x03FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 58); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_B() \
        GP_WB_READ_U32(0x650)

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_B(val) \
      GP_WB_WRITE_U32(0x650, (val))

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_0_3_SLEW_RATE() \
        GP_WB_READ_U1(0x650, 0)

#define GP_WB_GET_IOB_GPIO_0_3_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_3_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x650, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_3_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_0_3_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x650, 1)

#define GP_WB_GET_IOB_GPIO_0_3_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_3_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x650, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_3_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* drive strength 00 = 2.5mA, 01 = 5mA, 10 = 7.5mA, 11 = 10mA */
#define GP_WB_READ_IOB_GPIO_0_3_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x650) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_0_3_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_0_3_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x650, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_3_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFFF3; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_4_7_SLEW_RATE() \
        GP_WB_READ_U1(0x650, 4)

#define GP_WB_GET_IOB_GPIO_4_7_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_7_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x650, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_7_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_4_7_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x650, 5)

#define GP_WB_GET_IOB_GPIO_4_7_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_7_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x650, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_7_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* drive strength 00 = 2.5mA, 01 = 5mA, 10 = 7.5mA, 11 = 10mA */
#define GP_WB_READ_IOB_GPIO_4_7_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x650) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_4_7_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_4_7_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x650, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_7_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFFF3F; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_8_11_SLEW_RATE() \
        GP_WB_READ_U1(0x651, 0)

#define GP_WB_GET_IOB_GPIO_8_11_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_11_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x651, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_11_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_8_11_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x651, 1)

#define GP_WB_GET_IOB_GPIO_8_11_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_11_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x651, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_11_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* drive strength 00 = 2.5mA, 01 = 5mA, 10 = 7.5mA, 11 = 10mA */
#define GP_WB_READ_IOB_GPIO_8_11_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x651) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_8_11_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_8_11_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x651, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_11_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFFF3FF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_12_15_SLEW_RATE() \
        GP_WB_READ_U1(0x651, 4)

#define GP_WB_GET_IOB_GPIO_12_15_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_12_15_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x651, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_15_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_12_15_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x651, 5)

#define GP_WB_GET_IOB_GPIO_12_15_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_12_15_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x651, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_15_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* drive strength 00 = 2.5mA, 01 = 5mA, 10 = 7.5mA, 11 = 10mA */
#define GP_WB_READ_IOB_GPIO_12_15_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x651) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_12_15_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_12_15_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x651, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_15_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFFF3FFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_16_19_SLEW_RATE() \
        GP_WB_READ_U1(0x652, 0)

#define GP_WB_GET_IOB_GPIO_16_19_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_16_19_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x652, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_19_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_16_19_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x652, 1)

#define GP_WB_GET_IOB_GPIO_16_19_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_16_19_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x652, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_19_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* drive strength 00 = 2mA, 01 = 4mA, 10 = 6mA, 11 = 8mA */
#define GP_WB_READ_IOB_GPIO_16_19_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x652) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_16_19_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_16_19_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x652, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_19_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFFF3FFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_20_23_SLEW_RATE() \
        GP_WB_READ_U1(0x652, 4)

#define GP_WB_GET_IOB_GPIO_20_23_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_20_23_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x652, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_23_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_20_23_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x652, 5)

#define GP_WB_GET_IOB_GPIO_20_23_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_20_23_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x652, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_23_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFFDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* drive strength 00 = 2mA, 01 = 4mA, 10 = 6mA, 11 = 8mA */
#define GP_WB_READ_IOB_GPIO_20_23_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x652) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_20_23_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_20_23_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x652, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_23_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFF3FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_24_27_SLEW_RATE() \
        GP_WB_READ_U1(0x653, 0)

#define GP_WB_GET_IOB_GPIO_24_27_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_24_27_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x653, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_24_27_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFEFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_24_27_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x653, 1)

#define GP_WB_GET_IOB_GPIO_24_27_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_24_27_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x653, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_24_27_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFDFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* drive strength 00 = 2mA, 01 = 4mA, 10 = 6mA, 11 = 8mA */
#define GP_WB_READ_IOB_GPIO_24_27_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x653) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_24_27_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 26) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_24_27_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x653, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_24_27_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* slew_rate control 1 = slow, 0 = fast */
#define GP_WB_READ_IOB_GPIO_28_29_SLEW_RATE() \
        GP_WB_READ_U1(0x653, 4)

#define GP_WB_GET_IOB_GPIO_28_29_SLEW_RATE_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_28_29_SLEW_RATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x653, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_28_29_SLEW_RATE_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_28_29_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(0x653, 5)

#define GP_WB_GET_IOB_GPIO_28_29_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_28_29_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x653, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_28_29_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 29); \
        } while (0)

/* drive strength 00 = 2.5mA, 01 = 5mA, 10 = 7.5mA, 11 = 10mA */
#define GP_WB_READ_IOB_GPIO_28_29_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(0x653) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_28_29_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 30) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_28_29_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x653, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_28_29_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 30); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_C() \
        GP_WB_READ_U16(0x654)

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_C(val) \
      GP_WB_WRITE_U16(0x654, (val))

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_0_PULSECFG() \
        GP_WB_READ_U1(0x654, 0)

#define GP_WB_GET_IOB_GPIO_0_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_1_PULSECFG() \
        GP_WB_READ_U1(0x654, 1)

#define GP_WB_GET_IOB_GPIO_1_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_1_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_2_PULSECFG() \
        GP_WB_READ_U1(0x654, 2)

#define GP_WB_GET_IOB_GPIO_2_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_2_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_3_PULSECFG() \
        GP_WB_READ_U1(0x654, 3)

#define GP_WB_GET_IOB_GPIO_3_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_3_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_4_PULSECFG() \
        GP_WB_READ_U1(0x654, 4)

#define GP_WB_GET_IOB_GPIO_4_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_5_PULSECFG() \
        GP_WB_READ_U1(0x654, 5)

#define GP_WB_GET_IOB_GPIO_5_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_5_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_6_PULSECFG() \
        GP_WB_READ_U1(0x654, 6)

#define GP_WB_GET_IOB_GPIO_6_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_6_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 6, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_7_PULSECFG() \
        GP_WB_READ_U1(0x654, 7)

#define GP_WB_GET_IOB_GPIO_7_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_7_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x654, 7, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_8_PULSECFG() \
        GP_WB_READ_U1(0x655, 0)

#define GP_WB_GET_IOB_GPIO_8_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x655, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_9_PULSECFG() \
        GP_WB_READ_U1(0x655, 1)

#define GP_WB_GET_IOB_GPIO_9_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_9_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x655, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_10_PULSECFG() \
        GP_WB_READ_U1(0x655, 2)

#define GP_WB_GET_IOB_GPIO_10_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_10_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x655, 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_11_PULSECFG() \
        GP_WB_READ_U1(0x655, 3)

#define GP_WB_GET_IOB_GPIO_11_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_11_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x655, 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_MISC_CONFIG() \
        GP_WB_READ_U8(0x656)

#define GP_WB_WRITE_IOB_GPIO_MISC_CONFIG(val) \
      GP_WB_WRITE_U8(0x656, (val))

/* Test feauture for having a higher drivestrength gpio */
#define GP_WB_READ_IOB_DOUBLE_GPIO18_DRIVE_STRENGTH() \
        GP_WB_READ_U1(0x656, 0)

#define GP_WB_GET_IOB_DOUBLE_GPIO18_DRIVE_STRENGTH_FROM_GPIO_MISC_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_DOUBLE_GPIO18_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x656, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_DOUBLE_GPIO18_DRIVE_STRENGTH_TO_GPIO_MISC_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* controls the iddq input of the gpios */
#define GP_WB_READ_IOB_GPIO_IDDQ() \
        GP_WB_READ_U1(0x656, 1)

#define GP_WB_GET_IOB_GPIO_IDDQ_FROM_GPIO_MISC_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_IDDQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x656, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_IDDQ_TO_GPIO_MISC_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_VILVIH_VOLVOH_SELECT() \
        GP_WB_READ_U8(0x657)

#define GP_WB_WRITE_IOB_VILVIH_VOLVOH_SELECT(val) \
      GP_WB_WRITE_U8(0x657, (val))

/* Select 40 pin vilvih mode */
#define GP_WB_READ_IOB_VILVIH_40_PIN() \
        GP_WB_READ_U1(0x657, 0)

#define GP_WB_GET_IOB_VILVIH_40_PIN_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_VILVIH_40_PIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x657, 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_VILVIH_40_PIN_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Select 40 pin volvoh mode */
#define GP_WB_READ_IOB_VOLVOH_40_PIN() \
        GP_WB_READ_U1(0x657, 1)

#define GP_WB_GET_IOB_VOLVOH_40_PIN_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_VOLVOH_40_PIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x657, 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_VOLVOH_40_PIN_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_DEBUG_STATUS_PB() \
        GP_WB_READ_U8(0x658)

/* Reflects the values on the debug bus */
#define GP_WB_READ_IOB_DEBUG_STATUS() \
        (GP_WB_READ_U8(0x658) & 0x3F)

#define GP_WB_GET_IOB_DEBUG_STATUS_FROM_DEBUG_STATUS_PB(tmp) \
        ((tmp) & 0x3F)

/* Input from mirror gpio18b */
#define GP_WB_READ_IOB_GPIO18B_DI() \
        GP_WB_READ_U1(0x658, 6)

#define GP_WB_GET_IOB_GPIO18B_DI_FROM_DEBUG_STATUS_PB(tmp) \
        (((tmp) >> 6) & 0x01)

/***************************
 * layout: xap5_gp
 ***************************/

/* Address to be used as first instruction address of xap (32 bit word address) */
#define GP_WB_READ_XAP5_GP_VECTOR_PTR_PHYS_ADDR() \
        GP_WB_READ_U24(0x680)

#define GP_WB_WRITE_XAP5_GP_VECTOR_PTR_PHYS_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01FFFF); \
          GP_WB_WRITE_U24(0x680, (val)); \
        } while (0)


/* When 1 the xap is allowed to go to sleep, when 0, the xap will be waken up */
#define GP_WB_READ_XAP5_GP_SLEEP_ENABLE() \
        GP_WB_READ_U1(0x683, 0)

#define GP_WB_WRITE_XAP5_GP_SLEEP_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x683, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_SIF_MAPPING_A() \
        GP_WB_READ_U8(0x684)

#define GP_WB_WRITE_XAP5_GP_SIF_MAPPING_A(val) \
      GP_WB_WRITE_U8(0x684, (val))

/* Sif clock pin mapping. (only mappings a, b, c and d are valid mappings) */
#define GP_WB_READ_XAP5_GP_SIF_CLK_MAPPING() \
        (GP_WB_READ_U8(0x684) & 0x07)

#define GP_WB_GET_XAP5_GP_SIF_CLK_MAPPING_FROM_SIF_MAPPING_A(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_XAP5_GP_SIF_CLK_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x684, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SIF_CLK_MAPPING_TO_SIF_MAPPING_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sif loadb pin mapping. (only mappings a, b, c and d are valid mappings) */
#define GP_WB_READ_XAP5_GP_SIF_LOADB_MAPPING() \
        ((GP_WB_READ_U8(0x684) >> 3) & 0x07)

#define GP_WB_GET_XAP5_GP_SIF_LOADB_MAPPING_FROM_SIF_MAPPING_A(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_XAP5_GP_SIF_LOADB_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x684, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SIF_LOADB_MAPPING_TO_SIF_MAPPING_A(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_SIF_MAPPING_B() \
        GP_WB_READ_U8(0x685)

#define GP_WB_WRITE_XAP5_GP_SIF_MAPPING_B(val) \
      GP_WB_WRITE_U8(0x685, (val))

/* Sif miso pin mapping. (only mappings a, b, c and d are valid mappings) */
#define GP_WB_READ_XAP5_GP_SIF_MISO_MAPPING() \
        (GP_WB_READ_U8(0x685) & 0x07)

#define GP_WB_GET_XAP5_GP_SIF_MISO_MAPPING_FROM_SIF_MAPPING_B(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_XAP5_GP_SIF_MISO_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x685, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SIF_MISO_MAPPING_TO_SIF_MAPPING_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sif mosi pin mapping. (only mappings a, b, c and d are valid mappings) */
#define GP_WB_READ_XAP5_GP_SIF_MOSI_MAPPING() \
        ((GP_WB_READ_U8(0x685) >> 3) & 0x07)

#define GP_WB_GET_XAP5_GP_SIF_MOSI_MAPPING_FROM_SIF_MAPPING_B(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_XAP5_GP_SIF_MOSI_MAPPING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x685, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SIF_MOSI_MAPPING_TO_SIF_MAPPING_B(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_INT_PRIORITY_0() \
        GP_WB_READ_U8(0x686)

#define GP_WB_WRITE_XAP5_GP_INT_PRIORITY_0(val) \
      GP_WB_WRITE_U8(0x686, (val))

/* priority for rci interrupr */
#define GP_WB_READ_XAP5_GP_RCI_INT_PRIORITY() \
        (GP_WB_READ_U8(0x686) & 0x03)

#define GP_WB_GET_XAP5_GP_RCI_INT_PRIORITY_FROM_INT_PRIORITY_0(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_XAP5_GP_RCI_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x686, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_RCI_INT_PRIORITY_TO_INT_PRIORITY_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* priority es interrupt */
#define GP_WB_READ_XAP5_GP_ES_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x686) >> 2) & 0x03)

#define GP_WB_GET_XAP5_GP_ES_INT_PRIORITY_FROM_INT_PRIORITY_0(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_XAP5_GP_ES_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x686, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_XAP5_GP_ES_INT_PRIORITY_TO_INT_PRIORITY_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* priority for trc interrupt */
#define GP_WB_READ_XAP5_GP_TRC_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x686) >> 4) & 0x03)

#define GP_WB_GET_XAP5_GP_TRC_INT_PRIORITY_FROM_INT_PRIORITY_0(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_XAP5_GP_TRC_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x686, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_XAP5_GP_TRC_INT_PRIORITY_TO_INT_PRIORITY_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* priority for stbc interrupt */
#define GP_WB_READ_XAP5_GP_STBC_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x686) >> 6) & 0x03)

#define GP_WB_GET_XAP5_GP_STBC_INT_PRIORITY_FROM_INT_PRIORITY_0(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_XAP5_GP_STBC_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x686, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_XAP5_GP_STBC_INT_PRIORITY_TO_INT_PRIORITY_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_INT_PRIORITY_1() \
        GP_WB_READ_U8(0x687)

#define GP_WB_WRITE_XAP5_GP_INT_PRIORITY_1(val) \
      GP_WB_WRITE_U8(0x687, (val))

/* priority for keypad scan interrupt */
#define GP_WB_READ_XAP5_GP_KPS_INT_PRIORITY() \
        (GP_WB_READ_U8(0x687) & 0x03)

#define GP_WB_GET_XAP5_GP_KPS_INT_PRIORITY_FROM_INT_PRIORITY_1(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_XAP5_GP_KPS_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x687, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_KPS_INT_PRIORITY_TO_INT_PRIORITY_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* priority for ir interrupt */
#define GP_WB_READ_XAP5_GP_IR_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x687) >> 2) & 0x03)

#define GP_WB_GET_XAP5_GP_IR_INT_PRIORITY_FROM_INT_PRIORITY_1(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_XAP5_GP_IR_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x687, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_XAP5_GP_IR_INT_PRIORITY_TO_INT_PRIORITY_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* priority for uart interrupt */
#define GP_WB_READ_XAP5_GP_UART_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x687) >> 4) & 0x03)

#define GP_WB_GET_XAP5_GP_UART_INT_PRIORITY_FROM_INT_PRIORITY_1(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_XAP5_GP_UART_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x687, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_XAP5_GP_UART_INT_PRIORITY_TO_INT_PRIORITY_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* priority for tip interrupt */
#define GP_WB_READ_XAP5_GP_IPC_EXT2INT_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x687) >> 6) & 0x03)

#define GP_WB_GET_XAP5_GP_IPC_EXT2INT_INT_PRIORITY_FROM_INT_PRIORITY_1(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_XAP5_GP_IPC_EXT2INT_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x687, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_XAP5_GP_IPC_EXT2INT_INT_PRIORITY_TO_INT_PRIORITY_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_INT_PRIORITY_2() \
        GP_WB_READ_U8(0x688)

#define GP_WB_WRITE_XAP5_GP_INT_PRIORITY_2(val) \
      GP_WB_WRITE_U8(0x688, (val))

/* priority for mri interrupt */
#define GP_WB_READ_XAP5_GP_MRI_INT_PRIORITY() \
        (GP_WB_READ_U8(0x688) & 0x03)

#define GP_WB_GET_XAP5_GP_MRI_INT_PRIORITY_FROM_INT_PRIORITY_2(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_XAP5_GP_MRI_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x688, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_MRI_INT_PRIORITY_TO_INT_PRIORITY_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* priority for gpio interrupt */
#define GP_WB_READ_XAP5_GP_GPIO_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x688) >> 2) & 0x03)

#define GP_WB_GET_XAP5_GP_GPIO_INT_PRIORITY_FROM_INT_PRIORITY_2(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_XAP5_GP_GPIO_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x688, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_XAP5_GP_GPIO_INT_PRIORITY_TO_INT_PRIORITY_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* priority for twi master interrupt */
#define GP_WB_READ_XAP5_GP_TWI_MS_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x688) >> 4) & 0x03)

#define GP_WB_GET_XAP5_GP_TWI_MS_INT_PRIORITY_FROM_INT_PRIORITY_2(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_XAP5_GP_TWI_MS_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x688, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_XAP5_GP_TWI_MS_INT_PRIORITY_TO_INT_PRIORITY_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* priority for phy interrupt */
#define GP_WB_READ_XAP5_GP_PHY_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x688) >> 6) & 0x03)

#define GP_WB_GET_XAP5_GP_PHY_INT_PRIORITY_FROM_INT_PRIORITY_2(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_XAP5_GP_PHY_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x688, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_XAP5_GP_PHY_INT_PRIORITY_TO_INT_PRIORITY_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_INT_PRIORITY_3() \
        GP_WB_READ_U8(0x689)

#define GP_WB_WRITE_XAP5_GP_INT_PRIORITY_3(val) \
      GP_WB_WRITE_U8(0x689, (val))

/* priority for ssp interrupt */
#define GP_WB_READ_XAP5_GP_SSP_INT_PRIORITY() \
        (GP_WB_READ_U8(0x689) & 0x03)

#define GP_WB_GET_XAP5_GP_SSP_INT_PRIORITY_FROM_INT_PRIORITY_3(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_XAP5_GP_SSP_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x689, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SSP_INT_PRIORITY_TO_INT_PRIORITY_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* priority for spi master interrupt */
#define GP_WB_READ_XAP5_GP_SPI_MS_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x689) >> 2) & 0x03)

#define GP_WB_GET_XAP5_GP_SPI_MS_INT_PRIORITY_FROM_INT_PRIORITY_3(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_XAP5_GP_SPI_MS_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x689, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_XAP5_GP_SPI_MS_INT_PRIORITY_TO_INT_PRIORITY_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* priority for watchdog interrupt */
#define GP_WB_READ_XAP5_GP_WATCHDOG_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x689) >> 4) & 0x03)

#define GP_WB_GET_XAP5_GP_WATCHDOG_INT_PRIORITY_FROM_INT_PRIORITY_3(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_XAP5_GP_WATCHDOG_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x689, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_XAP5_GP_WATCHDOG_INT_PRIORITY_TO_INT_PRIORITY_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* priority for macfilter interrupt */
#define GP_WB_READ_XAP5_GP_MACFILT_INT_PRIORITY() \
        ((GP_WB_READ_U8(0x689) >> 6) & 0x03)

#define GP_WB_GET_XAP5_GP_MACFILT_INT_PRIORITY_FROM_INT_PRIORITY_3(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_XAP5_GP_MACFILT_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x689, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_XAP5_GP_MACFILT_INT_PRIORITY_TO_INT_PRIORITY_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* minimum priority level for an interrupt to be valid. When set to 0x03 all interrupts are valid. When set to 0x00 only highest level interrupts are valid */
#define GP_WB_READ_XAP5_GP_MIN_INT_PRIORITY() \
        GP_WB_READ_U8(0x68a)

#define GP_WB_WRITE_XAP5_GP_MIN_INT_PRIORITY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x68a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_ERROR_STATUS_0() \
        GP_WB_READ_U8(0x68b)

/* Type of the latched error. */
#define GP_WB_READ_XAP5_GP_ERR_STATUS() \
        (GP_WB_READ_U8(0x68b) & 0x07)

#define GP_WB_GET_XAP5_GP_ERR_STATUS_FROM_ERROR_STATUS_0(tmp) \
        ((tmp) & 0x07)

/* This status register is set to '1' when an address error occurred and the top 8 bits are not all zeros or all ones (=> inside window) */
#define GP_WB_READ_XAP5_GP_LOGICAL_ADDR_INVALID() \
        GP_WB_READ_U1(0x68b, 3)

#define GP_WB_GET_XAP5_GP_LOGICAL_ADDR_INVALID_FROM_ERROR_STATUS_0(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_XAP5_GP_ERROR_STATUS_1() \
        GP_WB_READ_U8(0x68c)

/* self force stop */
#define GP_WB_READ_XAP5_GP_SELF_FORCE_STOP() \
        GP_WB_READ_U1(0x68c, 0)

#define GP_WB_GET_XAP5_GP_SELF_FORCE_STOP_FROM_ERROR_STATUS_1(tmp) \
        ((tmp) & 0x01)

/* processor error */
#define GP_WB_READ_XAP5_GP_PROC_ERROR() \
        GP_WB_READ_U1(0x68c, 1)

#define GP_WB_GET_XAP5_GP_PROC_ERROR_FROM_ERROR_STATUS_1(tmp) \
        (((tmp) >> 1) & 0x01)

/* processor debug */
#define GP_WB_READ_XAP5_GP_DEBUG() \
        GP_WB_READ_U1(0x68c, 2)

#define GP_WB_GET_XAP5_GP_DEBUG_FROM_ERROR_STATUS_1(tmp) \
        (((tmp) >> 2) & 0x01)

/* processor stopped indication */
#define GP_WB_READ_XAP5_GP_PROC_STOPPED() \
        GP_WB_READ_U1(0x68c, 3)

#define GP_WB_GET_XAP5_GP_PROC_STOPPED_FROM_ERROR_STATUS_1(tmp) \
        (((tmp) >> 3) & 0x01)

/* processor sleep indication */
#define GP_WB_READ_XAP5_GP_PROC_ASLEEP() \
        GP_WB_READ_U1(0x68c, 4)

#define GP_WB_GET_XAP5_GP_PROC_ASLEEP_FROM_ERROR_STATUS_1(tmp) \
        (((tmp) >> 4) & 0x01)


/* Logical address latched when an error occurred ( byte address) */
#define GP_WB_READ_XAP5_GP_LOGICAL_ADDRESS_ON_ERR() \
        GP_WB_READ_U24(0x68e)


/* address of the last latched instruction address */
#define GP_WB_READ_XAP5_GP_PROGRAM_PTR() \
        GP_WB_READ_U24(0x692)


/* when set to 1 the program pointer is no longer updated. This needs to be done for proper readout of the program pointer */
#define GP_WB_READ_XAP5_GP_STOP_PROGRAM_PTR_UPDATE() \
        GP_WB_READ_U1(0x695, 0)

#define GP_WB_WRITE_XAP5_GP_STOP_PROGRAM_PTR_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x695, (val)); \
        } while (0)


/* Clears the latched address and err_status when an error has occurred. */
#define GP_WB_XAP5_GP_CLR_LOGICAL_ADDRESS_ON_ERR() \
        GP_WB_WRITE_U8(0x696, 0x01)


#define GP_WB_WRITE_XAP5_GP_BACKUP_RESTORE(val) \
      GP_WB_WRITE_U8(0x697, (val))

/* pulse that indicates to the standby controller that the restore is done (cm or sm) */
#define GP_WB_XAP5_GP_FLAG_RESTORE_DONE() \
        GP_WB_WRITE_U8(0x697, 0x01)

#define GP_WB_SET_XAP5_GP_FLAG_RESTORE_DONE_TO_BACKUP_RESTORE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* pulse that indicates to the standby controller that the backup is done */
#define GP_WB_XAP5_GP_FLAG_BACKUP_DONE() \
        GP_WB_WRITE_U8(0x697, 0x02)

#define GP_WB_SET_XAP5_GP_FLAG_BACKUP_DONE_TO_BACKUP_RESTORE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the direction in which the clu copies */
#define GP_WB_READ_XAP5_GP_CLU_MODE() \
        GP_WB_READ_U1(0x698, 0)

#define GP_WB_WRITE_XAP5_GP_CLU_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x698, (val)); \
        } while (0)

/***************************
 * layout: mm
 ***************************/

/* PBM Entries options base address ( = offset added to SM_linear start address). Resolution 2 bytes */
#define GP_WB_READ_MM_PBM_OPTS_BASE_ADDRESS() \
        GP_WB_READ_U16(0x700)

#define GP_WB_WRITE_MM_PBM_OPTS_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x700, (val)); \
        } while (0)


/* PBM 0 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_0_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x702)

#define GP_WB_WRITE_MM_PBM_0_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x702, (val)); \
        } while (0)


/* PBM 1 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_1_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x704)

#define GP_WB_WRITE_MM_PBM_1_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x704, (val)); \
        } while (0)


/* PBM 2 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_2_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x706)

#define GP_WB_WRITE_MM_PBM_2_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x706, (val)); \
        } while (0)


/* PBM 3 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_3_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x708)

#define GP_WB_WRITE_MM_PBM_3_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x708, (val)); \
        } while (0)


/* PBM 4 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_4_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x70a)

#define GP_WB_WRITE_MM_PBM_4_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x70a, (val)); \
        } while (0)


/* PBM 5 database address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_5_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x70c)

#define GP_WB_WRITE_MM_PBM_5_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x70c, (val)); \
        } while (0)


/* PBM 6 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_6_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x70e)

#define GP_WB_WRITE_MM_PBM_6_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x70e, (val)); \
        } while (0)


/* PBM 7 data base address ( = offset added to SM_linear start address). Resolution 1 byte */
#define GP_WB_READ_MM_PBM_7_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(0x710)

#define GP_WB_WRITE_MM_PBM_7_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x710, (val)); \
        } while (0)


/* Event Entries base address ( = offset added to SM_linear start address). Resolution 2 bytes */
#define GP_WB_READ_MM_EVENT_BASE_ADDRESS() \
        GP_WB_READ_U16(0x712)

#define GP_WB_WRITE_MM_EVENT_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x712, (val)); \
        } while (0)


/* General purpose 0 window base address ( = offset added to SM_linear start address). Resolution 2 byte - window size 512 bytes */
#define GP_WB_READ_MM_GEN_WINDOW_0_BASE_ADDRESS() \
        GP_WB_READ_U16(0x714)

#define GP_WB_WRITE_MM_GEN_WINDOW_0_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x714, (val)); \
        } while (0)


/* General purpose 1 window base address ( = offset added to SM_linear start address). Resolution 2 byte - window size 256 bytes */
#define GP_WB_READ_MM_GEN_WINDOW_1_BASE_ADDRESS() \
        GP_WB_READ_U16(0x716)

#define GP_WB_WRITE_MM_GEN_WINDOW_1_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x716, (val)); \
        } while (0)


/* General purpose 2 window base address ( = offset added to SM_linear start address). Resolution 2 byte - window size 256 bytes */
#define GP_WB_READ_MM_GEN_WINDOW_2_BASE_ADDRESS() \
        GP_WB_READ_U16(0x718)

#define GP_WB_WRITE_MM_GEN_WINDOW_2_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x718, (val)); \
        } while (0)


/* General purpose 3 window base address ( = offset added to SM_linear start address). Resolution 2 byte - window size 768 bytes */
#define GP_WB_READ_MM_GEN_WINDOW_3_BASE_ADDRESS() \
        GP_WB_READ_U16(0x71a)

#define GP_WB_WRITE_MM_GEN_WINDOW_3_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x71a, (val)); \
        } while (0)


/* Circular 0 window base address ( = offset added to SM_linear start address). Resolution 1 byte - window size 128 bytes (repeated twice) */
#define GP_WB_READ_MM_CIRC_WINDOW_0_BASE_ADDRESS() \
        GP_WB_READ_U16(0x71c)

#define GP_WB_WRITE_MM_CIRC_WINDOW_0_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3FFF); \
          GP_WB_WRITE_U16(0x71c, (val)); \
        } while (0)


/* Physical start address of the first variable size window. Resolution 2 bytes. Possible use case is the stack window - max size 4K */
#define GP_WB_READ_MM_GEN_WINDOW_VAR_0_BASE_ADDRESS() \
        GP_WB_READ_U16(0x71e)

#define GP_WB_WRITE_MM_GEN_WINDOW_VAR_0_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x71e, (val)); \
        } while (0)


/* Memory length of the first variable size window. Resolution 2 bytes (max size 4k) */
#define GP_WB_READ_MM_GEN_WINDOW_VAR_0_LEN() \
        GP_WB_READ_U16(0x720)

#define GP_WB_WRITE_MM_GEN_WINDOW_VAR_0_LEN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0FFF); \
          GP_WB_WRITE_U16(0x720, (val)); \
        } while (0)


/* Physical start address of the second variable size window. Resolution 2 byte. Possible use case is the shared memory window - max 8k */
#define GP_WB_READ_MM_GEN_WINDOW_VAR_1_BASE_ADDRESS() \
        GP_WB_READ_U16(0x722)

#define GP_WB_WRITE_MM_GEN_WINDOW_VAR_1_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x1FFF); \
          GP_WB_WRITE_U16(0x722, (val)); \
        } while (0)


/* Memory length of the second variable size window. Resolution 2 bytes  (max size 4k) */
#define GP_WB_READ_MM_GEN_WINDOW_VAR_1_LEN() \
        GP_WB_READ_U16(0x724)

#define GP_WB_WRITE_MM_GEN_WINDOW_VAR_1_LEN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0FFF); \
          GP_WB_WRITE_U16(0x724, (val)); \
        } while (0)


/* when set to 1, the memory arbiters will give absolute priority to intuc mem requests. To be used only when intuc execution needs guaranteed deterministic execution time. Property to be used with HIGH care */
#define GP_WB_READ_MM_INTUC_HAS_HIGHEST_PRIO() \
        GP_WB_READ_U1(0x726, 0)

#define GP_WB_WRITE_MM_INTUC_HAS_HIGHEST_PRIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x726, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CTRL_READ() \
        GP_WB_READ_U8(0x727)

#define GP_WB_WRITE_MM_FLASH_CTRL_READ(val) \
      GP_WB_WRITE_U8(0x727, (val))

/* Enables read access to the Flash. Puts the controller in read mode all the time */
#define GP_WB_READ_MM_FLASH_CTRL_READ_EN() \
        GP_WB_READ_U1(0x727, 0)

#define GP_WB_GET_MM_FLASH_CTRL_READ_EN_FROM_FLASH_CTRL_READ(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CTRL_READ_EN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x727, 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CTRL_READ_EN_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Forces on the flash charge pump to generate vrr, even if the flash is not in read or write mode */
#define GP_WB_READ_MM_FLASH_CTRL_FORCE_ON_VRR() \
        GP_WB_READ_U1(0x727, 1)

#define GP_WB_GET_MM_FLASH_CTRL_FORCE_ON_VRR_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CTRL_FORCE_ON_VRR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x727, 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CTRL_FORCE_ON_VRR_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set to '1', the flash is allowed to go into deep power down mode (for saving power) */
#define GP_WB_READ_MM_FLASH_CTRL_DPDOWN_ENABLE() \
        GP_WB_READ_U1(0x727, 2)

#define GP_WB_GET_MM_FLASH_CTRL_DPDOWN_ENABLE_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CTRL_DPDOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x727, 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CTRL_DPDOWN_ENABLE_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Determines the minimum time (in multiples of 500ns), the flash will wait to do an access after dpdown was released */
#define GP_WB_READ_MM_FLASH_CTRL_DPDOWN_TIMEOUT() \
        GP_WB_READ_U8(0x728)

#define GP_WB_WRITE_MM_FLASH_CTRL_DPDOWN_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x728, (val)); \
        } while (0)


/* Determines the minimum time the vrr needs to be stable before it is regarded as really stable (in 16us multiples) */
#define GP_WB_READ_MM_MIN_VRR_STABLE_TIME() \
        GP_WB_READ_U8(0x729)

#define GP_WB_WRITE_MM_MIN_VRR_STABLE_TIME(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x729, (val)); \
        } while (0)


/* Indicates digital vrr stable indication (so it is related to the flashcp_vout_rdy, but with the digital min_stabel time applied to it) */
#define GP_WB_READ_MM_VRR_STABLE() \
        GP_WB_READ_U1(0x72a, 0)


/* 32 bit word address register for accessing nvm directly */
#define GP_WB_READ_MM_MRI_NVM_ADDRESS() \
        GP_WB_READ_U24(0x72c)

#define GP_WB_WRITE_MM_MRI_NVM_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01FFFF); \
          GP_WB_WRITE_U24(0x72c, (val)); \
        } while (0)


/* 32 bit write date register for writing to nvm */
#define GP_WB_READ_MM_MRI_NVM_WRITE_DATA() \
        GP_WB_READ_U32(0x730)

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_DATA(val) do { \
          GP_WB_WRITE_U32(0x730, (val)); \
        } while (0)


/* 32 read data register holding nvm data read */
#define GP_WB_READ_MM_MRI_NVM_READ_DATA() \
        GP_WB_READ_U32(0x734)


/* When direct access is enabled (and the flash is in overrule mode), the mri nvm address and the different flash control bits are directly connected to the flash (so this overrules the signals generated by the mri command). Use this for testing flash or using flash in async mode */
#define GP_WB_READ_MM_MRI_DIRECT_ACCESS() \
        GP_WB_READ_U1(0x738, 0)

#define GP_WB_WRITE_MM_MRI_DIRECT_ACCESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x738, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_MRI_NVM_STATUS() \
        GP_WB_READ_U8(0x739)

/* Bit that indicates if the mri is doing an access */
#define GP_WB_READ_MM_MRI_NVM_ACCESS_BUSY() \
        GP_WB_READ_U1(0x739, 0)

#define GP_WB_GET_MM_MRI_NVM_ACCESS_BUSY_FROM_MRI_NVM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status reflecting the rbb output of the flash. When 0 the flash is busy doing something and you should hold off any access to it (0 means busy) */
#define GP_WB_READ_MM_MRI_NVM_RBB() \
        GP_WB_READ_U1(0x739, 1)

#define GP_WB_GET_MM_MRI_NVM_RBB_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Bit that indicates if the flash is currently still in deep power down mode */
#define GP_WB_READ_MM_MRI_NVM_IN_DPDOWN() \
        GP_WB_READ_U1(0x739, 2)

#define GP_WB_GET_MM_MRI_NVM_IN_DPDOWN_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that there was a memory access failure. Cleared on each new access */
#define GP_WB_READ_MM_MRI_NVM_MEMORY_ERR() \
        GP_WB_READ_U1(0x739, 3)

#define GP_WB_GET_MM_MRI_NVM_MEMORY_ERR_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that a unmasked write interrupt occurred */
#define GP_WB_READ_MM_MRI_NVM_UNMASKED_ACCESS_DONE_INTERRUPT() \
        GP_WB_READ_U1(0x739, 4)

#define GP_WB_GET_MM_MRI_NVM_UNMASKED_ACCESS_DONE_INTERRUPT_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_MM_MRI_NVM_CMD_TRIGGER_CTRL(val) \
      GP_WB_WRITE_U8(0x73a, (val))

/* trigger a nvm access, defined by the flash_config settings when in overrule mode */
#define GP_WB_MM_MRI_NVM_CMD_TRIGGER() \
        GP_WB_WRITE_U8(0x73a, 0x01)

#define GP_WB_SET_MM_MRI_NVM_CMD_TRIGGER_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0A; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* nvm address post increment */
#define GP_WB_MM_MRI_NVM_AUTO_INCREMENT() \
        GP_WB_WRITE_U8(0x73a, 0x02)

#define GP_WB_SET_MM_MRI_NVM_AUTO_INCREMENT_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x09; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* write interrupt clear */
#define GP_WB_MM_MRI_NVM_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(0x73a, 0x08)

#define GP_WB_SET_MM_MRI_NVM_CLR_INTERRUPT_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONFIG_0() \
        GP_WB_READ_U8(0x73b)

#define GP_WB_WRITE_MM_FLASH_CONFIG_0(val) \
      GP_WB_WRITE_U8(0x73b, (val))

/* When set to '1', thje flash pins are directly controlled by the settings in these flash_config registers. Is required to have write access to the flash */
#define GP_WB_READ_MM_FLASH_OVERRULE_MODE() \
        GP_WB_READ_U1(0x73b, 0)

#define GP_WB_GET_MM_FLASH_OVERRULE_MODE_FROM_FLASH_CONFIG_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_OVERRULE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73b, 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_OVERRULE_MODE_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Controls the POR of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_POR() \
        GP_WB_READ_U1(0x73b, 1)

#define GP_WB_GET_MM_FLASH_POR_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_POR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73b, 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_POR_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Controls the deep power down mode pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_DPDOWN() \
        GP_WB_READ_U1(0x73b, 2)

#define GP_WB_GET_MM_FLASH_DPDOWN_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_DPDOWN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73b, 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_DPDOWN_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Controls the inf pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_INF() \
        GP_WB_READ_U1(0x73b, 3)

#define GP_WB_GET_MM_FLASH_INF_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_INF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73b, 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_INF_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Controls the tm pins of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_TEST_MODE() \
        ((GP_WB_READ_U8(0x73b) >> 4) & 0x0F)

#define GP_WB_GET_MM_FLASH_TEST_MODE_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_MM_FLASH_TEST_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x73b, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_MM_FLASH_TEST_MODE_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONFIG_1() \
        GP_WB_READ_U8(0x73c)

#define GP_WB_WRITE_MM_FLASH_CONFIG_1(val) \
      GP_WB_WRITE_U8(0x73c, (val))

/* Controls the ce pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_CE() \
        GP_WB_READ_U1(0x73c, 0)

#define GP_WB_GET_MM_FLASH_CE_FROM_FLASH_CONFIG_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Controls the wronly pin of the flash when in overrule mode  - flashcp_write needs to be set to 1 for this action to work, unless external read write voltage is used */
#define GP_WB_READ_MM_FLASH_WRONLY() \
        GP_WB_READ_U1(0x73c, 1)

#define GP_WB_GET_MM_FLASH_WRONLY_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_WRONLY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_WRONLY_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Controls the prog pin of the flash when in overrule mode - flashcp_write needs to be set to 1 for this action to work, unless external read write voltage is used */
#define GP_WB_READ_MM_FLASH_PROG() \
        GP_WB_READ_U1(0x73c, 2)

#define GP_WB_GET_MM_FLASH_PROG_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_PROG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_PROG_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Controls the perase pin of the flash when in overrule mode - flashcp_write needs to be set to 1 for this action to work, unless external read write voltage is used */
#define GP_WB_READ_MM_FLASH_PERASE() \
        GP_WB_READ_U1(0x73c, 3)

#define GP_WB_GET_MM_FLASH_PERASE_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_PERASE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_PERASE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Controls the serase pin of the flash when in overrule mode - flashcp_write needs to be set to 1 for this action to work, unless external read write voltage is used */
#define GP_WB_READ_MM_FLASH_SERASE() \
        GP_WB_READ_U1(0x73c, 4)

#define GP_WB_GET_MM_FLASH_SERASE_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_FLASH_SERASE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_SERASE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Controls the merase pin of the flash when in overrule mode - flashcp_write needs to be set to 1 for this action to work, unless external read write voltage is used */
#define GP_WB_READ_MM_FLASH_MERASE() \
        GP_WB_READ_U1(0x73c, 5)

#define GP_WB_GET_MM_FLASH_MERASE_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MM_FLASH_MERASE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 5, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_MERASE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Controls the ale pin of the flash when in overrule mode. This value is ored with the ale generated by an mri access command */
#define GP_WB_READ_MM_FLASH_ALE() \
        GP_WB_READ_U1(0x73c, 6)

#define GP_WB_GET_MM_FLASH_ALE_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MM_FLASH_ALE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 6, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ALE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When flash is in direct overrule mode, this bit enables direct access to the di(0) pin, in order to be able to put an analog signal on this pin */
#define GP_WB_READ_MM_FLASH_ENABLE_ANALOG_TEST_MODE() \
        GP_WB_READ_U1(0x73c, 7)

#define GP_WB_GET_MM_FLASH_ENABLE_ANALOG_TEST_MODE_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MM_FLASH_ENABLE_ANALOG_TEST_MODE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73c, 7, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ENABLE_ANALOG_TEST_MODE_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASCP_CONFIG() \
        GP_WB_READ_U8(0x73d)

#define GP_WB_WRITE_MM_FLASCP_CONFIG(val) \
      GP_WB_WRITE_U8(0x73d, (val))

/* Battery bypass signal for CP_FLASH */
#define GP_WB_READ_MM_FLASHCP_BYP_ENA() \
        GP_WB_READ_U1(0x73d, 0)

#define GP_WB_GET_MM_FLASHCP_BYP_ENA_FROM_FLASCP_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASHCP_BYP_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73d, 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASHCP_BYP_ENA_TO_FLASCP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Keep on signal for CP_FLASH */
#define GP_WB_READ_MM_FLASHCP_KEEP_ON() \
        GP_WB_READ_U1(0x73d, 1)

#define GP_WB_GET_MM_FLASHCP_KEEP_ON_FROM_FLASCP_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASHCP_KEEP_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73d, 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASHCP_KEEP_ON_TO_FLASCP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Trimming bits for CP reference voltage */
#define GP_WB_READ_MM_FLASHCP_REFBITS() \
        ((GP_WB_READ_U8(0x73d) >> 2) & 0x07)

#define GP_WB_GET_MM_FLASHCP_REFBITS_FROM_FLASCP_CONFIG(tmp) \
        (((tmp) >> 2) & 0x07)

#define GP_WB_WRITE_MM_FLASHCP_REFBITS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x73d, 0x1C, (val) << 2); \
        } while (0)

#define GP_WB_SET_MM_FLASHCP_REFBITS_TO_FLASCP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x63; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Overrule enable for the dynamically controlled pup */
#define GP_WB_READ_MM_FLASHCP_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(0x73d, 5)

#define GP_WB_GET_MM_FLASHCP_PUP_OVERRULE_ENA_FROM_FLASCP_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MM_FLASHCP_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73d, 5, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASHCP_PUP_OVERRULE_ENA_TO_FLASCP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Overrule value for the dynamically controlled pup */
#define GP_WB_READ_MM_FLASHCP_PUP_OVERRULE() \
        GP_WB_READ_U1(0x73d, 6)

#define GP_WB_GET_MM_FLASHCP_PUP_OVERRULE_FROM_FLASCP_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MM_FLASHCP_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x73d, 6, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASHCP_PUP_OVERRULE_TO_FLASCP_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* forces the the flasshcp vout rdy to 1. (status is still the one coming from analog, the forced value is used by vrr stable generator */
#define GP_WB_READ_MM_FLASHCP_VOUT_RDY_FORCE() \
        GP_WB_READ_U1(0x73e, 0)

#define GP_WB_WRITE_MM_FLASHCP_VOUT_RDY_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x73e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASHCP_STATUS() \
        GP_WB_READ_U8(0x73f)

/* rdy signal indicating that flashcp output voltage is stable */
#define GP_WB_READ_MM_FLASHCP_VOUT_RDY() \
        GP_WB_READ_U1(0x73f, 0)

#define GP_WB_GET_MM_FLASHCP_VOUT_RDY_FROM_FLASHCP_STATUS(tmp) \
        ((tmp) & 0x01)

/* Ready signal generated by voltage monitor in CP FLASH */
#define GP_WB_READ_MM_FLASHCP_VDDD_RDY() \
        GP_WB_READ_U1(0x73f, 1)

#define GP_WB_GET_MM_FLASHCP_VDDD_RDY_FROM_FLASHCP_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* pup status from design */
#define GP_WB_READ_MM_FLASHCP_PUP_STATUS() \
        GP_WB_READ_U1(0x73f, 2)

#define GP_WB_GET_MM_FLASHCP_PUP_STATUS_FROM_FLASHCP_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Ram Start address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_RAM_CRC_INIT_START_ADDRESS() \
        GP_WB_READ_U16(0x740)

#define GP_WB_WRITE_MM_RAM_CRC_INIT_START_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0FFF); \
          GP_WB_WRITE_U16(0x740, (val)); \
        } while (0)


/* Ram end address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_RAM_CRC_INIT_END_ADDRESS() \
        GP_WB_READ_U16(0x742)

#define GP_WB_WRITE_MM_RAM_CRC_INIT_END_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0FFF); \
          GP_WB_WRITE_U16(0x742, (val)); \
        } while (0)


/* Result of the crc calculation */
#define GP_WB_READ_MM_RAM_CRC_RESULT() \
        GP_WB_READ_U32(0x744)


/* When set to '1', the BIST is allowed to take control of the RAM interface. */
#define GP_WB_READ_MM_BIST_ENABLE() \
        GP_WB_READ_U1(0x748, 0)

#define GP_WB_WRITE_MM_BIST_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x748, (val)); \
        } while (0)


#define GP_WB_WRITE_MM_RAM_OPERATION_TRIGGERS(val) \
      GP_WB_WRITE_U8(0x749, (val))

/* Triggers the BIST test (when enabled !). Beware ... this will block all other RAM accesses and overwrite ALL  memory content !!! */
#define GP_WB_MM_BIST_START() \
        GP_WB_WRITE_U8(0x749, 0x01)

#define GP_WB_SET_MM_BIST_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Triggers the CRC calculation over the range defined by ram_crc_init_start_address and end address */
#define GP_WB_MM_CRC_START() \
        GP_WB_WRITE_U8(0x749, 0x02)

#define GP_WB_SET_MM_CRC_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Triggers the CRC calculation over the range defined by ram_crc_init_start_address and end address */
#define GP_WB_MM_INIT_START() \
        GP_WB_WRITE_U8(0x749, 0x04)

#define GP_WB_SET_MM_INIT_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_RAM_OPERATION_STATUS() \
        GP_WB_READ_U8(0x74a)

/* Indicates that the BIST test is finished */
#define GP_WB_READ_MM_BIST_RDY() \
        GP_WB_READ_U1(0x74a, 0)

#define GP_WB_GET_MM_BIST_RDY_FROM_RAM_OPERATION_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_MM_BIST_OK() \
        GP_WB_READ_U1(0x74a, 1)

#define GP_WB_GET_MM_BIST_OK_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the ram crc calculation or init is ongoing */
#define GP_WB_READ_MM_CRC_INIT_BUSY() \
        GP_WB_READ_U1(0x74a, 2)

#define GP_WB_GET_MM_CRC_INIT_BUSY_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/***************************
 * layout: pbm_adm
 ***************************/

/* PBM entry external uC bit mask (bit 1 = '1' => entry 1 can be claimed, etc.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_UC_MASK() \
        GP_WB_READ_U8(0x780)

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_UC_MASK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x780, (val)); \
        } while (0)


/* PBM entry RT-MAC bit mask (bit 2 = '1' => entry 2 can be claimed, etc.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_RXMAC_MASK() \
        GP_WB_READ_U8(0x781)

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_RXMAC_MASK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x781, (val)); \
        } while (0)


/* Claim PBM entry by external uC, read to claim an available one */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_CLAIM() \
        GP_WB_READ_U8(0x782)


/* Free PBM entry by writing a number */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_RETURN() \
        GP_WB_READ_U8(0x783)

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_RETURN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_WRITE_U8(0x783, (val)); \
        } while (0)


/* Currently claimed PBM entries (bit 0 = '1' => entry 0 is claimed ect.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_CLAIMED() \
        GP_WB_READ_U8(0x784)

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_CLAIMED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_WRITE_U8(0x784, (val)); \
        } while (0)

/***************************
 * layout: standby
 ***************************/

/* Version register */
#define GP_WB_READ_STANDBY_VERSION() \
        GP_WB_READ_U16(0x800)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_STBY_MODE_0() \
        GP_WB_READ_U8(0x802)

#define GP_WB_WRITE_STANDBY_STBY_MODE_0(val) \
      GP_WB_WRITE_U8(0x802, (val))

/* SM CRC calculation enabled when 0x1 */
#define GP_WB_READ_STANDBY_CRC_ENABLE() \
        GP_WB_READ_U1(0x802, 0)

#define GP_WB_GET_STANDBY_CRC_ENABLE_FROM_STBY_MODE_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CRC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x802, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CRC_ENABLE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* MW write enabled when 0x1 */
#define GP_WB_READ_STANDBY_MW_ENABLE() \
        GP_WB_READ_U1(0x802, 1)

#define GP_WB_GET_STANDBY_MW_ENABLE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_MW_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x802, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_MW_ENABLE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Field indicating that the wb backup needs to be done */
#define GP_WB_READ_STANDBY_WB_BACKUP_NEEDED() \
        GP_WB_READ_U1(0x802, 2)

#define GP_WB_GET_STANDBY_WB_BACKUP_NEEDED_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_WB_BACKUP_NEEDED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x802, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WB_BACKUP_NEEDED_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Sets if the vlt_status needs to be triggered when vddb below threshold (=1) or when above threshold (=0) */
#define GP_WB_READ_STANDBY_VLT_STATUS_COMPARE_VALUE() \
        GP_WB_READ_U1(0x802, 3)

#define GP_WB_GET_STANDBY_VLT_STATUS_COMPARE_VALUE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_VLT_STATUS_COMPARE_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x802, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_VLT_STATUS_COMPARE_VALUE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* CPU clock selection: 0x00 = 1 MHz, 0x01 = 2 MHz, 0x02 = 4 MHz, 0x03 = 8 MHz, 0x04 = 16 MHz */
#define GP_WB_READ_STANDBY_CLK_SELECT_CPU() \
        GP_WB_READ_U8(0x803)

#define GP_WB_WRITE_STANDBY_CLK_SELECT_CPU(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x803, (val)); \
        } while (0)


#define GP_WB_WRITE_STANDBY_RST_PULSE(val) \
      GP_WB_WRITE_U8(0x804, (val))

/* reset pulse for external CPU when 0x1 */
#define GP_WB_STANDBY_RESET_PULSE_CPU_SW() \
        GP_WB_WRITE_U8(0x804, 0x01)

#define GP_WB_SET_STANDBY_RESET_PULSE_CPU_SW_TO_RST_PULSE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Resets the internal uc when '1' */
#define GP_WB_STANDBY_RESET_PULSE_INT_UC() \
        GP_WB_WRITE_U8(0x804, 0x02)

#define GP_WB_SET_STANDBY_RESET_PULSE_INT_UC_TO_RST_PULSE(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RESET_FUNC() \
        GP_WB_READ_U32(0x806)

#define GP_WB_WRITE_STANDBY_RESET_FUNC(val) \
      GP_WB_WRITE_U32(0x806, (val))

/* Resets the external CPU  when '1' */
#define GP_WB_READ_STANDBY_RESET_CPU_SW() \
        GP_WB_READ_U1(0x806, 0)

#define GP_WB_GET_STANDBY_RESET_CPU_SW_FROM_RESET_FUNC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_CPU_SW(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_CPU_SW_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Resets the internal uc  when '1' */
#define GP_WB_READ_STANDBY_RESET_INT_UC() \
        GP_WB_READ_U1(0x806, 1)

#define GP_WB_GET_STANDBY_RESET_INT_UC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_INT_UC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Resets the internal uc sif logic  when '1' */
#define GP_WB_READ_STANDBY_RESET_SIF() \
        GP_WB_READ_U1(0x806, 2)

#define GP_WB_GET_STANDBY_RESET_SIF_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_SIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_SIF_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Reset the spi slave when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SPI_S() \
        GP_WB_READ_U1(0x806, 3)

#define GP_WB_GET_STANDBY_RESET_EPI_SPI_S_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SPI_S_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Reset the twi slave block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_TWI_S() \
        GP_WB_READ_U1(0x806, 4)

#define GP_WB_GET_STANDBY_RESET_EPI_TWI_S_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_TWI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_TWI_S_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Resets the macfilter sequencer */
#define GP_WB_READ_STANDBY_RESET_SEQ() \
        GP_WB_READ_U1(0x806, 5)

#define GP_WB_GET_STANDBY_RESET_SEQ_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_SEQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_SEQ_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Reset the es timeref block when '1' */
#define GP_WB_READ_STANDBY_RESET_ES_TIMEREF() \
        GP_WB_READ_U1(0x806, 6)

#define GP_WB_GET_STANDBY_RESET_ES_TIMEREF_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_ES_TIMEREF_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Reset the es event block when '1' */
#define GP_WB_READ_STANDBY_RESET_ES_EVENT() \
        GP_WB_READ_U1(0x806, 7)

#define GP_WB_GET_STANDBY_RESET_ES_EVENT_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x806, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_ES_EVENT_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Reset the gpio block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_GPIO() \
        GP_WB_READ_U1(0x807, 0)

#define GP_WB_GET_STANDBY_RESET_EPI_GPIO_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_GPIO_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Reset the ssp block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SSP() \
        GP_WB_READ_U1(0x807, 1)

#define GP_WB_GET_STANDBY_RESET_EPI_SSP_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SSP_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Reset the coex block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_COEX() \
        GP_WB_READ_U1(0x807, 2)

#define GP_WB_GET_STANDBY_RESET_EPI_COEX_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_COEX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_COEX_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Reset the uart block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_UART() \
        GP_WB_READ_U1(0x807, 3)

#define GP_WB_GET_STANDBY_RESET_EPI_UART_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_UART_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Reset the keypad scan block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_KEYPAD() \
        GP_WB_READ_U1(0x807, 4)

#define GP_WB_GET_STANDBY_RESET_EPI_KEYPAD_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_KEYPAD_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Reset the spi master block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SPI_M() \
        GP_WB_READ_U1(0x807, 5)

#define GP_WB_GET_STANDBY_RESET_EPI_SPI_M_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SPI_M_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Reset the twi master block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_TWI_M() \
        GP_WB_READ_U1(0x807, 6)

#define GP_WB_GET_STANDBY_RESET_EPI_TWI_M_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_TWI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_TWI_M_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Reset for the IR peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_IR() \
        GP_WB_READ_U1(0x807, 7)

#define GP_WB_GET_STANDBY_RESET_EPI_IR_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x807, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_IR_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Reset for the Led driver peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_LED() \
        GP_WB_READ_U1(0x808, 0)

#define GP_WB_GET_STANDBY_RESET_EPI_LED_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_LED_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Reset for the adcif / rssi  peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_ADCIF() \
        GP_WB_READ_U1(0x808, 1)

#define GP_WB_GET_STANDBY_RESET_EPI_ADCIF_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_ADCIF_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Reset for the inter processor communication peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_IPC() \
        GP_WB_READ_U1(0x808, 2)

#define GP_WB_GET_STANDBY_RESET_EPI_IPC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_IPC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Reset for the dma peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_DMA() \
        GP_WB_READ_U1(0x808, 3)

#define GP_WB_GET_STANDBY_RESET_EPI_DMA_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_DMA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_DMA_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FF7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Reset for the PWM peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_PWM() \
        GP_WB_READ_U1(0x808, 4)

#define GP_WB_GET_STANDBY_RESET_EPI_PWM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_PWM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Reset the pseudo random generator block when '1' */
#define GP_WB_READ_STANDBY_RESET_PRG() \
        GP_WB_READ_U1(0x808, 5)

#define GP_WB_GET_STANDBY_RESET_PRG_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PRG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PRG_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Reset the phy when '1' */
#define GP_WB_READ_STANDBY_RESET_PHY() \
        GP_WB_READ_U1(0x808, 6)

#define GP_WB_GET_STANDBY_RESET_PHY_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PHY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PHY_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FBFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* reset the rtm when '1' */
#define GP_WB_READ_STANDBY_RESET_RTM() \
        GP_WB_READ_U1(0x808, 7)

#define GP_WB_GET_STANDBY_RESET_RTM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_RTM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x808, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_RTM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* reset the iob when '1' */
#define GP_WB_READ_STANDBY_RESET_IOB() \
        GP_WB_READ_U1(0x809, 0)

#define GP_WB_GET_STANDBY_RESET_IOB_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_IOB(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x809, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_IOB_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0EFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* reset the standby memory and its peripheral blocks when '1' */
#define GP_WB_READ_STANDBY_RESET_MM_STBM() \
        GP_WB_READ_U1(0x809, 1)

#define GP_WB_GET_STANDBY_RESET_MM_STBM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x809, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MM_STBM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0DFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* reset the flash controller and peripheral blocks when '1' */
#define GP_WB_READ_STANDBY_RESET_MM_FLASH() \
        GP_WB_READ_U1(0x809, 2)

#define GP_WB_GET_STANDBY_RESET_MM_FLASH_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MM_FLASH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x809, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MM_FLASH_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0BFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* reset the spi/twi controller when '1' */
#define GP_WB_READ_STANDBY_RESET_MSI_CORE() \
        GP_WB_READ_U1(0x809, 3)

#define GP_WB_GET_STANDBY_RESET_MSI_CORE_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x809, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MSI_CORE_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RESET_REGMAP() \
        GP_WB_READ_U32(0x80a)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP(val) \
      GP_WB_WRITE_U32(0x80a, (val))

/* resets the iob regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_IOB() \
        GP_WB_READ_U1(0x80a, 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_IOB_FROM_RESET_REGMAP(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_IOB(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_IOB_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* resets the stby controller regmap. This resets all registers in this regmap!! */
#define GP_WB_READ_STANDBY_RESET_REGMAP_STBC() \
        GP_WB_READ_U1(0x80a, 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_STBC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_STBC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_STBC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Resets the internal uC regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_INT_UC() \
        GP_WB_READ_U1(0x80a, 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_INT_UC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_INT_UC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Resets the macfilt sequencer regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_SEQ() \
        GP_WB_READ_U1(0x80a, 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_SEQ_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_SEQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_SEQ_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* resets the es regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_ES() \
        GP_WB_READ_U1(0x80a, 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_ES_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_ES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_ES_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* resets the gpio regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_GPIO() \
        GP_WB_READ_U1(0x80a, 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_GPIO_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_GPIO_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* resets the twi master regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_TWI_M() \
        GP_WB_READ_U1(0x80a, 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_TWI_M_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_TWI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_TWI_M_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* resets the ssp regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SSP() \
        GP_WB_READ_U1(0x80a, 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SSP_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80a, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SSP_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* resets the coex regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_COEX() \
        GP_WB_READ_U1(0x80b, 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_COEX_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_COEX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_COEX_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* resets the uart regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_UART() \
        GP_WB_READ_U1(0x80b, 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_UART_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_UART_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* resets the keypad scan regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_KEYPAD() \
        GP_WB_READ_U1(0x80b, 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_KEYPAD_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_KEYPAD_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* resets the spi master regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SPI_M() \
        GP_WB_READ_U1(0x80b, 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SPI_M_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SPI_M_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* resets the epi ir block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_IR() \
        GP_WB_READ_U1(0x80b, 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_IR_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_IR_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* resets the epi led driver block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_LED() \
        GP_WB_READ_U1(0x80b, 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_LED_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_LED_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* resets the adcif block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_ADCIF() \
        GP_WB_READ_U1(0x80b, 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_ADCIF_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_ADCIF_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* resets the ipc block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_IPC() \
        GP_WB_READ_U1(0x80b, 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_IPC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80b, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_IPC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* resets the dma block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_DMA() \
        GP_WB_READ_U1(0x80c, 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_DMA_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_DMA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_DMA_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* resets the pwm block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_PWM() \
        GP_WB_READ_U1(0x80c, 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_PWM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_PWM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* resets the prg regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PRG() \
        GP_WB_READ_U1(0x80c, 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PRG_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PRG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PRG_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* resets the phy regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PHY() \
        GP_WB_READ_U1(0x80c, 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PHY_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PHY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PHY_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FF7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* resets the rtm regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_RTM() \
        GP_WB_READ_U1(0x80c, 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_RTM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_RTM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_RTM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* resets the qta regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(0x80c, 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_RTM_QTA_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_RTM_QTA_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* resets the mm regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MM() \
        GP_WB_READ_U1(0x80c, 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FBFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* resets the msi interrupt controller regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(0x80c, 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MSI_INT_CTRL_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80c, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MSI_INT_CTRL_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* resets the msi core regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MSI_CORE() \
        GP_WB_READ_U1(0x80d, 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MSI_CORE_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80d, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MSI_CORE_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0EFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* resets the pbm admin regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(0x80d, 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PBM_ADMIN_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80d, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PBM_ADMIN_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0DFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* resets the spi slave regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SPI_S() \
        GP_WB_READ_U1(0x80d, 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SPI_S_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80d, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SPI_S_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0BFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* resets the twi slave regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_TWI_S() \
        GP_WB_READ_U1(0x80d, 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_TWI_S_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_TWI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80d, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_TWI_S_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_CLK_ENABLE_FUNC() \
        GP_WB_READ_U32(0x80e)

#define GP_WB_WRITE_STANDBY_CLK_ENABLE_FUNC(val) \
      GP_WB_WRITE_U32(0x80e, (val))

/* Disables the clock to the external cpu when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_CPU() \
        GP_WB_READ_U1(0x80e, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_CPU_FROM_CLK_ENABLE_FUNC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_CPU(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_CPU_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Disables the clock to the internal uc when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_INT_UC() \
        GP_WB_READ_U1(0x80e, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_INT_UC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_INT_UC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Disables the clock to the epi spi slave block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SPI_S() \
        GP_WB_READ_U1(0x80e, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SPI_S_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SPI_S_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Disables the clock to the epi twi slave block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_TWI_S() \
        GP_WB_READ_U1(0x80e, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_TWI_S_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_TWI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_TWI_S_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Clk enable for the macfilt sequencer */
#define GP_WB_READ_STANDBY_CLK_ENA_SEQ() \
        GP_WB_READ_U1(0x80e, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_SEQ_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_SEQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_SEQ_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Disables the clock to the es timeref block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_ES_TIMEREF() \
        GP_WB_READ_U1(0x80e, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_ES_TIMEREF_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_ES_TIMEREF_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Disables the clock to the es event block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_ES_EVENT() \
        GP_WB_READ_U1(0x80e, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_ES_EVENT_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_ES_EVENT_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Disables the clock to the epi gpio block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_GPIO() \
        GP_WB_READ_U1(0x80e, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_GPIO_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80e, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_GPIO_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Disables the clock to the epi ssp block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SSP() \
        GP_WB_READ_U1(0x80f, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SSP_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SSP_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Disables the clock to the epi coex block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_COEX() \
        GP_WB_READ_U1(0x80f, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_COEX_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_COEX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_COEX_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Disables the clock to the epi uart block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_UART() \
        GP_WB_READ_U1(0x80f, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_UART_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_UART_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Disables the clock to the epi keypad scan block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_KEYPAD() \
        GP_WB_READ_U1(0x80f, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_KEYPAD_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_KEYPAD_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Disables the clock to the epi ir block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_IR() \
        GP_WB_READ_U1(0x80f, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_IR_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_IR_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Disables the clock to the epi led block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_LED() \
        GP_WB_READ_U1(0x80f, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_LED_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_LED_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Disables the clock to the epi spi master block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SPI_M() \
        GP_WB_READ_U1(0x80f, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SPI_M_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SPI_M_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Disables the clock to the twi master block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_TWI_M() \
        GP_WB_READ_U1(0x80f, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_TWI_M_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_TWI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x80f, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_TWI_M_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Disables the clock to the adcif block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_ADCIF() \
        GP_WB_READ_U1(0x810, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_ADCIF_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_ADCIF_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Disables the clock to the ipc block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_IPC() \
        GP_WB_READ_U1(0x810, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_IPC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_IPC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Disables the clock to the dma block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_DMA() \
        GP_WB_READ_U1(0x810, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_DMA_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_DMA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_DMA_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Disables the clock to the pwm block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_PWM() \
        GP_WB_READ_U1(0x810, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_PWM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_PWM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03F7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Disables the clock to the pseudo random generator block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PRG() \
        GP_WB_READ_U1(0x810, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_PRG_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PRG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PRG_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03EFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Disables the clock to the phy block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PHY() \
        GP_WB_READ_U1(0x810, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_PHY_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PHY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PHY_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03DFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Disables the clock to the rtm block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_RTM() \
        GP_WB_READ_U1(0x810, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_RTM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_RTM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_RTM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03BFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* Disables the clock to the standby memory and its peripheral blocks when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MM_STBM() \
        GP_WB_READ_U1(0x810, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_MM_STBM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x810, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MM_STBM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x037FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Disables the clock to  the flash controller and peripheral blocks when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MM_FLASH() \
        GP_WB_READ_U1(0x811, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_MM_FLASH_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MM_FLASH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x811, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MM_FLASH_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Disables the clock to  the spi/twi controller when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MSI_CORE() \
        GP_WB_READ_U1(0x811, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_MSI_CORE_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x811, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MSI_CORE_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_CLK_ENABLE_REGMAP() \
        GP_WB_READ_U32(0x812)

#define GP_WB_WRITE_STANDBY_CLK_ENABLE_REGMAP(val) \
      GP_WB_WRITE_U32(0x812, (val))

/* Disables the clock to the iob regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_IOB() \
        GP_WB_READ_U1(0x812, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_IOB_FROM_CLK_ENABLE_REGMAP(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_IOB(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_IOB_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Disables the clock to PMUD regmap (the always on power domain) when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PMUD() \
        GP_WB_READ_U1(0x812, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PMUD_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PMUD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PMUD_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* clk enable for the internal uc regmap */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_INT_UC() \
        GP_WB_READ_U1(0x812, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_INT_UC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_INT_UC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* clk enable for the sequencer regmap */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_SEQ() \
        GP_WB_READ_U1(0x812, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_SEQ_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_SEQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_SEQ_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Disables the clock to the es regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_ES() \
        GP_WB_READ_U1(0x812, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_ES_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_ES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_ES_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Disables the clock to the gpio regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_GPIO() \
        GP_WB_READ_U1(0x812, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_GPIO_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_GPIO_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Disables the clock to the twi mastrer regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_TWI_M() \
        GP_WB_READ_U1(0x812, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_TWI_M_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_TWI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_TWI_M_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Disables the clock to the ssp regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SSP() \
        GP_WB_READ_U1(0x812, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SSP_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x812, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SSP_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Disables the clock to the coex regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_COEX() \
        GP_WB_READ_U1(0x813, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_COEX_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_COEX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_COEX_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Disables the clock to the uart regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_UART() \
        GP_WB_READ_U1(0x813, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_UART_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_UART_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Disables the clock to the keypad scan regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_KEYPAD() \
        GP_WB_READ_U1(0x813, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_KEYPAD_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_KEYPAD_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Disables the clock to the spi master regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M() \
        GP_WB_READ_U1(0x813, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Disables the clock to the ir regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_IR() \
        GP_WB_READ_U1(0x813, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_IR_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_IR_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Disables the clock to the led regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_LED() \
        GP_WB_READ_U1(0x813, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_LED_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_LED_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Disables the clock to the ipc regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_IPC() \
        GP_WB_READ_U1(0x813, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_IPC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_IPC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Disables the clock to the adcif regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF() \
        GP_WB_READ_U1(0x813, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x813, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Disables the clock to the dma regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_DMA() \
        GP_WB_READ_U1(0x814, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_DMA_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_DMA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_DMA_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Disables the clock to the pwm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_PWM() \
        GP_WB_READ_U1(0x814, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_PWM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_PWM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Disables the clock to the prg regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PRG() \
        GP_WB_READ_U1(0x814, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PRG_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PRG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PRG_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FFBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Disables the clock to the phy regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PHY() \
        GP_WB_READ_U1(0x814, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PHY_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PHY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PHY_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FF7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Disables the clock to the rtm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_RTM() \
        GP_WB_READ_U1(0x814, 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_RTM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_RTM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_RTM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Disables the clock to the qta regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(0x814, 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_RTM_QTA_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_RTM_QTA_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Disables the clock to the mm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MM() \
        GP_WB_READ_U1(0x814, 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0FBFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* Disables the clock to the msi interrupt controller regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(0x814, 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x814, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Disables the clock to the msi core regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MSI_CORE() \
        GP_WB_READ_U1(0x815, 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MSI_CORE_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x815, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MSI_CORE_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0EFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(0x815, 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x815, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0DFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S() \
        GP_WB_READ_U1(0x815, 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x815, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0BFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_TWI_S() \
        GP_WB_READ_U1(0x815, 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_TWI_S_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_TWI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x815, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_TWI_S_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


#define GP_WB_WRITE_STANDBY_SNAPSHOT_CTRL(val) \
      GP_WB_WRITE_U8(0x816, (val))

/* Sample retention when 0x1 */
#define GP_WB_STANDBY_SAMPLE_RET() \
        GP_WB_WRITE_U8(0x816, 0x01)

#define GP_WB_SET_STANDBY_SAMPLE_RET_TO_SNAPSHOT_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* preload retention when 0x1 */
#define GP_WB_STANDBY_PRELOAD_RET() \
        GP_WB_WRITE_U8(0x816, 0x02)

#define GP_WB_SET_STANDBY_PRELOAD_RET_TO_SNAPSHOT_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_POWERUP_AND_ISOLATION_CTRL() \
        GP_WB_READ_U8(0x817)

#define GP_WB_WRITE_STANDBY_POWERUP_AND_ISOLATION_CTRL(val) \
      GP_WB_WRITE_U8(0x817, (val))

/* This is the main clock enable of the chip. It needs to be put to 1 in order to enable the main functionality. When 0 only regmaps/uc/rams and flash have a clock */
#define GP_WB_READ_STANDBY_ENABLE_MAIN_CLOCKS() \
        GP_WB_READ_U1(0x817, 0)

#define GP_WB_GET_STANDBY_ENABLE_MAIN_CLOCKS_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_ENABLE_MAIN_CLOCKS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x817, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ENABLE_MAIN_CLOCKS_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Needs to be explicitely set by SW, when chip is ready to drive ioring */
#define GP_WB_READ_STANDBY_ACTIVATE_IORING() \
        GP_WB_READ_U1(0x817, 1)

#define GP_WB_GET_STANDBY_ACTIVATE_IORING_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_ACTIVATE_IORING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x817, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ACTIVATE_IORING_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Isolate radio from digital logic when 0x1, actual signal is low active */
#define GP_WB_READ_STANDBY_RADIO_ISOLATE() \
        GP_WB_READ_U1(0x817, 2)

#define GP_WB_GET_STANDBY_RADIO_ISOLATE_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RADIO_ISOLATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x817, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RADIO_ISOLATE_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Debug feature in order to be able to overrule the ldo_rdy state from the different ldo's (radio/adc) in determinng id the ldo domain needs to be isolated */
#define GP_WB_READ_STANDBY_IGNORE_LDO_RDY_FOR_ISOLATION() \
        GP_WB_READ_U1(0x817, 3)

#define GP_WB_GET_STANDBY_IGNORE_LDO_RDY_FOR_ISOLATION_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_IGNORE_LDO_RDY_FOR_ISOLATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x817, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_IGNORE_LDO_RDY_FOR_ISOLATION_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Debug feature to disable the isolation for radio and ADC. the radio_isolate has priority on this ! */
#define GP_WB_READ_STANDBY_OVERRULE_ISOLATION() \
        GP_WB_READ_U1(0x817, 4)

#define GP_WB_GET_STANDBY_OVERRULE_ISOLATION_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_OVERRULE_ISOLATION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x817, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_OVERRULE_ISOLATION_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Threshold for Ready to go to standby check. Number of 16 MHz clock cycles all need to be ready before going to standby. 0 = ready signals overlap for duration of one 16 MHz clock cycle */
#define GP_WB_READ_STANDBY_RTGTS_THRESHOLD() \
        GP_WB_READ_U8(0x818)

#define GP_WB_WRITE_STANDBY_RTGTS_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(0x818, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_0() \
        GP_WB_READ_U8(0x819)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_0(val) \
      GP_WB_WRITE_U8(0x819, (val))

/* Ready to go to standby overrule for es interrup from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_INTERRUPT() \
        GP_WB_READ_U1(0x819, 0)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_INTERRUPT_FROM_RTGTS_SW_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x819, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_INTERRUPT_TO_RTGTS_SW_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for es event handler from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_EVENT_HANDLER() \
        ((GP_WB_READ_U8(0x819) >> 1) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_EVENT_HANDLER_FROM_RTGTS_SW_0(tmp) \
        (((tmp) >> 1) & 0x3F)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_EVENT_HANDLER(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_MWRITE_U8(0x819, 0x7E, (val) << 1); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_EVENT_HANDLER_TO_RTGTS_SW_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_1() \
        GP_WB_READ_U8(0x81a)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_1(val) \
      GP_WB_WRITE_U8(0x81a, (val))

/* Ready to go to standby overrule for es timereference from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_TIME_REFERENCE() \
        (GP_WB_READ_U8(0x81a) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_TIME_REFERENCE_FROM_RTGTS_SW_1(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_TIME_REFERENCE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_MWRITE_U8(0x81a, 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_TIME_REFERENCE_TO_RTGTS_SW_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for gpio from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_GPIO() \
        GP_WB_READ_U1(0x81a, 6)

#define GP_WB_GET_STANDBY_RTGTS_SW_GPIO_FROM_RTGTS_SW_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81a, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_GPIO_TO_RTGTS_SW_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Ready to go to standby overrule for the led driver from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_LED() \
        GP_WB_READ_U1(0x81a, 7)

#define GP_WB_GET_STANDBY_RTGTS_SW_LED_FROM_RTGTS_SW_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81a, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_LED_TO_RTGTS_SW_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_2() \
        GP_WB_READ_U8(0x81b)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_2(val) \
      GP_WB_WRITE_U8(0x81b, (val))

/* Ready to go to standby overrule for dps from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_DPS() \
        (GP_WB_READ_U8(0x81b) & 0x03)

#define GP_WB_GET_STANDBY_RTGTS_SW_DPS_FROM_RTGTS_SW_2(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_DPS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x81b, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_DPS_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for msi peripherals from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_MSI_PERIP() \
        GP_WB_READ_U1(0x81b, 3)

#define GP_WB_GET_STANDBY_RTGTS_SW_MSI_PERIP_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_MSI_PERIP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81b, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_MSI_PERIP_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x73; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Ready to go to standby overrule for pending masked interrupts */
#define GP_WB_READ_STANDBY_RTGTS_SW_INTERRUPTS() \
        GP_WB_READ_U1(0x81b, 4)

#define GP_WB_GET_STANDBY_RTGTS_SW_INTERRUPTS_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81b, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_INTERRUPTS_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6B; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Ready to go to standby overrule for keypad scan from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_KEYPAD() \
        GP_WB_READ_U1(0x81b, 5)

#define GP_WB_GET_STANDBY_RTGTS_SW_KEYPAD_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81b, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_KEYPAD_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5B; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Ready to go to standby overrule for the internal UC from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_INTUC() \
        GP_WB_READ_U1(0x81b, 6)

#define GP_WB_GET_STANDBY_RTGTS_SW_INTUC_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_INTUC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81b, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_INTUC_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_3() \
        GP_WB_READ_U8(0x81c)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_3(val) \
      GP_WB_WRITE_U8(0x81c, (val))

/* Ready to go to standby overrule for spi slave selected */
#define GP_WB_READ_STANDBY_RTGTS_SW_SPI_SL() \
        GP_WB_READ_U1(0x81c, 0)

#define GP_WB_GET_STANDBY_RTGTS_SW_SPI_SL_FROM_RTGTS_SW_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_SPI_SL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81c, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_SPI_SL_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for i2c slave selected */
#define GP_WB_READ_STANDBY_RTGTS_SW_I2C_SL() \
        GP_WB_READ_U1(0x81c, 1)

#define GP_WB_GET_STANDBY_RTGTS_SW_I2C_SL_FROM_RTGTS_SW_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_I2C_SL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81c, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_I2C_SL_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Ready to go to standby overrule for uart TX busy */
#define GP_WB_READ_STANDBY_RTGTS_SW_UART() \
        GP_WB_READ_U1(0x81c, 2)

#define GP_WB_GET_STANDBY_RTGTS_SW_UART_FROM_RTGTS_SW_3(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81c, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_UART_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* SW ready to go to standby */
#define GP_WB_READ_STANDBY_RTGTS_SW() \
        GP_WB_READ_U1(0x81d, 0)

#define GP_WB_WRITE_STANDBY_RTGTS_SW(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x81d, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_NVM_DPDOWN_CONFIG() \
        GP_WB_READ_U8(0x81e)

#define GP_WB_WRITE_STANDBY_NVM_DPDOWN_CONFIG(val) \
      GP_WB_WRITE_U8(0x81e, (val))

/* This bit indicates if we want to wait until the NVM macro is in its deep power down state, before actually going to standby (Putting this to 0 speeds up going to sleep) */
#define GP_WB_READ_STANDBY_WAIT_FOR_NVM_DPDOWN() \
        GP_WB_READ_U1(0x81e, 0)

#define GP_WB_GET_STANDBY_WAIT_FOR_NVM_DPDOWN_FROM_NVM_DPDOWN_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_WAIT_FOR_NVM_DPDOWN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81e, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WAIT_FOR_NVM_DPDOWN_TO_NVM_DPDOWN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* This bit indicates if we want to enable the NVM (so in fact enable the read voltage and make sure the nvm state machine is in read mode) while the chip is in the active state */
#define GP_WB_READ_STANDBY_KEEP_NVM_ON_DURING_ACTIVE() \
        GP_WB_READ_U1(0x81e, 1)

#define GP_WB_GET_STANDBY_KEEP_NVM_ON_DURING_ACTIVE_FROM_NVM_DPDOWN_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_KEEP_NVM_ON_DURING_ACTIVE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x81e, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_KEEP_NVM_ON_DURING_ACTIVE_TO_NVM_DPDOWN_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_0() \
        GP_WB_READ_U8(0x81f)

/* Status of ready to go to standbvy for es interrupt */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_INTERRUPT() \
        GP_WB_READ_U1(0x81f, 0)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_INTERRUPT_FROM_RTGTS_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* Status of ready to go to standbvy for es event handler */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_EVENT_HANDLER() \
        ((GP_WB_READ_U8(0x81f) >> 1) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_EVENT_HANDLER_FROM_RTGTS_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x3F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_1() \
        GP_WB_READ_U8(0x820)

/* Status of ready to go to standby for es time reference */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_TIME_REFERENCE() \
        (GP_WB_READ_U8(0x820) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_TIME_REFERENCE_FROM_RTGTS_STATUS_1(tmp) \
        ((tmp) & 0x3F)

/* Status of ready to go to standby for gpio */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_GPIO() \
        GP_WB_READ_U1(0x820, 6)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_GPIO_FROM_RTGTS_STATUS_1(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status of ready to go to standby for the led driver */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_LED() \
        GP_WB_READ_U1(0x820, 7)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_LED_FROM_RTGTS_STATUS_1(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_2() \
        GP_WB_READ_U8(0x821)

/* Status of ready to go to standby for dps */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_DPS() \
        (GP_WB_READ_U8(0x821) & 0x03)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_DPS_FROM_RTGTS_STATUS_2(tmp) \
        ((tmp) & 0x03)

/* Status of ready to go to standby for msi peripherals */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_MSI_PERIP() \
        GP_WB_READ_U1(0x821, 3)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_MSI_PERIP_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status of ready to go to standby for interrupts peripheral */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_INTERRUPTS() \
        GP_WB_READ_U1(0x821, 4)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_INTERRUPTS_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status of ready to go to standby for keypad scan */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_KEYPAD() \
        GP_WB_READ_U1(0x821, 5)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_KEYPAD_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status of ready to go to standby for internal uc */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_INTUC() \
        GP_WB_READ_U1(0x821, 6)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_INTUC_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_3() \
        GP_WB_READ_U8(0x822)

/* Status of ready to go to standby for spi slave selected */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_SPI_SL() \
        GP_WB_READ_U1(0x822, 0)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_SPI_SL_FROM_RTGTS_STATUS_3(tmp) \
        ((tmp) & 0x01)

/* Status of ready to go to standby for i2c slave selected */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_I2C_SL() \
        GP_WB_READ_U1(0x822, 1)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_I2C_SL_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of ready to go to standby for uart TX busy */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_UART() \
        GP_WB_READ_U1(0x822, 2)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_UART_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_UNMASKED_INTERRUPT_STATUS_0() \
        GP_WB_READ_U8(0x823)

/* Interrupt event power on reset detected, set to 0x1 when detected */
#define GP_WB_READ_STANDBY_UNMASKED_PORD_INTERRUPT() \
        GP_WB_READ_U1(0x823, 0)

#define GP_WB_GET_STANDBY_UNMASKED_PORD_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* Interrupt event Active state, set to 0x1 when detected */
#define GP_WB_READ_STANDBY_UNMASKED_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(0x823, 1)

#define GP_WB_GET_STANDBY_UNMASKED_ACTIVE_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x01)

/* interrupt event when iso_tx brown out */
#define GP_WB_READ_STANDBY_UNMASKED_ISO_TX_INTERRUPT() \
        GP_WB_READ_U1(0x823, 2)

#define GP_WB_GET_STANDBY_UNMASKED_ISO_TX_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS_0(tmp) \
        (((tmp) >> 2) & 0x01)

/* interrupt event when VRR (or VCC1) brown out */
#define GP_WB_READ_STANDBY_UNMASKED_VRR_BROWNOUT_INTERRUPT() \
        GP_WB_READ_U1(0x823, 3)

#define GP_WB_GET_STANDBY_UNMASKED_VRR_BROWNOUT_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS_0(tmp) \
        (((tmp) >> 3) & 0x01)

/* interrupt event when vlt_status = vlt_compare_value brown out */
#define GP_WB_READ_STANDBY_UNMASKED_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(0x823, 4)

#define GP_WB_GET_STANDBY_UNMASKED_VLT_STATUS_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS_0(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_STANDBY_CLR_INTERRUPT_0(val) \
      GP_WB_WRITE_U8(0x824, (val))

/* Interrupt event clear power on reset detected by writing 0x1 */
#define GP_WB_STANDBY_CLR_PORD_INTERRUPT() \
        GP_WB_WRITE_U8(0x824, 0x01)

#define GP_WB_SET_STANDBY_CLR_PORD_INTERRUPT_TO_CLR_INTERRUPT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt event clear Active state by writing 0x1 */
#define GP_WB_STANDBY_CLR_ACTIVE_INTERRUPT() \
        GP_WB_WRITE_U8(0x824, 0x02)

#define GP_WB_SET_STANDBY_CLR_ACTIVE_INTERRUPT_TO_CLR_INTERRUPT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Interrupt event clear iso_tx by writing 0x1 */
#define GP_WB_STANDBY_CLR_ISO_TX_INTERRUPT() \
        GP_WB_WRITE_U8(0x824, 0x04)

#define GP_WB_SET_STANDBY_CLR_ISO_TX_INTERRUPT_TO_CLR_INTERRUPT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* vrr (=VCC1)  brownout interrupt clear by writing 0x1 */
#define GP_WB_STANDBY_CLR_VRR_BROWNOUT_INTERRUPT() \
        GP_WB_WRITE_U8(0x824, 0x08)

#define GP_WB_SET_STANDBY_CLR_VRR_BROWNOUT_INTERRUPT_TO_CLR_INTERRUPT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x27; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* vlt_status clear by writing 0x1 */
#define GP_WB_STANDBY_CLR_VLT_STATUS_INTERRUPT() \
        GP_WB_WRITE_U8(0x824, 0x20)

#define GP_WB_SET_STANDBY_CLR_VLT_STATUS_INTERRUPT_TO_CLR_INTERRUPT_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_SOFT_POR_CTRL() \
        GP_WB_READ_U8(0x825)

#define GP_WB_WRITE_STANDBY_SOFT_POR_CTRL(val) \
      GP_WB_WRITE_U8(0x825, (val))

/* When set to '1', a iso tx detect  will generate a soft_por */
#define GP_WB_READ_STANDBY_SOFT_POR_ON_ISO_TX_DETECT() \
        GP_WB_READ_U1(0x825, 0)

#define GP_WB_GET_STANDBY_SOFT_POR_ON_ISO_TX_DETECT_FROM_SOFT_POR_CTRL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_SOFT_POR_ON_ISO_TX_DETECT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x825, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_SOFT_POR_ON_ISO_TX_DETECT_TO_SOFT_POR_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', a vrr (or Vcc1) brownout will generate a soft por */
#define GP_WB_READ_STANDBY_SOFT_POR_ON_VRR_BROWNOUT() \
        GP_WB_READ_U1(0x825, 1)

#define GP_WB_GET_STANDBY_SOFT_POR_ON_VRR_BROWNOUT_FROM_SOFT_POR_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_SOFT_POR_ON_VRR_BROWNOUT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x825, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_SOFT_POR_ON_VRR_BROWNOUT_TO_SOFT_POR_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_STANDBY_STATUS() \
        GP_WB_READ_U8(0x826)

/* State (for debug only) */
#define GP_WB_READ_STANDBY_STANDBY_CONTROLLER_STATE() \
        (GP_WB_READ_U8(0x826) & 0x03)

#define GP_WB_GET_STANDBY_STANDBY_CONTROLLER_STATE_FROM_STANDBY_STATUS(tmp) \
        ((tmp) & 0x03)

/* Is 1 when vddb is below vlt threshold (which is 1.8V fixed at this time) */
#define GP_WB_READ_STANDBY_VLT_STATUS() \
        GP_WB_READ_U1(0x826, 2)

#define GP_WB_GET_STANDBY_VLT_STATUS_FROM_STANDBY_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


#define GP_WB_WRITE_STANDBY_LICENSE_ITF(val) \
      GP_WB_WRITE_U24(0x828, (val))

/* sets the nvm size (multiples of 32kB - use type for encoding) */
#define GP_WB_WRITE_STANDBY_NVM_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_WRITE_U8(0x828, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_SIZE_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x3FFFF8; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* sets the ram size (multiples of 4kB - use type for encoding) */
#define GP_WB_WRITE_STANDBY_RAM_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_WRITE_U8(0x828, (val) << 3); \
        } while (0)

#define GP_WB_SET_STANDBY_RAM_SIZE_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3FFFE7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Disables the spi slave interface */
#define GP_WB_STANDBY_DISABLE_SPI() \
        GP_WB_WRITE_U8(0x828, 0x20)

#define GP_WB_SET_STANDBY_DISABLE_SPI_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Disables the twi slave interface */
#define GP_WB_STANDBY_DISABLE_TWI() \
        GP_WB_WRITE_U8(0x828, 0x40)

#define GP_WB_SET_STANDBY_DISABLE_TWI_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Disables the sif interface */
#define GP_WB_STANDBY_DISABLE_SIF() \
        GP_WB_WRITE_U8(0x828, 0x80)

#define GP_WB_SET_STANDBY_DISABLE_SIF_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Disables the spi master interface */
#define GP_WB_STANDBY_DISABLE_SPI_M() \
        GP_WB_WRITE_U8(0x829, 0x01)

#define GP_WB_SET_STANDBY_DISABLE_SPI_M_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Disables the twi master interface */
#define GP_WB_STANDBY_DISABLE_TWI_M() \
        GP_WB_WRITE_U8(0x829, 0x02)

#define GP_WB_SET_STANDBY_DISABLE_TWI_M_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Disables the uart interface */
#define GP_WB_STANDBY_DISABLE_UART() \
        GP_WB_WRITE_U8(0x829, 0x04)

#define GP_WB_SET_STANDBY_DISABLE_UART_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Disables the gpio block */
#define GP_WB_STANDBY_DISABLE_GPIO() \
        GP_WB_WRITE_U8(0x829, 0x08)

#define GP_WB_SET_STANDBY_DISABLE_GPIO_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Disables the ir block */
#define GP_WB_STANDBY_DISABLE_IR() \
        GP_WB_WRITE_U8(0x829, 0x10)

#define GP_WB_SET_STANDBY_DISABLE_IR_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Disables the ir block */
#define GP_WB_STANDBY_DISABLE_LED() \
        GP_WB_WRITE_U8(0x829, 0x20)

#define GP_WB_SET_STANDBY_DISABLE_LED_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Disables the keyscan block */
#define GP_WB_STANDBY_DISABLE_KEYSCAN() \
        GP_WB_WRITE_U8(0x829, 0x40)

#define GP_WB_SET_STANDBY_DISABLE_KEYSCAN_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3FBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Disables the watchdog block */
#define GP_WB_STANDBY_DISABLE_WATCHDOG() \
        GP_WB_WRITE_U8(0x829, 0x80)

#define GP_WB_SET_STANDBY_DISABLE_WATCHDOG_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Disables the adc block */
#define GP_WB_STANDBY_DISABLE_ADC() \
        GP_WB_WRITE_U8(0x82a, 0x01)

#define GP_WB_SET_STANDBY_DISABLE_ADC_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3EFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Disables the coex interface block */
#define GP_WB_STANDBY_DISABLE_COEX_ITF() \
        GP_WB_WRITE_U8(0x82a, 0x02)

#define GP_WB_SET_STANDBY_DISABLE_COEX_ITF_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3DFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Locks the number of supported channels to what is set by the cm restore */
#define GP_WB_STANDBY_LOCK_MULTI_CHANNEL() \
        GP_WB_WRITE_U8(0x82a, 0x04)

#define GP_WB_SET_STANDBY_LOCK_MULTI_CHANNEL_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3BFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Locks the number of supported pans to what is set by the cm restore */
#define GP_WB_STANDBY_LOCK_MULTI_PAN() \
        GP_WB_WRITE_U8(0x82a, 0x08)

#define GP_WB_SET_STANDBY_LOCK_MULTI_PAN_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x37FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* locks write and read access to inf page */
#define GP_WB_STANDBY_LOCK_INF_PAGE() \
        GP_WB_WRITE_U8(0x82a, 0x10)

#define GP_WB_SET_STANDBY_LOCK_INF_PAGE_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2FFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* locks the interface to the license (when triggered, no more license updates can happen) */
#define GP_WB_STANDBY_LOCK_LICENSE_ITF() \
        GP_WB_WRITE_U8(0x82a, 0x20)

#define GP_WB_SET_STANDBY_LOCK_LICENSE_ITF_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_0_INP_ADDR() \
        GP_WB_READ_U16(0x82c)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_0_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x82c, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_0_REMAP_ADDR() \
        GP_WB_READ_U16(0x82e)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_0_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x82e, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_1_INP_ADDR() \
        GP_WB_READ_U16(0x830)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_1_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x830, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_1_REMAP_ADDR() \
        GP_WB_READ_U16(0x832)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_1_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x832, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_2_INP_ADDR() \
        GP_WB_READ_U16(0x834)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_2_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x834, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_2_REMAP_ADDR() \
        GP_WB_READ_U16(0x836)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_2_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x836, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_3_INP_ADDR() \
        GP_WB_READ_U16(0x838)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_3_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x838, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_3_REMAP_ADDR() \
        GP_WB_READ_U16(0x83a)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_3_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x83a, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_4_INP_ADDR() \
        GP_WB_READ_U16(0x83c)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_4_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x83c, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_4_REMAP_ADDR() \
        GP_WB_READ_U16(0x83e)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_4_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x83e, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_5_INP_ADDR() \
        GP_WB_READ_U16(0x840)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_5_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x840, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_5_REMAP_ADDR() \
        GP_WB_READ_U16(0x842)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_5_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x842, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_6_INP_ADDR() \
        GP_WB_READ_U16(0x844)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_6_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x844, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_6_REMAP_ADDR() \
        GP_WB_READ_U16(0x846)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_6_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x846, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_7_INP_ADDR() \
        GP_WB_READ_U16(0x848)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_7_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x848, (val)); \
        } while (0)


/* flash page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_PAGE_REMAP_ENTRY_7_REMAP_ADDR() \
        GP_WB_READ_U16(0x84a)

#define GP_WB_WRITE_STANDBY_NVM_PAGE_REMAP_ENTRY_7_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FF); \
          GP_WB_WRITE_U16(0x84a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_NVM_INF_PAGE_REMAP_ENTRY() \
        GP_WB_READ_U8(0x84c)

#define GP_WB_WRITE_STANDBY_NVM_INF_PAGE_REMAP_ENTRY(val) \
      GP_WB_WRITE_U8(0x84c, (val))

/* flash inf page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_INP_ADDR() \
        (GP_WB_READ_U8(0x84c) & 0x0F)

#define GP_WB_GET_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_INP_ADDR_FROM_NVM_INF_PAGE_REMAP_ENTRY(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x84c, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_INP_ADDR_TO_NVM_INF_PAGE_REMAP_ENTRY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* flash inf page word address that needs to be remapped */
#define GP_WB_READ_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_REMAP_ADDR() \
        ((GP_WB_READ_U8(0x84c) >> 4) & 0x0F)

#define GP_WB_GET_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_REMAP_ADDR_FROM_NVM_INF_PAGE_REMAP_ENTRY(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_REMAP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_MWRITE_U8(0x84c, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_INF_PAGE_REMAP_ENTRY_REMAP_ADDR_TO_NVM_INF_PAGE_REMAP_ENTRY(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U8(0x84d)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U8(0x84d, (val))

/* Does the logical to physical mapping of the first 64kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_0() \
        (GP_WB_READ_U8(0x84d) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_0_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x84d, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_0_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Does the logical to physical mapping of the second 64kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_1() \
        ((GP_WB_READ_U8(0x84d) >> 2) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_1_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x84d, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_1_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Does the logical to physical mapping of the third 64kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_2() \
        ((GP_WB_READ_U8(0x84d) >> 4) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_2_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x84d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_2_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Does the logical to physical mapping of the fourth 64kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_3() \
        ((GP_WB_READ_U8(0x84d) >> 6) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_3_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_MWRITE_U8(0x84d, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_3_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_LOCK_NVM_REMAP_ENTRIES() \
        GP_WB_READ_U16(0x84e)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U16(0x84e, (val))

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_0() \
        GP_WB_READ_U1(0x84e, 0)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_0_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_0_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_1() \
        GP_WB_READ_U1(0x84e, 1)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_1_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_1_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_2() \
        GP_WB_READ_U1(0x84e, 2)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_2_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_2_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_3() \
        GP_WB_READ_U1(0x84e, 3)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_3_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_3_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_4() \
        GP_WB_READ_U1(0x84e, 4)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_4_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_4_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_5() \
        GP_WB_READ_U1(0x84e, 5)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_5_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_5_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_6() \
        GP_WB_READ_U1(0x84e, 6)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_6_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_6_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_7() \
        GP_WB_READ_U1(0x84e, 7)

#define GP_WB_GET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_7_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84e, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_PAGE_REMAP_ENTRY_7_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Locks the page remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_INF_PAGE_REMAP_ENTRY() \
        GP_WB_READ_U1(0x84f, 0)

#define GP_WB_GET_STANDBY_LOCK_NVM_INF_PAGE_REMAP_ENTRY_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_INF_PAGE_REMAP_ENTRY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84f, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_INF_PAGE_REMAP_ENTRY_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* locks the block remapping fields (including this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U1(0x84f, 1)

#define GP_WB_GET_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x84f, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_FORCE_ON() \
        GP_WB_READ_U40(0x850)

#define GP_WB_WRITE_STANDBY_FORCE_ON(val) \
      GP_WB_WRITE_U40(0x850, (val))

/* All fons force on both func and regmap clocks */
#define GP_WB_READ_STANDBY_FON_CLK_INT_UC() \
        GP_WB_READ_U1(0x850, 0)

#define GP_WB_GET_STANDBY_FON_CLK_INT_UC_FROM_FORCE_ON(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_INT_UC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_SEQ() \
        GP_WB_READ_U1(0x850, 1)

#define GP_WB_GET_STANDBY_FON_CLK_SEQ_FROM_FORCE_ON(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_SEQ(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_SEQ_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_STBC() \
        GP_WB_READ_U1(0x850, 2)

#define GP_WB_GET_STANDBY_FON_CLK_STBC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_STBC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_STBC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_RTM() \
        GP_WB_READ_U1(0x850, 3)

#define GP_WB_GET_STANDBY_FON_CLK_RTM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_RTM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_RTM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_ES_TIMEREF() \
        GP_WB_READ_U1(0x850, 4)

#define GP_WB_GET_STANDBY_FON_CLK_ES_TIMEREF_FROM_FORCE_ON(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_ES_TIMEREF_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_ES_EVENT() \
        GP_WB_READ_U1(0x850, 5)

#define GP_WB_GET_STANDBY_FON_CLK_ES_EVENT_FROM_FORCE_ON(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_ES_EVENT_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_GPIO() \
        GP_WB_READ_U1(0x850, 6)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_GPIO_FROM_FORCE_ON(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_GPIO_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SSP() \
        GP_WB_READ_U1(0x850, 7)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SSP_FROM_FORCE_ON(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x850, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SSP_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_COEX() \
        GP_WB_READ_U1(0x851, 0)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_COEX_FROM_FORCE_ON(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_COEX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_COEX_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_IPC() \
        GP_WB_READ_U1(0x851, 1)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_IPC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_IPC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_IR() \
        GP_WB_READ_U1(0x851, 2)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_IR_FROM_FORCE_ON(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_IR_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_LED() \
        GP_WB_READ_U1(0x851, 3)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_LED_FROM_FORCE_ON(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_LED_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_ADCIF() \
        GP_WB_READ_U1(0x851, 4)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_ADCIF_FROM_FORCE_ON(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_ADCIF_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_KEYPAD() \
        GP_WB_READ_U1(0x851, 5)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_KEYPAD_FROM_FORCE_ON(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_KEYPAD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_KEYPAD_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_UART() \
        GP_WB_READ_U1(0x851, 6)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_UART_FROM_FORCE_ON(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_UART(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_UART_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SPI_M() \
        GP_WB_READ_U1(0x851, 7)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SPI_M_FROM_FORCE_ON(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x851, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SPI_M_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_TWI_M() \
        GP_WB_READ_U1(0x852, 0)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_TWI_M_FROM_FORCE_ON(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_TWI_M(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_TWI_M_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_WATCHDOG() \
        GP_WB_READ_U1(0x852, 1)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_WATCHDOG_FROM_FORCE_ON(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_WATCHDOG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_WATCHDOG_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SPI_S() \
        GP_WB_READ_U1(0x852, 2)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SPI_S_FROM_FORCE_ON(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SPI_S_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_TWI_S() \
        GP_WB_READ_U1(0x852, 3)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_TWI_S_FROM_FORCE_ON(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_TWI_S(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_TWI_S_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_DMA() \
        GP_WB_READ_U1(0x852, 4)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_DMA_FROM_FORCE_ON(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_DMA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_DMA_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_PWM() \
        GP_WB_READ_U1(0x852, 5)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_PWM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_PWM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PRG() \
        GP_WB_READ_U1(0x852, 6)

#define GP_WB_GET_STANDBY_FON_CLK_PRG_FROM_FORCE_ON(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PRG(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PRG_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PHY() \
        GP_WB_READ_U1(0x852, 7)

#define GP_WB_GET_STANDBY_FON_CLK_PHY_FROM_FORCE_ON(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PHY(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x852, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PHY_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MM_STBM() \
        GP_WB_READ_U1(0x853, 0)

#define GP_WB_GET_STANDBY_FON_CLK_MM_STBM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MM_STBM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MM_FLASH() \
        GP_WB_READ_U1(0x853, 1)

#define GP_WB_GET_STANDBY_FON_CLK_MM_FLASH_FROM_FORCE_ON(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MM_FLASH(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MM_FLASH_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MSI_CORE() \
        GP_WB_READ_U1(0x853, 2)

#define GP_WB_GET_STANDBY_FON_CLK_MSI_CORE_FROM_FORCE_ON(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MSI_CORE_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* forces on the clock to the iob regmap when '1' */
#define GP_WB_READ_STANDBY_FON_CLK_IOB() \
        GP_WB_READ_U1(0x853, 3)

#define GP_WB_GET_STANDBY_FON_CLK_IOB_FROM_FORCE_ON(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_IOB(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_IOB_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_PMUD() \
        GP_WB_READ_U1(0x853, 4)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_PMUD_FROM_FORCE_ON(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_PMUD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_PMUD_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* forces on the clock to the qta regmap (and logic) when  '1' */
#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(0x853, 5)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_RTM_QTA_FROM_FORCE_ON(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_RTM_QTA_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_MM() \
        GP_WB_READ_U1(0x853, 6)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_MM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_MM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(0x853, 7)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL_FROM_FORCE_ON(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x853, 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x017FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(0x854, 0)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_PBM_ADMIN_FROM_FORCE_ON(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x854, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_PBM_ADMIN_TO_FORCE_ON(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/***************************
 * layout: seqdma
 ***************************/

#define GP_WB_WRITE_SEQDMA_START_COPY_CTRL(val) \
      GP_WB_WRITE_U8(0x880, (val))

/* Starts the dma operation when set to '1' */
#define GP_WB_SEQDMA_START_COPY() \
        GP_WB_WRITE_U8(0x880, 0x01)

#define GP_WB_SET_SEQDMA_START_COPY_TO_START_COPY_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* copy done interrupt clear */
#define GP_WB_SEQDMA_CLR_CPY_DONE_INT() \
        GP_WB_WRITE_U8(0x880, 0x02)

#define GP_WB_SET_SEQDMA_CLR_CPY_DONE_INT_TO_START_COPY_CTRL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Start pointer for dma action */
#define GP_WB_READ_SEQDMA_START_PTR() \
        GP_WB_READ_U24(0x882)

#define GP_WB_WRITE_SEQDMA_START_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x882, (val)); \
        } while (0)


/* Destination pointer for DMA operation */
#define GP_WB_READ_SEQDMA_DEST_PTR() \
        GP_WB_READ_U24(0x886)

#define GP_WB_WRITE_SEQDMA_DEST_PTR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07FFFF); \
          GP_WB_WRITE_U24(0x886, (val)); \
        } while (0)


/* Length of DMA operation - (actually length-1, putting 0 results in a 1 byte copy, 255 results into 256 byte copy) */
#define GP_WB_READ_SEQDMA_CPY_LENGTH() \
        GP_WB_READ_U8(0x889)

#define GP_WB_WRITE_SEQDMA_CPY_LENGTH(val) do { \
          GP_WB_WRITE_U8(0x889, (val)); \
        } while (0)


/* source block size for match operation */
#define GP_WB_READ_SEQDMA_BLOCK_SIZE() \
        GP_WB_READ_U8(0x88a)

#define GP_WB_WRITE_SEQDMA_BLOCK_SIZE(val) do { \
          GP_WB_WRITE_U8(0x88a, (val)); \
        } while (0)


/* Amount of byte to match */
#define GP_WB_READ_SEQDMA_MATCH_SIZE() \
        GP_WB_READ_U8(0x88b)

#define GP_WB_WRITE_SEQDMA_MATCH_SIZE(val) do { \
          GP_WB_WRITE_U8(0x88b, (val)); \
        } while (0)


/* Amount of bytes that use masked match - (iso using a = b, it uses (a AND b) = a) */
#define GP_WB_READ_SEQDMA_MATCH_MASK_SIZE() \
        GP_WB_READ_U8(0x88c)

#define GP_WB_WRITE_SEQDMA_MATCH_MASK_SIZE(val) do { \
          GP_WB_WRITE_U8(0x88c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEQDMA_CONFIG() \
        GP_WB_READ_U8(0x88d)

#define GP_WB_WRITE_SEQDMA_CONFIG(val) \
      GP_WB_WRITE_U8(0x88d, (val))

/* copy function: "000" -> copy start to dest, "001" : copy start xor dest to dest, "010" : copy start and dest to dest, "011" : copy start or dest to dest, "100" : Add start to Dest, "101" Compare Start with Dest, "110, 111" - reserved */
#define GP_WB_READ_SEQDMA_CPY_FUNCTION() \
        (GP_WB_READ_U8(0x88d) & 0x07)

#define GP_WB_GET_SEQDMA_CPY_FUNCTION_FROM_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_SEQDMA_CPY_FUNCTION(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x88d, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_SEQDMA_CPY_FUNCTION_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, the result of the and/or/xor operation will actually overwrite the destination memory location */
#define GP_WB_READ_SEQDMA_OVERWRITE_DEST_FOR_AND_OR_XOR() \
        GP_WB_READ_U1(0x88d, 3)

#define GP_WB_GET_SEQDMA_OVERWRITE_DEST_FOR_AND_OR_XOR_FROM_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SEQDMA_OVERWRITE_DEST_FOR_AND_OR_XOR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x88d, 3, (val)); \
        } while (0)

#define GP_WB_SET_SEQDMA_OVERWRITE_DEST_FOR_AND_OR_XOR_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set to 1, the result of the add operation will actually overwrite the destination memory location */
#define GP_WB_READ_SEQDMA_OVERWRITE_DEST_FOR_ADD() \
        GP_WB_READ_U1(0x88d, 4)

#define GP_WB_GET_SEQDMA_OVERWRITE_DEST_FOR_ADD_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SEQDMA_OVERWRITE_DEST_FOR_ADD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x88d, 4, (val)); \
        } while (0)

#define GP_WB_SET_SEQDMA_OVERWRITE_DEST_FOR_ADD_TO_CONFIG(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEQDMA_STATUS() \
        GP_WB_READ_U16(0x88e)

/* dma operation ongoing when '1' */
#define GP_WB_READ_SEQDMA_CPY_BUSY() \
        GP_WB_READ_U1(0x88e, 0)

#define GP_WB_GET_SEQDMA_CPY_BUSY_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* an error occured while doing dma operation. Error cleared on next dma operation */
#define GP_WB_READ_SEQDMA_CPY_ERR() \
        GP_WB_READ_U1(0x88e, 1)

#define GP_WB_GET_SEQDMA_CPY_ERR_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked dma operation done interrupt */
#define GP_WB_READ_SEQDMA_CPY_DONE_UNMASKED_INT() \
        GP_WB_READ_U1(0x88e, 2)

#define GP_WB_GET_SEQDMA_CPY_DONE_UNMASKED_INT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* result of compare operation */
#define GP_WB_READ_SEQDMA_EQUAL() \
        GP_WB_READ_U1(0x88e, 3)

#define GP_WB_GET_SEQDMA_EQUAL_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* result of match operation */
#define GP_WB_READ_SEQDMA_MATCH() \
        GP_WB_READ_U1(0x88e, 4)

#define GP_WB_GET_SEQDMA_MATCH_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* result of greater than operation */
#define GP_WB_READ_SEQDMA_A_GT_B() \
        GP_WB_READ_U1(0x88e, 5)

#define GP_WB_GET_SEQDMA_A_GT_B_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* result of less than operation */
#define GP_WB_READ_SEQDMA_A_LT_B() \
        GP_WB_READ_U1(0x88e, 6)

#define GP_WB_GET_SEQDMA_A_LT_B_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* source is all zero */
#define GP_WB_READ_SEQDMA_A_ALLZEROS() \
        GP_WB_READ_U1(0x88e, 7)

#define GP_WB_GET_SEQDMA_A_ALLZEROS_FROM_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)

/* source is all ones */
#define GP_WB_READ_SEQDMA_A_ALLONES() \
        GP_WB_READ_U1(0x88f, 0)

#define GP_WB_GET_SEQDMA_A_ALLONES_FROM_STATUS(tmp) \
        (((tmp) >> 8) & 0x01)

/* destination is all zero */
#define GP_WB_READ_SEQDMA_B_ALLZEROS() \
        GP_WB_READ_U1(0x88f, 1)

#define GP_WB_GET_SEQDMA_B_ALLZEROS_FROM_STATUS(tmp) \
        (((tmp) >> 9) & 0x01)

/* carry flag of addition */
#define GP_WB_READ_SEQDMA_CARRY() \
        GP_WB_READ_U1(0x88f, 2)

#define GP_WB_GET_SEQDMA_CARRY_FROM_STATUS(tmp) \
        (((tmp) >> 10) & 0x01)


/* offset indicating the start of th block that shows a match */
#define GP_WB_READ_SEQDMA_MATCH_OFFSET() \
        GP_WB_READ_U8(0x890)

/***************************
 * layout: seqproc
 ***************************/

/* trigger the program */
#define GP_WB_SEQPROC_START_PROGRAM() \
        GP_WB_WRITE_U8(0x8a0, 0x01)


/* Sets the byteaddress of the start 32bit instruction word of the sequencer main program (only 16 bits because seqproc uses 16 bit addressing. section offset is used to run the programm in a specific mem section- allowing to go beyond 16 bit addressing range) */
#define GP_WB_READ_SEQPROC_PROGRAM_START_PTR() \
        GP_WB_READ_U16(0x8a2)

#define GP_WB_WRITE_SEQPROC_PROGRAM_START_PTR(val) do { \
          GP_WB_WRITE_U16(0x8a2, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEQPROC_SECTION_OFFSETS() \
        GP_WB_READ_U8(0x8a4)

#define GP_WB_WRITE_SEQPROC_SECTION_OFFSETS(val) \
      GP_WB_WRITE_U8(0x8a4, (val))

/* Determines the memory section the sequencer operates in (3 msb bits of instruction memory address). This is needed because jump instructions only have a 16 bit jump address, where the memory map requires more bits */
#define GP_WB_READ_SEQPROC_PROGRAM_SECTION_OFFSET() \
        (GP_WB_READ_U8(0x8a4) & 0x07)

#define GP_WB_GET_SEQPROC_PROGRAM_SECTION_OFFSET_FROM_SECTION_OFFSETS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_SEQPROC_PROGRAM_SECTION_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x8a4, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_PROGRAM_SECTION_OFFSET_TO_SECTION_OFFSETS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Determines the data memory section offset for the sequencer (3 msb bits of data memory address). This is needed because data address bus is only 16 bits, but memory map is wider */
#define GP_WB_READ_SEQPROC_DATA_SECTION_OFFSET() \
        ((GP_WB_READ_U8(0x8a4) >> 3) & 0x07)

#define GP_WB_GET_SEQPROC_DATA_SECTION_OFFSET_FROM_SECTION_OFFSETS(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_SEQPROC_DATA_SECTION_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x8a4, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_SEQPROC_DATA_SECTION_OFFSET_TO_SECTION_OFFSETS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEQPROC_SHIFT_CONTROL() \
        GP_WB_READ_U8(0x8a5)

#define GP_WB_WRITE_SEQPROC_SHIFT_CONTROL(val) \
      GP_WB_WRITE_U8(0x8a5, (val))

/* Sets the shift by value for the memory mapped generic shifter */
#define GP_WB_READ_SEQPROC_SHIFT_AMOUNT() \
        (GP_WB_READ_U8(0x8a5) & 0x07)

#define GP_WB_GET_SEQPROC_SHIFT_AMOUNT_FROM_SHIFT_CONTROL(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_SEQPROC_SHIFT_AMOUNT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_MWRITE_U8(0x8a5, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_SHIFT_AMOUNT_TO_SHIFT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* default 0 is shifted in, if this propery is set, 1 is shifted in */
#define GP_WB_READ_SEQPROC_SHIFT_IN_1_NOT_0() \
        GP_WB_READ_U1(0x8a5, 3)

#define GP_WB_GET_SEQPROC_SHIFT_IN_1_NOT_0_FROM_SHIFT_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SEQPROC_SHIFT_IN_1_NOT_0(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x8a5, 3, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_SHIFT_IN_1_NOT_0_TO_SHIFT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set, the value of the msb (or lsb) bit will be shifted in */
#define GP_WB_READ_SEQPROC_SIGN_EXTEND() \
        GP_WB_READ_U1(0x8a5, 4)

#define GP_WB_GET_SEQPROC_SIGN_EXTEND_FROM_SHIFT_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SEQPROC_SIGN_EXTEND(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x8a5, 4, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_SIGN_EXTEND_TO_SHIFT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set, a barrel shift function is used (what is shifted out at one side is shifted in at the other) */
#define GP_WB_READ_SEQPROC_ROTATE() \
        GP_WB_READ_U1(0x8a5, 5)

#define GP_WB_GET_SEQPROC_ROTATE_FROM_SHIFT_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SEQPROC_ROTATE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x8a5, 5, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_ROTATE_TO_SHIFT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set, shift goes from right to left (so stuff shifted in at msb side and shifted out at lsb side) */
#define GP_WB_READ_SEQPROC_SHIFT_RIGHT_NOT_LEFT() \
        GP_WB_READ_U1(0x8a5, 6)

#define GP_WB_GET_SEQPROC_SHIFT_RIGHT_NOT_LEFT_FROM_SHIFT_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_SEQPROC_SHIFT_RIGHT_NOT_LEFT(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x8a5, 6, (val)); \
        } while (0)

#define GP_WB_SET_SEQPROC_SHIFT_RIGHT_NOT_LEFT_TO_SHIFT_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* Shifter input data */
#define GP_WB_READ_SEQPROC_SHIFT_DATA_IN() \
        GP_WB_READ_U8(0x8a6)

#define GP_WB_WRITE_SEQPROC_SHIFT_DATA_IN(val) do { \
          GP_WB_WRITE_U8(0x8a6, (val)); \
        } while (0)


/* Result of shift operator */
#define GP_WB_READ_SEQPROC_SHIFT_DATA_OUT() \
        GP_WB_READ_U8(0x8a7)


/* Indicates that there was a memory access failure in the core */
#define GP_WB_READ_SEQPROC_CORE_MEM_ERR() \
        GP_WB_READ_U1(0x8a8, 0)


/* Lsb of progam counter (byte address) */
#define GP_WB_READ_SEQPROC_CORE_DEBUG_PC() \
        GP_WB_READ_U24(0x8aa)


/* Internal r1 register value */
#define GP_WB_READ_SEQPROC_CORE_DEBUG_R1() \
        GP_WB_READ_U8(0x8ad)


/* Internal r2 register value */
#define GP_WB_READ_SEQPROC_CORE_DEBUG_R2() \
        GP_WB_READ_U8(0x8ae)


/* Internal r3 register value */
#define GP_WB_READ_SEQPROC_SEQ_CORE_DEBUG_R3() \
        GP_WB_READ_U8(0x8af)

/***************************
 * layout: macfilt
 ***************************/

/* 64 bit mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS() \
        GP_WB_READ_U64(0x1600)

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS(val) do { \
          GP_WB_WRITE_U64(0x1600, (val)); \
        } while (0)


/* 64 bit secondary mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS_ALT_A() \
        GP_WB_READ_U64(0x1608)

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS_ALT_A(val) do { \
          GP_WB_WRITE_U64(0x1608, (val)); \
        } while (0)


/* 64 bit tertiary mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS_ALT_B() \
        GP_WB_READ_U64(0x1610)

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS_ALT_B(val) do { \
          GP_WB_WRITE_U64(0x1610, (val)); \
        } while (0)


/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX() \
        GP_WB_READ_U8(0x1618)

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x1618, (val)); \
        } while (0)


/* Set to 1 if device if pan coordinator for primary pan */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR() \
        GP_WB_READ_U1(0x1619, 0)

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x1619, (val)); \
        } while (0)


/* primary pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID() \
        GP_WB_READ_U16(0x161a)

#define GP_WB_WRITE_MACFILT_PAN_ID(val) do { \
          GP_WB_WRITE_U16(0x161a, (val)); \
        } while (0)


/* Short address for the device within its primary PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS() \
        GP_WB_READ_U16(0x161c)

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS(val) do { \
          GP_WB_WRITE_U16(0x161c, (val)); \
        } while (0)


/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX_ALT_A() \
        GP_WB_READ_U8(0x161e)

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x161e, (val)); \
        } while (0)


/* Set to 1 if device if pan coordinator for secondary pan */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR_ALT_A() \
        GP_WB_READ_U1(0x161f, 0)

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x161f, (val)); \
        } while (0)


/* secondary pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID_ALT_A() \
        GP_WB_READ_U16(0x1620)

#define GP_WB_WRITE_MACFILT_PAN_ID_ALT_A(val) do { \
          GP_WB_WRITE_U16(0x1620, (val)); \
        } while (0)


/* Short address for the device within its secondary PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS_ALT_A() \
        GP_WB_READ_U16(0x1622)

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS_ALT_A(val) do { \
          GP_WB_WRITE_U16(0x1622, (val)); \
        } while (0)


/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX_ALT_B() \
        GP_WB_READ_U8(0x1624)

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_WRITE_U8(0x1624, (val)); \
        } while (0)


/* Set to 1 if device if pan coordinator for tertiary pan */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR_ALT_B() \
        GP_WB_READ_U1(0x1625, 0)

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_WRITE_U8(0x1625, (val)); \
        } while (0)


/* third pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID_ALT_B() \
        GP_WB_READ_U16(0x1626)

#define GP_WB_WRITE_MACFILT_PAN_ID_ALT_B(val) do { \
          GP_WB_WRITE_U16(0x1626, (val)); \
        } while (0)


/* Short address for the device within third PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS_ALT_B() \
        GP_WB_READ_U16(0x1628)

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS_ALT_B(val) do { \
          GP_WB_WRITE_U16(0x1628, (val)); \
        } while (0)


/* Size-1 of the ext address table in bytes (0xFF means 256 bytes) */
#define GP_WB_READ_MACFILT_EXT_ADDR_TABLE_SIZE() \
        GP_WB_READ_U8(0x162a)

#define GP_WB_WRITE_MACFILT_EXT_ADDR_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(0x162a, (val)); \
        } while (0)


/* Indicates the effective size of the short src address table in bytes-1 (so 0XFF means 256 bytes) */
#define GP_WB_READ_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE() \
        GP_WB_READ_U8(0x162b)

#define GP_WB_WRITE_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(0x162b, (val)); \
        } while (0)


/* Indicates the effective size of the long src address table in bytes-1 (so 0XFF means 256 bytes) */
#define GP_WB_READ_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE() \
        GP_WB_READ_U8(0x162c)

#define GP_WB_WRITE_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(0x162c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_GENERIC_CONTROL() \
        GP_WB_READ_U8(0x162d)

#define GP_WB_WRITE_MACFILT_GENERIC_CONTROL(val) \
      GP_WB_WRITE_U8(0x162d, (val))

/* This sets the polarity of the src address search. When set to 0, the fp in the ack will be set to 0 when no match is found, and to 1 when a match is found. When set to 1, the opposite behavior is obtained */
#define GP_WB_READ_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND() \
        GP_WB_READ_U1(0x162d, 0)

#define GP_WB_GET_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND_FROM_GENERIC_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162d, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When enabled, all packets will be queued even if the macfilter would normally drop the frame. The pbm will indicate in the drop_reason field if the frame was dropped or not */
#define GP_WB_READ_MACFILT_ENABLE_SNIFFING() \
        GP_WB_READ_U1(0x162d, 1)

#define GP_WB_GET_MACFILT_ENABLE_SNIFFING_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ENABLE_SNIFFING(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162d, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ENABLE_SNIFFING_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Cmd type that can be filtered on */
#define GP_WB_READ_MACFILT_CMD_TYPE() \
        GP_WB_READ_U8(0x162e)

#define GP_WB_WRITE_MACFILT_CMD_TYPE(val) do { \
          GP_WB_WRITE_U8(0x162e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_TYPE_ACCEPT() \
        GP_WB_READ_U8(0x162f)

#define GP_WB_WRITE_MACFILT_FRAME_TYPE_ACCEPT(val) \
      GP_WB_WRITE_U8(0x162f, (val))

/* When 1, frames of type beacon will be accepted by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_BCN() \
        GP_WB_READ_U1(0x162f, 0)

#define GP_WB_GET_MACFILT_ACCEPT_FT_BCN_FROM_FRAME_TYPE_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_BCN(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_BCN_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, frames of type data will be accepted by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_DATA() \
        GP_WB_READ_U1(0x162f, 1)

#define GP_WB_GET_MACFILT_ACCEPT_FT_DATA_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_DATA(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_DATA_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, frames of type ack will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_ACK() \
        GP_WB_READ_U1(0x162f, 2)

#define GP_WB_GET_MACFILT_ACCEPT_FT_ACK_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_ACK(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_ACK_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, frames of type beacon will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_CMD() \
        GP_WB_READ_U1(0x162f, 3)

#define GP_WB_GET_MACFILT_ACCEPT_FT_CMD_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_CMD(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_CMD_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, frames of reserved frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_RSV_4() \
        GP_WB_READ_U1(0x162f, 4)

#define GP_WB_GET_MACFILT_ACCEPT_FT_RSV_4_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_RSV_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_RSV_4_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, frames of reserved frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_RSV_5() \
        GP_WB_READ_U1(0x162f, 5)

#define GP_WB_GET_MACFILT_ACCEPT_FT_RSV_5_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_RSV_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_RSV_5_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1, frames of reserved frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_RSV_6() \
        GP_WB_READ_U1(0x162f, 6)

#define GP_WB_GET_MACFILT_ACCEPT_FT_RSV_6_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_RSV_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_RSV_6_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1, frames of reserved frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_RSV_7() \
        GP_WB_READ_U1(0x162f, 7)

#define GP_WB_GET_MACFILT_ACCEPT_FT_RSV_7_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_RSV_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x162f, 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_RSV_7_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_VERSION_ACCEPT() \
        GP_WB_READ_U8(0x1630)

#define GP_WB_WRITE_MACFILT_FRAME_VERSION_ACCEPT(val) \
      GP_WB_WRITE_U8(0x1630, (val))

/* When 1, frames of frames using the 2003 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2003() \
        GP_WB_READ_U1(0x1630, 0)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2003_FROM_FRAME_VERSION_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2003(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2003_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, frames of frames using the 2006 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2006() \
        GP_WB_READ_U1(0x1630, 1)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2006_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2006(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2006_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, frames of frames using the 2010 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2010() \
        GP_WB_READ_U1(0x1630, 2)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2010_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2010(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2010_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_3() \
        GP_WB_READ_U1(0x1630, 3)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_3_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_3(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_3_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_4() \
        GP_WB_READ_U1(0x1630, 4)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_4_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_4(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_4_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_5() \
        GP_WB_READ_U1(0x1630, 5)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_5_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_5(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_5_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_6() \
        GP_WB_READ_U1(0x1630, 6)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_6_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_6(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_6_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_7() \
        GP_WB_READ_U1(0x1630, 7)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_7_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_7(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1630, 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_7_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_ADDRESSING_ACCEPT() \
        GP_WB_READ_U8(0x1631)

#define GP_WB_WRITE_MACFILT_FRAME_ADDRESSING_ACCEPT(val) \
      GP_WB_WRITE_U8(0x1631, (val))

/* When 1, beacon frames with src address mode set to 0 will be accepted. Default is 0, used to filter out all zero packets */
#define GP_WB_READ_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00() \
        GP_WB_READ_U1(0x1631, 0)

#define GP_WB_GET_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1631, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1 (=default), broadcast destination addressing will be accepted. Use this setting to filter out broadcast packets */
#define GP_WB_READ_MACFILT_ACCEPT_BCAST_DADDR() \
        GP_WB_READ_U1(0x1631, 1)

#define GP_WB_GET_MACFILT_ACCEPT_BCAST_DADDR_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_BCAST_DADDR(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1631, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_BCAST_DADDR_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1 (=default), broadcast pan id-s will be accepted. Use this setting to filter out packets using broadcast */
#define GP_WB_READ_MACFILT_ACCEPT_BCAST_PAN_ID() \
        GP_WB_READ_U1(0x1631, 2)

#define GP_WB_GET_MACFILT_ACCEPT_BCAST_PAN_ID_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_BCAST_PAN_ID(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1631, 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_BCAST_PAN_ID_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_CHECKS() \
        GP_WB_READ_U8(0x1632)

#define GP_WB_WRITE_MACFILT_FRAME_CHECKS(val) \
      GP_WB_WRITE_U8(0x1632, (val))

/* When 1, the src pan id is checked for beacon frames, and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON() \
        GP_WB_READ_U1(0x1632, 0)

#define GP_WB_GET_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1632, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, the src pan id is checked for data/cmd frames, and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON() \
        GP_WB_READ_U1(0x1632, 1)

#define GP_WB_GET_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1632, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, the destination pan id is checked and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_DST_PAN_ID_CHECK_ON() \
        GP_WB_READ_U1(0x1632, 2)

#define GP_WB_GET_MACFILT_DST_PAN_ID_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_DST_PAN_ID_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1632, 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DST_PAN_ID_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, the src addr is checked and the frame is accepted when the src address matches the address set by short_addr (or extended addresss) */
#define GP_WB_READ_MACFILT_DST_ADDR_CHECK_ON() \
        GP_WB_READ_U1(0x1632, 3)

#define GP_WB_GET_MACFILT_DST_ADDR_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_DST_ADDR_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1632, 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DST_ADDR_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, the cmd type is checked and the frame is accepted when the command type matches */
#define GP_WB_READ_MACFILT_CMD_TYPE_CHECK_ON() \
        GP_WB_READ_U1(0x1632, 4)

#define GP_WB_GET_MACFILT_CMD_TYPE_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_CMD_TYPE_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1632, 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_CMD_TYPE_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_TO_QUEUE_ENABLES() \
        GP_WB_READ_U8(0x1633)

#define GP_WB_WRITE_MACFILT_FRAME_TO_QUEUE_ENABLES(val) \
      GP_WB_WRITE_U8(0x1633, (val))

/* When 1, beacon frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_BCN_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 0)

#define GP_WB_GET_MACFILT_FT_BCN_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_BCN_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_BCN_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, data frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_DATA_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 1)

#define GP_WB_GET_MACFILT_FT_DATA_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_DATA_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_DATA_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, ack frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_ACK_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 2)

#define GP_WB_GET_MACFILT_FT_ACK_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_ACK_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_ACK_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, cmd frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_CMD_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 3)

#define GP_WB_GET_MACFILT_FT_CMD_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_CMD_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_CMD_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, reserved frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_RSV_4_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 4)

#define GP_WB_GET_MACFILT_FT_RSV_4_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_RSV_4_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_RSV_4_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, reserved frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_RSV_5_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 5)

#define GP_WB_GET_MACFILT_FT_RSV_5_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_RSV_5_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_RSV_5_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1, reserved frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_RSV_6_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 6)

#define GP_WB_GET_MACFILT_FT_RSV_6_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_RSV_6_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_RSV_6_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1, reserved frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_RSV_7_TO_QUEUE() \
        GP_WB_READ_U1(0x1633, 7)

#define GP_WB_GET_MACFILT_FT_RSV_7_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_RSV_7_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_MWRITE_U1(0x1633, 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_RSV_7_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Sequence number place holder register for the sequence number of ongoing transmission */
#define GP_WB_READ_MACFILT_TX_SEQ_NUMBER() \
        GP_WB_READ_U8(0x1634)

#define GP_WB_WRITE_MACFILT_TX_SEQ_NUMBER(val) do { \
          GP_WB_WRITE_U8(0x1634, (val)); \
        } while (0)


/* placeholder to put a broadcast mask (so 0xFFFF) - needs to be inited */
#define GP_WB_READ_MACFILT_BROADCAST_MASK() \
        GP_WB_READ_U16(0x1636)

#define GP_WB_WRITE_MACFILT_BROADCAST_MASK(val) do { \
          GP_WB_WRITE_U16(0x1636, (val)); \
        } while (0)

/***************************
 * layout: event
 ***************************/

/* Execution time (2us units) */
#define GP_WB_READ_EVENT_EXECUTION_TIME(offset) \
        GP_WB_READ_U32((offset) + 0x000)

#define GP_WB_WRITE_EVENT_EXECUTION_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U32((offset) + 0x000, (val)); \
        } while (0)


/* Recurrence period (2us units) */
#define GP_WB_READ_EVENT_RECURRENCE_PERIOD(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_EVENT_RECURRENCE_PERIOD(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7FFFFFFF); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Recurrence Amount, event is executed (recurrence_amount+1) times */
#define GP_WB_READ_EVENT_RECURRENCE_AMOUNT(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_EVENT_RECURRENCE_AMOUNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* Customer data, free to be used in sw */
#define GP_WB_READ_EVENT_CUSTOM_DATA(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_WRITE_EVENT_CUSTOM_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_EVENT_OPTIONS_FIELD(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_EVENT_OPTIONS_FIELD(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x00c, (val))

/* Event execution is delayed by the amount of time specified by the Guard Time Selector */
#define GP_WB_READ_EVENT_ADD_GUARD_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 0)

#define GP_WB_GET_EVENT_ADD_GUARD_TIME_FROM_OPTIONS_FIELD(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_EVENT_ADD_GUARD_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 0, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_ADD_GUARD_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F1E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Event execution is advanced by the amount of time specified by the Guard Time Selector */
#define GP_WB_READ_EVENT_SUBTRACT_GUARD_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 1)

#define GP_WB_GET_EVENT_SUBTRACT_GUARD_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_EVENT_SUBTRACT_GUARD_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 1, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_SUBTRACT_GUARD_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F1D; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Event will always be executed, even when too late */
#define GP_WB_READ_EVENT_EXECUTE_IF_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 2)

#define GP_WB_GET_EVENT_EXECUTE_IF_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_EVENT_EXECUTE_IF_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 2, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_EXECUTE_IF_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F1B; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Prevents going to sleep as long as at least one event is active with prohibit_standby enabled */
#define GP_WB_READ_EVENT_PROHIBIT_STANDBY(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 3)

#define GP_WB_GET_EVENT_PROHIBIT_STANDBY_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_EVENT_PROHIBIT_STANDBY(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 3, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_PROHIBIT_STANDBY_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F17; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Event execution is delayed by the amount of time specified by Dither seed and Dither backoff exponent mask (in 320us units) */
#define GP_WB_READ_EVENT_ADD_DITHER_BACKOFF(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 4)

#define GP_WB_GET_EVENT_ADD_DITHER_BACKOFF_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_EVENT_ADD_DITHER_BACKOFF(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 4, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_ADD_DITHER_BACKOFF_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_FIRST_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 0)

#define GP_WB_GET_EVENT_INTERRUPT_ON_FIRST_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_FIRST_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 0, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_FIRST_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3E1F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_OTHERS_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 1)

#define GP_WB_GET_EVENT_INTERRUPT_ON_OTHERS_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_OTHERS_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 1, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_OTHERS_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3D1F; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_LAST_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 2)

#define GP_WB_GET_EVENT_INTERRUPT_ON_LAST_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_LAST_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 2, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_LAST_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3B1F; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_FIRST_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 3)

#define GP_WB_GET_EVENT_INTERRUPT_ON_FIRST_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_FIRST_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 3, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_FIRST_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x371F; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 4)

#define GP_WB_GET_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 4, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F1F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_LAST_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 5)

#define GP_WB_GET_EVENT_INTERRUPT_ON_LAST_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_LAST_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 5, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_LAST_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F1F; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_EVENT_STATE_RESULT_FIELD(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_EVENT_STATE_RESULT_FIELD(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00e, (val))

/* State field */
#define GP_WB_READ_EVENT_STATE_FIELD(offset) \
        (GP_WB_READ_U8((offset) + 0x00e) & 0x07)

#define GP_WB_GET_EVENT_STATE_FIELD_FROM_STATE_RESULT_FIELD(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_EVENT_STATE_FIELD(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_STATE_FIELD_TO_STATE_RESULT_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Result Field */
#define GP_WB_READ_EVENT_RESULT_FIELD(offset) \
        ((GP_WB_READ_U8((offset) + 0x00e) >> 4) & 0x03)

#define GP_WB_GET_EVENT_RESULT_FIELD_FROM_STATE_RESULT_FIELD(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_EVENT_RESULT_FIELD(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_EVENT_RESULT_FIELD_TO_STATE_RESULT_FIELD(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Event Type field */
#define GP_WB_READ_EVENT_TYPE_FIELD(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_EVENT_TYPE_FIELD(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)

/***************************
 * layout: pbm_format_z
 ***************************/

#define GP_WB_READ_PBM_FORMAT_Z_STATE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_FORMAT_Z_STATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_Z(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

/***************************
 * layout: pbm_format_r
 ***************************/

#define GP_WB_READ_PBM_FORMAT_R_STATE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_FORMAT_R_STATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PBM_FORMAT_R_RETURN_CODE(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_R_RX_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_PBM_FORMAT_R_RX_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x002, (val))

#define GP_WB_READ_PBM_FORMAT_R_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x002, 0)

#define GP_WB_GET_PBM_FORMAT_R_ANTENNA_FROM_RX_STATUS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ANTENNA_TO_RX_STATUS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_R_FCS_OK(offset) \
        GP_WB_READ_U1((offset) + 0x002, 1)

#define GP_WB_GET_PBM_FORMAT_R_FCS_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_FCS_OK(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_FCS_OK_TO_RX_STATUS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Holds the result of an ED scan - actually not used in rx */
#define GP_WB_READ_PBM_FORMAT_R_ED_RESULT(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_PBM_FORMAT_R_ED_RESULT(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_FORMAT_R_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_FRAME_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_WRITE_PBM_FORMAT_R_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_FRAME_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x009)

#define GP_WB_WRITE_PBM_FORMAT_R_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_LQI(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_WRITE_PBM_FORMAT_R_LQI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_RSSI(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_WRITE_PBM_FORMAT_R_RSSI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_R_CHANNEL_INFO(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL_INFO(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00c, (val))

#define GP_WB_READ_PBM_FORMAT_R_CHANNEL(offset) \
        (GP_WB_READ_U8((offset) + 0x00c) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_R_CHANNEL_FROM_CHANNEL_INFO(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00c, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_CHANNEL_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Channel bank the packet was received on */
#define GP_WB_READ_PBM_FORMAT_R_CHANNEL_IDX(offset) \
        ((GP_WB_READ_U8((offset) + 0x00c) >> 4) & 0x07)

#define GP_WB_GET_PBM_FORMAT_R_CHANNEL_IDX_FROM_CHANNEL_INFO(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00c, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_CHANNEL_IDX_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Indicates what indexes where configured to use the same channel as the channel this packet is received on */
#define GP_WB_READ_PBM_FORMAT_R_MATCHING_CH_IDX_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_PBM_FORMAT_R_MATCHING_CH_IDX_MASK(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x3F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)


/* Reason why frame was dropped. Should always be E_NO_DROP, except in sniffing mode where this will indicate if the frame is ok or not */
#define GP_WB_READ_PBM_FORMAT_R_DROP_REASON(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_PBM_FORMAT_R_DROP_REASON(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)


/* some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_FORMAT_R_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_PBM_FORMAT_R_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)

/***************************
 * layout: pbm_format_t
 ***************************/

#define GP_WB_READ_PBM_FORMAT_T_STATE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_FORMAT_T_STATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_T_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PBM_FORMAT_T_RETURN_CODE(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_TX_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x002, (val))

#define GP_WB_READ_PBM_FORMAT_T_TX_RETRY(offset) \
        (GP_WB_READ_U8((offset) + 0x002) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_TX_RETRY_FROM_TX_STATUS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_RETRY(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x002, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_RETRY_TO_TX_STATUS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_TX_FRM_PENDING(offset) \
        GP_WB_READ_U1((offset) + 0x002, 3)

#define GP_WB_GET_PBM_FORMAT_T_TX_FRM_PENDING_FROM_TX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_FRM_PENDING(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_FRM_PENDING_TO_TX_STATUS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* The number of CCA-s that were done for transmitting the packet - Only valid when csma-cca is enabled on the packet. If csma-cca is disabled, this field needs to be ignored as it will hold the value of the previous csma-cca run */
#define GP_WB_READ_PBM_FORMAT_T_TX_CCA_CNT(offset) \
        ((GP_WB_READ_U8((offset) + 0x002) >> 4) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_TX_CCA_CNT_FROM_TX_STATUS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_CCA_CNT(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x002, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_CCA_CNT_TO_TX_STATUS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Holds the result of an ED scan */
#define GP_WB_READ_PBM_FORMAT_T_ED_RESULT(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_PBM_FORMAT_T_ED_RESULT(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_T_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_FORMAT_T_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_T_FRAME_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_WRITE_PBM_FORMAT_T_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_T_FRAME_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x009)

#define GP_WB_WRITE_PBM_FORMAT_T_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_0(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_0(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00a, (val))

/* The length of first backoff slot will be forced to zero. */
#define GP_WB_READ_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0(offset) \
        GP_WB_READ_U1((offset) + 0x00a, 0)

#define GP_WB_GET_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0_FROM_GP_FLOW_CTRL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00a, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_CSMA_CA_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x00a, 1)

#define GP_WB_GET_PBM_FORMAT_T_GP_CSMA_CA_ENABLE_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CSMA_CA_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00a, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CSMA_CA_ENABLE_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK(offset) \
        GP_WB_READ_U1((offset) + 0x00a, 2)

#define GP_WB_GET_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00a, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_VQ_SEL(offset) \
        ((GP_WB_READ_U8((offset) + 0x00a) >> 3) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_GP_VQ_SEL_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_VQ_SEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00a, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_VQ_SEL_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x47; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set to the FLL frequency and dac calibration will be skipped. Not advised to do this though ... */
#define GP_WB_READ_PBM_FORMAT_T_GP_SKIP_CAL_TX(offset) \
        GP_WB_READ_U1((offset) + 0x00a, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_SKIP_CAL_TX_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_SKIP_CAL_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00a, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_SKIP_CAL_TX_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_1(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_1(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00b, (val))

#define GP_WB_READ_PBM_FORMAT_T_GP_CONFIRM_QUEUE(offset) \
        (GP_WB_READ_U8((offset) + 0x00b) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_CONFIRM_QUEUE_FROM_GP_FLOW_CTRL_1(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CONFIRM_QUEUE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00b, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CONFIRM_QUEUE_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_ACKED_MODE(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 2)

#define GP_WB_GET_PBM_FORMAT_T_GP_ACKED_MODE_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ACKED_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ACKED_MODE_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 3)

#define GP_WB_GET_PBM_FORMAT_T_GP_ANTENNA_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ANTENNA_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_FCS_INSERT_DIS(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 4)

#define GP_WB_GET_PBM_FORMAT_T_GP_FCS_INSERT_DIS_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FCS_INSERT_DIS(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_FCS_INSERT_DIS_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* the RX window is stopped when the PBM is full (from the TRC point of view this means it is not granted any PBM entry after reception of the last packet) */
#define GP_WB_READ_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 5)

#define GP_WB_GET_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_ED_SCAN(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_ED_SCAN_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ED_SCAN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ED_SCAN_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set, the value in gp_rx_duration will be taken into acount. */
#define GP_WB_READ_PBM_FORMAT_T_GP_RX_DURATION_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_RX_DURATION_VALID_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_RX_DURATION_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_RX_DURATION_VALID_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_2(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_2(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00c, (val))

/* Indicates to which stack, the pbm belongs. In a multichannel environment this will determine what channel in hte channel list will be changed during pre and post channel change */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x00c) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_IDX_FROM_GP_FLOW_CTRL_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00c, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_IDX_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The optional RX listening window will be started only if the expected ACK has the pending bit set */
#define GP_WB_READ_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 3)

#define GP_WB_GET_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Before each packet transmission (including retransmission), the MAC will check the status of this bits in the sequence CH0A_EN (first transmission), CH0B_EN (first retransmission), CH0C_EN (second retransmission), CH0A_EN (third retransmission) etc. If the bit being analyzed is set, the PHY channel will be set to the corresponding value (MM_GP_CHANNEL_CH0[A/B/C]) */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 4)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 5)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* If this bit is set, at the end of the transmission process the PHY channel will be set to the corresponding value */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH1_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH1_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH1_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH1_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_EXTERNAL_PA_FEM_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_PBM_FORMAT_T_EXTERNAL_PA_FEM_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00d, (val))

/* 4 general purpose mode bits that are output to the iob and can be put on pins during the TX phase. This allows for controlling external PA/FEM */
#define GP_WB_READ_PBM_FORMAT_T_GP_MODE_CTRL(offset) \
        (GP_WB_READ_U8((offset) + 0x00d) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_MODE_CTRL_FROM_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_MODE_CTRL(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00d, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_MODE_CTRL_TO_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Controls the way the internal antenna port is selected during TX */
#define GP_WB_READ_PBM_FORMAT_T_GP_ANTSEL_INT(offset) \
        ((GP_WB_READ_U8((offset) + 0x00d) >> 4) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_ANTSEL_INT_FROM_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ANTSEL_INT(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ANTSEL_INT_TO_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Controls the way the external antenna port is selected during TX */
#define GP_WB_READ_PBM_FORMAT_T_GP_ANTSEL_EXT(offset) \
        ((GP_WB_READ_U8((offset) + 0x00d) >> 6) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_ANTSEL_EXT_FROM_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ANTSEL_EXT(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00d, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ANTSEL_EXT_TO_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_OPTIONS(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_OPTIONS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00e, (val))

#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_PACKET_TX_PRIO(offset) \
        (GP_WB_READ_U8((offset) + 0x00e) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_COEX_PACKET_TX_PRIO_FROM_GP_COEX_OPTIONS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_PACKET_TX_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_COEX_PACKET_TX_PRIO_TO_GP_COEX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xF4; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_PACKET_TX_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 2)

#define GP_WB_GET_PBM_FORMAT_T_GP_COEX_PACKET_TX_REQ_EN_FROM_GP_COEX_OPTIONS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_PACKET_TX_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_COEX_PACKET_TX_REQ_EN_TO_GP_COEX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_ACK_RX_PRIO(offset) \
        ((GP_WB_READ_U8((offset) + 0x00e) >> 4) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_COEX_ACK_RX_PRIO_FROM_GP_COEX_OPTIONS(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_ACK_RX_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_COEX_ACK_RX_PRIO_TO_GP_COEX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x03); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_ACK_RX_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_COEX_ACK_RX_REQ_EN_FROM_GP_COEX_OPTIONS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_ACK_RX_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_COEX_ACK_RX_REQ_EN_TO_GP_COEX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0xB7; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_PBM_FORMAT_T_GP_COEX_GRANT_AWARE(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_COEX_GRANT_AWARE_FROM_GP_COEX_OPTIONS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_COEX_GRANT_AWARE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_COEX_GRANT_AWARE_TO_GP_COEX_OPTIONS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_PA_POWER_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_POWER_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00f, (val))

/* Desired Power for transmitted packet */
#define GP_WB_READ_PBM_FORMAT_T_TX_POWER(offset) \
        (GP_WB_READ_U8((offset) + 0x00f) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_TX_POWER_FROM_PA_POWER_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_POWER(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_POWER_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* selects the mid power band when 1 (expected range -13 db to +3dB */
#define GP_WB_READ_PBM_FORMAT_T_PA_LOW(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 4)

#define GP_WB_GET_PBM_FORMAT_T_PA_LOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_LOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_PA_LOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* selects the low power band when 1 (expected range -30 dBm to -13dBm) */
#define GP_WB_READ_PBM_FORMAT_T_PA_ULTRALOW(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 5)

#define GP_WB_GET_PBM_FORMAT_T_PA_ULTRALOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_ULTRALOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_PA_ULTRALOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_CSMA_CA_BE_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_PBM_FORMAT_T_CSMA_CA_BE_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x010, (val))

/* Min BE setting for the CSMA CA cycle - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MIN_BE(offset) \
        (GP_WB_READ_U8((offset) + 0x010) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_MIN_BE_FROM_CSMA_CA_BE_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_MIN_BE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x010, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MIN_BE_TO_CSMA_CA_BE_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Min BE setting for the CSMA CA cycle - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MAX_BE(offset) \
        ((GP_WB_READ_U8((offset) + 0x010) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_MAX_BE_FROM_CSMA_CA_BE_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_BE(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x010, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_BE_TO_CSMA_CA_BE_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_CSMA_CA_BO_RETRY_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_WRITE_PBM_FORMAT_T_CSMA_CA_BO_RETRY_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x011, (val))

/* Max backoffs to be performed - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MAX_CSMA_BACKOFFS(offset) \
        (GP_WB_READ_U8((offset) + 0x011) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_MAX_CSMA_BACKOFFS_FROM_CSMA_CA_BO_RETRY_SETTINGS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_CSMA_BACKOFFS(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x011, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_CSMA_BACKOFFS_TO_CSMA_CA_BO_RETRY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* MAx number of retries when  - always valid */
#define GP_WB_READ_PBM_FORMAT_T_MAX_FRAME_RETRIES(offset) \
        ((GP_WB_READ_U8((offset) + 0x011) >> 3) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_MAX_FRAME_RETRIES_FROM_CSMA_CA_BO_RETRY_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_FRAME_RETRIES(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x011, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_FRAME_RETRIES_TO_CSMA_CA_BO_RETRY_SETTINGS(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CHANGE_0(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CHANGE_0(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x012, (val))

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0A(offset) \
        (GP_WB_READ_U8((offset) + 0x012) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0A_FROM_GP_CHANNEL_CHANGE_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0A(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x012, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0A_TO_GP_CHANNEL_CHANGE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0B(offset) \
        ((GP_WB_READ_U8((offset) + 0x012) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0B_FROM_GP_CHANNEL_CHANGE_0(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0B(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x012, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0B_TO_GP_CHANNEL_CHANGE_0(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CHANGE_1(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CHANGE_1(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x013, (val))

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0C(offset) \
        (GP_WB_READ_U8((offset) + 0x013) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0C_FROM_GP_CHANNEL_CHANGE_1(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0C(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x013, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0C_TO_GP_CHANNEL_CHANGE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* gp_channel_ch1_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH1(offset) \
        ((GP_WB_READ_U8((offset) + 0x013) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH1_FROM_GP_CHANNEL_CHANGE_1(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH1(offset, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x013, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH1_TO_GP_CHANNEL_CHANGE_1(tmp, val) do { \
          GP_WB_RANGE_CHECK(val,  0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* If gp_rx_duration_valid=True, number of symbols the receiver will be enabled after the successfull transmission packet has been transmitted (if a packet needed to be transmitted). If transmission was not succesfull gp_force_rx_on_after_tx_fail has to be set to use this feature. In case of an ED scan this is has to be interpreted as the scan length. If it is equal to zero a single ED will be performed. */
#define GP_WB_READ_PBM_FORMAT_T_GP_RX_DURATION(offset) \
        GP_WB_READ_U24((offset) + 0x014)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_RX_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U24((offset) + 0x014, (val)); \
        } while (0)


/* some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_FORMAT_T_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_PBM_FORMAT_T_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)

#endif //GP_WB_PROP_H

